/*! For license information please see demo.js.LICENSE.txt */
(() => {
  "use strict";
  var t = {
      857: (t, e) => {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.AudioClip = void 0),
          (e.AudioClip = class {
            constructor(t, e, n, i = () => {}) {
              (this.audioTime = 0),
                (this.isPlaying = !1),
                (this.isPaused = !1),
                (this.isMuted = !1),
                (this.volume = 1),
                (this.name = t),
                (this.audioPath = e),
                (this.groupNode = n),
                (this.onAudioNodeLoad = i),
                this.Initialize();
            }
            Play(t = !1) {
              this.audioNode &&
                (t && (this.audioNode.loop = !0),
                this.audioNode.play(),
                (this.isPaused = !1),
                (this.isPlaying = !0));
            }
            Pause() {
              this.audioNode &&
                (this.audioNode.pause(), (this.isPaused = !0), (this.isPlaying = !1));
            }
            SetVolume(t) {
              this.audioNode && (t > 1 && (t = 1), (this.audioNode.volume = t));
            }
            Mute() {
              this.audioNode && (this.audioNode.muted = !0);
            }
            UnMute() {
              this.audioNode && (this.audioNode.muted = !1);
            }
            Initialize() {
              var t;
              if (this.groupNode) {
                let e = document.createElement("audio");
                (e.id = "audio-clip-" + this.name),
                  (e.src = this.audioPath),
                  (this.audioNode = e),
                  null === (t = this.groupNode) || void 0 === t || t.appendChild(this.audioNode),
                  this.onAudioNodeLoad && this.onAudioNodeLoad();
              }
            }
            Destroy() {
              this.audioNode && (this.Mute(), this.Pause(), this.audioNode.remove());
            }
          });
      },
      9: (t, e, n) => {
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.AudioManager = void 0);
        const i = n(857);
        e.AudioManager = class {
          constructor(t) {
            (this.audioGroups = []), (this.scene = t);
            let e = "audio-manager";
            if (!document.querySelector(`#${e}`)) {
              let t = document.createElement("div");
              (t.id = e),
                (t.style.position = "absolute"),
                this.CreateAudioGroup("default"),
                (this.root = t),
                document.body.appendChild(this.root);
            }
          }
          CreateAudioGroup(t) {
            if (this.root && !this.audioGroups.find((e) => e.groupName === t)) {
              let e = { groupName: t, audioClips: [], clipIndex: 0 },
                n = document.createElement("div");
              (n.id = `audio-group-${t.trim().toLowerCase()}`),
                (e.groupNode = n),
                this.root.appendChild(n),
                this.audioGroups.push(e);
            }
          }
          DeleteAudioGroup(t) {
            let e = this.audioGroups.find((e) => e.groupName === t);
            if (e) {
              let t = this.audioGroups.indexOf(e);
              e.audioClips.forEach((t) => {
                t.Destroy();
              }),
                this.audioGroups.splice(t, 1);
            }
          }
          CreateAudioClip(t, e, n, r = () => {}) {
            let s = this.audioGroups.find((e) => e.groupName === t);
            if (s && s.groupNode) {
              let t = new i.AudioClip(e, n, s.groupNode, r);
              s.audioClips.push(t), t.Initialize();
            } else {
              let t = this.audioGroups[0];
              if (t.groupNode) {
                let s = new i.AudioClip(e, n, t.groupNode, r);
                t.audioClips.push(s), s.Initialize();
              }
            }
          }
          RemoveAudioClip(t, e) {
            let n = this.audioGroups.find((e) => e.groupName === t);
            if (n) {
              let t = n.audioClips.find((t) => t.name === e);
              if (t) {
                let e = n.audioClips.indexOf(t);
                t.Destroy(), n.audioClips.splice(e, 1);
              }
            }
          }
          MuteAll() {
            this.audioGroups.forEach((t) => {
              t.audioClips.forEach((t) => {
                t.Mute();
              });
            });
          }
          UnMuteAll() {
            this.audioGroups.forEach((t) => {
              t.audioClips.forEach((t) => {
                t.UnMute();
              });
            });
          }
          MuteInGroup(t) {
            let e = this.audioGroups.find((e) => e.groupName === t);
            e &&
              e.audioClips.forEach((t) => {
                t.Mute();
              });
          }
          UnMuteInGroup(t) {
            let e = this.audioGroups.find((e) => e.groupName === t);
            e &&
              e.audioClips.forEach((t) => {
                t.UnMute();
              });
          }
          PauseAll() {
            this.audioGroups.forEach((t) => {
              t.audioClips.forEach((t) => {
                t.Pause();
              });
            });
          }
          UnPauseAll() {
            this.audioGroups.forEach((t) => {
              t.audioClips.forEach((t) => {
                t.Play();
              });
            });
          }
          PauseInGroup(t) {
            let e = this.audioGroups.find((e) => e.groupName === t);
            e &&
              e.audioClips.forEach((t) => {
                t.Pause();
              });
          }
          UnPauseInGroup(t) {
            let e = this.audioGroups.find((e) => e.groupName === t);
            e &&
              e.audioClips.forEach((t) => {
                t.Play();
              });
          }
          PlayNextInGroup(t, e = !1) {
            let n = this.audioGroups.find((e) => e.groupName === t);
            if (n) {
              let t = n.clipIndex;
              t + 1 <= n.audioClips.length - 1 && (t += 1);
              let i = n.audioClips[t];
              i && i.Play(e);
            }
          }
          PlayPreviousInGroup(t, e = !1) {
            let n = this.audioGroups.find((e) => e.groupName === t);
            if (n) {
              let t = n.clipIndex;
              t - 1 >= 0 && ((t -= 1), n.audioClips[t].Play(e));
            }
          }
          PlayRandomInGroup(t, e = !1) {
            let n = this.audioGroups.find((e) => e.groupName === t);
            if (n) {
              let t = Math.floor(Math.random() * n.audioClips.length);
              n.audioClips[t].Play(e);
            }
          }
        };
      },
      574: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.GameObject = void 0);
        const a = s(n(232)),
          o = n(365);
        e.GameObject = class {
          constructor(t, e, n = null, i = o.defaultPhysicsOptions) {
            (this.tags = []),
              (this.animations = []),
              (this.translation = new a.Vector3()),
              (this.phi = 0),
              (this.theta = 0),
              (this.isActive = !0),
              (this.scene = t),
              (this.name = e),
              n && (this._object = n),
              (this.PhysicsEngine = new o.PhysicsEngine(this, i)),
              this.Start();
          }
          Start() {
            console.log(`GAME_OBJECT:${this.name}`, this);
          }
          Instantiate() {
            this._object && this.scene.appScene.add(this._object), this.scene.objects.push(this);
          }
          Destroy() {
            this.OnDestroy(), this._object && this.scene.appScene.remove(this._object);
            let t = this.scene.objects.indexOf(this);
            this.scene.objects.splice(t, 1), (this.isActive = !1);
          }
          OnDestroy() {}
          Update() {
            this.isActive &&
              (null == this.PhysicsEngine._object &&
                null != this._object &&
                (this.PhysicsEngine._object = this._object),
              this.Physics());
          }
          Physics() {
            this._object &&
              this.PhysicsEngine.options.enabled &&
              (this.PhysicsEngine.CheckForCollisions(), this.PhysicsEngine.Gravity());
          }
          AddTag(t) {
            this.tags.includes(t) || this.tags.push(t);
          }
          RemoveTag(t) {
            let e = this.tags.indexOf(t);
            e > -1 && this.tags.splice(e, 1);
          }
          GetForwardVector(t = 1) {
            const e = new a.Quaternion();
            e.setFromAxisAngle(new a.Vector3(0, 1, 0), this.phi);
            const n = new a.Vector3(0, 0, -1);
            return n.applyQuaternion(e), n.multiplyScalar(t), n;
          }
          GetLeftVector(t = 1) {
            const e = new a.Quaternion();
            e.setFromAxisAngle(new a.Vector3(0, 1, 0), this.phi);
            const n = new a.Vector3(-1, 0, 0);
            return n.applyQuaternion(e), n.multiplyScalar(t), n;
          }
        };
      },
      854: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.MathHelpers = void 0);
        const a = s(n(232));
        e.MathHelpers = class {
          static DegreesToRadians(t) {
            return (t * Math.PI) / 180;
          }
          static GetForwardVector(t, e = 1) {
            const n = new a.Quaternion();
            n.setFromAxisAngle(new a.Vector3(0, 1, 0), t);
            const i = new a.Vector3(0, 0, -1);
            return i.applyQuaternion(n), i.multiplyScalar(e), i;
          }
          static GetLeftVector(t, e = 1) {
            const n = new a.Quaternion();
            n.setFromAxisAngle(new a.Vector3(0, 1, 0), t);
            const i = new a.Vector3(-1, 0, 0);
            return i.applyQuaternion(n), i.multiplyScalar(e), i;
          }
        };
      },
      878: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.ObjectLoader = void 0);
        const a = s(n(232)),
          o = n(867),
          l = n(574),
          c = n(365);
        e.ObjectLoader = class {
          constructor(t) {
            this.scene = t;
          }
          LoadGLTFModel(t, e = c.defaultPhysicsOptions, n = !0) {
            new o.GLTFLoader().load(
              t.modelPath,
              (i) => {
                var r, s, o, c;
                let h = [];
                i.animations && (h = i.animations);
                const u = i.scene;
                let d;
                if (
                  (u.scale.set(t.scale.x, t.scale.y, t.scale.z),
                  u.position.set(t.position.x, t.position.y, t.position.z),
                  u.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z),
                  t.texturePath)
                ) {
                  const e = new a.TextureLoader().load(t.texturePath);
                  (e.wrapS = a.RepeatWrapping),
                    (e.wrapT = a.RepeatWrapping),
                    e.repeat.set(
                      null !==
                        (s = null === (r = t.textureRepeat) || void 0 === r ? void 0 : r.x) &&
                        void 0 !== s
                        ? s
                        : 1,
                      null !==
                        (c = null === (o = t.textureRepeat) || void 0 === o ? void 0 : o.y) &&
                        void 0 !== c
                        ? c
                        : 1
                    ),
                    (d = new a.MeshStandardMaterial({
                      map: e,
                      color: t.color ? new a.Color(t.color) : 65280,
                    }));
                } else
                  d = new a.MeshBasicMaterial({ color: t.color ? new a.Color(t.color) : 65280 });
                u.traverse((t) => {
                  t instanceof a.Mesh && (t.material = d);
                });
                let p = new l.GameObject(this.scene, t.name, u, e);
                h.length > 0 && (p.animations = h),
                  this.scene.appScene.add(u),
                  n && p.Instantiate(),
                  t.onLoad && t.onLoad(p);
              },
              (e) => {
                t.onProgress && t.onProgress(e);
              },
              (e) => {
                t.onError && t.onError(e);
              }
            );
          }
        };
      },
      365: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            },
          a =
            (this && this.__awaiter) ||
            function (t, e, n, i) {
              return new (n || (n = Promise))(function (r, s) {
                function a(t) {
                  try {
                    l(i.next(t));
                  } catch (t) {
                    s(t);
                  }
                }
                function o(t) {
                  try {
                    l(i.throw(t));
                  } catch (t) {
                    s(t);
                  }
                }
                function l(t) {
                  var e;
                  t.done
                    ? r(t.value)
                    : ((e = t.value),
                      e instanceof n
                        ? e
                        : new n(function (t) {
                            t(e);
                          })).then(a, o);
                }
                l((i = i.apply(t, e || [])).next());
              });
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.PhysicsEngine = e.defaultPhysicsOptions = void 0);
        const o = s(n(232));
        e.defaultPhysicsOptions = { enabled: !0, mass: 1, useGravity: !0, collisionEnabled: !0 };
        class l {
          constructor(t, n = e.defaultPhysicsOptions) {
            (this.velocity = new o.Vector3(0, 0, 0)),
              (this.acceleration = new o.Vector3(0, 0, 0)),
              (this.momentum = 0),
              (this.collisions = [{ object: {}, direction: { x: 0, y: 0, z: 0 } }]),
              (this.classObject = t),
              (this.options = n);
          }
          CheckForCollisions() {
            if (!this.options.collisionEnabled || !this._object) return;
            this.collisions = [];
            const t = new o.Object3D();
            t.position.copy(this._object.position), this._object.add(t);
            const e = new o.Box3().setFromObject(t, !0),
              n = t.position.clone();
            this.classObject.scene.appScene.traverse((i) => {
              if (i !== t) {
                const t = new o.Box3().setFromObject(i, !0),
                  r = i.position.clone();
                if (e.intersectsBox(t)) {
                  const t = new o.Vector3().subVectors(r, n).normalize();
                  this.collisions.push({ object: i, direction: t });
                }
              }
            }),
              this._object.remove(t);
          }
          Gravity() {
            return a(this, void 0, void 0, function* () {
              if (!this.collisions.find((t) => -1 == t.direction.y)) {
                let t = new o.Vector3(...l.Yaxis);
                this.acceleration.y -= l.gravity;
                let e = t.multiplyScalar(this.acceleration.y);
                new o.Vector3(...this.classObject.translation).add(e);
              }
            });
          }
          CalcForce(t, e) {
            return t * e;
          }
        }
        (e.PhysicsEngine = l),
          (l.gravity = 9.8),
          (l.Xaxis = new o.Vector3(1, 0, 0)),
          (l.Yaxis = new o.Vector3(0, 1, 0)),
          (l.Zaxis = new o.Vector3(0, 0, 1));
      },
      165: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.Primitives = void 0);
        const a = s(n(232)),
          o = n(574),
          l = n(365),
          c = { name: "ambient-light", color: "#ffffff", intensity: 1 },
          h = {
            name: "point-light",
            color: "#ffffff",
            intensity: 1,
            distance: 2,
            decay: 2,
            position: { x: 0, y: 20, z: 0 },
          },
          u = {
            name: "directional-light",
            color: "#ffffff",
            intensity: 1,
            position: { x: 0, y: 20, z: 0 },
            target: { x: 0, y: 0, z: 0 },
          },
          d = {
            name: "spot-light",
            color: "#ffffff",
            intensity: 1,
            position: { x: 0, y: 20, z: 0 },
            target: { x: 0, y: 0, z: 0 },
          },
          p = {
            name: "cube",
            scale: { x: 1, y: 1, z: 1 },
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            color: "#ffffff",
            texturePath: null,
          },
          f = {
            name: "cone",
            scale: { x: 1, y: 1, z: 1 },
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            color: "#ffffff",
            texturePath: null,
          },
          m = {
            name: "sphere",
            scale: { x: 1, y: 1, z: 1 },
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            color: "#ffffff",
            texturePath: null,
          },
          g = {
            name: "cone",
            scale: { x: 1, y: 1, z: 1 },
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            color: "#ffffff",
            texturePath: null,
          };
        e.Primitives = class {
          constructor(t) {
            this.scene = t;
          }
          CreateSkyBox(t, e = !0) {
            var n, i, r, s;
            let l;
            if (t.texturePath) {
              const e = new a.TextureLoader().load(t.texturePath);
              (e.wrapS = a.RepeatWrapping),
                (e.wrapT = a.RepeatWrapping),
                e.repeat.set(
                  null !== (i = null === (n = t.textureRepeat) || void 0 === n ? void 0 : n.x) &&
                    void 0 !== i
                    ? i
                    : 1,
                  null !== (s = null === (r = t.textureRepeat) || void 0 === r ? void 0 : r.y) &&
                    void 0 !== s
                    ? s
                    : 1
                ),
                (l = new a.MeshStandardMaterial({
                  map: e,
                  color: t.color ? new a.Color(t.color) : 65280,
                  side: a.BackSide,
                }));
            } else
              l = new a.MeshBasicMaterial({
                color: t.color ? new a.Color(t.color) : 65280,
                side: a.BackSide,
              });
            let c = new a.BoxGeometry(t.scale.x, t.scale.y, t.scale.z),
              h = new a.Mesh(c, l),
              u = new o.GameObject(this.scene, t.name, h);
            return e && u.Instantiate(), u;
          }
          CreateAmbientLight(t = c, e = !0) {
            let n = new a.AmbientLight(t.color, t.intensity),
              i = new o.GameObject(this.scene, t.name, n);
            return e && i.Instantiate(), i;
          }
          CreatePointLight(t = h, e = !0) {
            let n = new a.PointLight(t.color, t.intensity, t.distance, t.decay);
            t.position && n.position.copy(new a.Vector3(t.position.x, t.position.y, t.position.z));
            let i = new o.GameObject(this.scene, t.name, n);
            return e && i.Instantiate(), i;
          }
          CreateDirectionalLight(t = u, e = !0) {
            var n, i, r;
            let s = new a.DirectionalLight(t.color, t.intensity);
            s.lookAt(
              new a.Vector3(
                null === (n = t.target) || void 0 === n ? void 0 : n.x,
                null === (i = t.target) || void 0 === i ? void 0 : i.y,
                null === (r = t.target) || void 0 === r ? void 0 : r.z
              )
            ),
              t.position &&
                s.position.copy(new a.Vector3(t.position.x, t.position.y, t.position.z));
            let l = new o.GameObject(this.scene, t.name, s);
            return e && l.Instantiate(), l;
          }
          CreateSpotLight(t = d, e = !0) {
            var n, i, r;
            let s = new a.SpotLight(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
            s.lookAt(
              new a.Vector3(
                null === (n = t.target) || void 0 === n ? void 0 : n.x,
                null === (i = t.target) || void 0 === i ? void 0 : i.y,
                null === (r = t.target) || void 0 === r ? void 0 : r.z
              )
            ),
              t.position &&
                s.position.copy(new a.Vector3(t.position.x, t.position.y, t.position.z));
            let l = new o.GameObject(this.scene, t.name, s);
            return e && l.Instantiate(), l;
          }
          CreateCube(t = p, e = l.defaultPhysicsOptions, n = !0) {
            var i, r, s, c;
            const h = new a.BoxGeometry(t.scale.x, t.scale.y, t.scale.z);
            let u;
            if (t.texturePath) {
              const e = new a.TextureLoader().load(t.texturePath);
              (e.wrapS = a.RepeatWrapping),
                (e.wrapT = a.RepeatWrapping),
                e.repeat.set(
                  null !== (r = null === (i = t.textureRepeat) || void 0 === i ? void 0 : i.x) &&
                    void 0 !== r
                    ? r
                    : 1,
                  null !== (c = null === (s = t.textureRepeat) || void 0 === s ? void 0 : s.y) &&
                    void 0 !== c
                    ? c
                    : 1
                ),
                (u = new a.MeshStandardMaterial({
                  map: e,
                  color: t.color ? new a.Color(t.color) : 65280,
                }));
            } else u = new a.MeshBasicMaterial({ color: t.color ? new a.Color(t.color) : 65280 });
            const d = new a.Mesh(h, u);
            d.position.set(t.position.x, t.position.y, t.position.z),
              d.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z);
            let f = new o.GameObject(this.scene, t.name, d, e);
            return n && f.Instantiate(), f;
          }
          CreateSphere(t = m, e = l.defaultPhysicsOptions, n = !0) {
            var i, r, s, c;
            const h = new a.SphereGeometry(t.scale.x, t.scale.y, t.scale.z);
            let u;
            if (t.texturePath) {
              const e = new a.TextureLoader().load(t.texturePath);
              (e.wrapS = a.RepeatWrapping),
                (e.wrapT = a.RepeatWrapping),
                e.repeat.set(
                  null !== (r = null === (i = t.textureRepeat) || void 0 === i ? void 0 : i.x) &&
                    void 0 !== r
                    ? r
                    : 1,
                  null !== (c = null === (s = t.textureRepeat) || void 0 === s ? void 0 : s.y) &&
                    void 0 !== c
                    ? c
                    : 1
                ),
                (u = new a.MeshStandardMaterial({
                  map: e,
                  color: t.color ? new a.Color(t.color) : 65280,
                }));
            } else u = new a.MeshBasicMaterial({ color: t.color ? new a.Color(t.color) : 65280 });
            const d = new a.Mesh(h, u);
            d.position.set(t.position.x, t.position.y, t.position.z),
              d.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z);
            let p = new o.GameObject(this.scene, t.name, d, e);
            return n && p.Instantiate(), p;
          }
          CreateCone(t = f, e = l.defaultPhysicsOptions, n = !0) {
            var i, r, s, c;
            const h = new a.ConeGeometry(t.scale.x, t.scale.y, t.scale.z);
            let u;
            if (t.texturePath) {
              const e = new a.TextureLoader().load(t.texturePath);
              (e.wrapS = a.RepeatWrapping),
                (e.wrapT = a.RepeatWrapping),
                e.repeat.set(
                  null !== (r = null === (i = t.textureRepeat) || void 0 === i ? void 0 : i.x) &&
                    void 0 !== r
                    ? r
                    : 1,
                  null !== (c = null === (s = t.textureRepeat) || void 0 === s ? void 0 : s.y) &&
                    void 0 !== c
                    ? c
                    : 1
                ),
                (u = new a.MeshStandardMaterial({
                  map: e,
                  color: t.color ? new a.Color(t.color) : 65280,
                }));
            } else u = new a.MeshBasicMaterial({ color: t.color ? new a.Color(t.color) : 65280 });
            const d = new a.Mesh(h, u);
            d.position.set(t.position.x, t.position.y, t.position.z),
              d.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z);
            let p = new o.GameObject(this.scene, t.name, d, e);
            return n && p.Instantiate(), p;
          }
          CreatePlane(t = g, e = l.defaultPhysicsOptions, n = !0) {
            var i, r, s, c;
            const h = new a.PlaneGeometry(t.scale.x, t.scale.z);
            let u;
            if (t.texturePath) {
              const e = new a.TextureLoader().load(t.texturePath);
              (e.wrapS = a.RepeatWrapping),
                (e.wrapT = a.RepeatWrapping),
                e.repeat.set(
                  null !== (r = null === (i = t.textureRepeat) || void 0 === i ? void 0 : i.x) &&
                    void 0 !== r
                    ? r
                    : 1,
                  null !== (c = null === (s = t.textureRepeat) || void 0 === s ? void 0 : s.y) &&
                    void 0 !== c
                    ? c
                    : 1
                ),
                (u = new a.MeshStandardMaterial({
                  map: e,
                  color: t.color ? new a.Color(t.color) : 65280,
                }));
            } else u = new a.MeshBasicMaterial({ color: t.color ? new a.Color(t.color) : 65280 });
            const d = new a.Mesh(h, u);
            d.position.set(t.position.x, t.position.y, t.position.z),
              d.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z);
            let p = new o.GameObject(this.scene, t.name, d, e);
            return n && p.Instantiate(), p;
          }
        };
      },
      338: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.Camera = void 0);
        const a = s(n(232)),
          o = n(574),
          l = n(365);
        class c extends o.GameObject {
          constructor(
            t,
            e,
            n,
            i,
            r,
            s = { x: 0, y: 0, z: 0 },
            o = { x: 0, y: 0, z: 0 },
            c = l.defaultPhysicsOptions
          ) {
            super(t, e, void 0, c),
              (this.name = e),
              (this.fov = n),
              (this.near = i),
              (this.far = r),
              (this.camera = new a.PerspectiveCamera(
                n,
                window.innerWidth / window.innerHeight,
                i,
                r
              )),
              (this._object = this.camera),
              this.camera.position.set(s.x, s.y, s.z),
              this.camera.rotation.set(o.x, o.y, o.z);
          }
          Update() {
            super.Update();
          }
          ShowWireFrame() {}
          RayCast() {}
          TeleportTo(t) {}
          TransitionTo(t, e) {}
        }
        e.Camera = c;
      },
      958: (t, e, n) => {
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.CameraManager = void 0);
        const i = n(413),
          r = n(338),
          s = n(365);
        e.CameraManager = class {
          constructor(t) {
            (this.cameras = []), (this.activeIndex = 0), (this.MainCamera = null), (this.scene = t);
          }
          Update() {
            this.cameras.forEach((t) => t.Update());
          }
          CreateCamera(t, e, n, i, s, a) {
            (t = t || "DefaultCamera"),
              (e = void 0 === e ? 75 : e),
              (n = void 0 === n ? 0.1 : n),
              (i = void 0 === i ? 1e3 : i);
            let o = new r.Camera(this.scene, t, e, n, i, s, a);
            this.cameras.push(o),
              this.scene && this.scene.appScene.add(o.camera),
              this.MainCamera || (this.MainCamera = o);
          }
          CreateFirstPersonCamera(
            t,
            e,
            n,
            r,
            a,
            o,
            l,
            c = i.defaultFristPersonCameraOptions,
            h = s.defaultPhysicsOptions
          ) {
            let u = new i.FirstPersonCamera(this.scene, t, e, n, r, a, o, l, c, h);
            this.cameras.push(u),
              this.scene.appScene.add(u.camera),
              this.MainCamera || (this.MainCamera = u);
          }
          CreateThirdPersonCamera() {}
          CreateFreeFlyCamera() {}
          CreateOrbitCamera() {}
          NextCamera() {
            this.activeIndex + 1 < this.cameras.length && this.activeIndex++,
              (this.MainCamera = this.cameras[this.activeIndex]);
          }
          PreviousCamera() {
            this.activeIndex - 1 >= 0 && this.activeIndex--,
              (this.MainCamera = this.cameras[this.activeIndex]);
          }
          SetActiveCameraIndex(t) {
            if (!(t >= 0 && t < this.cameras.length))
              throw new Error("Camera Index Out Of Bounds!");
            {
              let e = this.cameras[t];
              e ? ((this.activeIndex = t), (this.MainCamera = e)) : console.log("camera was null");
            }
          }
          SetActiveCameraByName(t) {
            let e = this.cameras.find((e) => e.name == t);
            if (!e) throw new Error("No Camera With Matching Name!");
            (this.activeIndex = this.cameras.indexOf(e)), (this.MainCamera = e);
          }
        };
      },
      413: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.FirstPersonCamera = e.defaultFristPersonCameraOptions = void 0);
        const a = s(n(232)),
          o = n(338),
          l = n(35),
          c = n(542),
          h = n(365);
        e.defaultFristPersonCameraOptions = {
          enableCameraBob: !1,
          cameraAcceleration: 0.25,
          useMomentum: !0,
          maxMoveOperations: 5,
          usePhysics: !0,
          enableJump: !1,
          jumpHeight: 1,
          enableCollision: !1,
          toggleLook: !0,
          keyDownLook: !0,
          lookToggleKeys: ["Escape"],
          lookHeldKeys: ["Mouse2"],
          forwardKeys: ["KeyW", "ArrowUp"],
          leftKeys: ["KeyA", "ArrowLeft"],
          backKeys: ["KeyS", "ArrowDown"],
          rightKeys: ["KeyD", "ArrowRight"],
          jumpKeys: ["Space"],
        };
        class u extends o.Camera {
          constructor(
            t,
            n,
            i,
            r,
            s,
            o,
            l,
            c,
            u = e.defaultFristPersonCameraOptions,
            d = h.defaultPhysicsOptions
          ) {
            super(t, n, i, r, s, o, l, d),
              (this.lookToggle = !0),
              (this.movementSpeed = 1),
              (this.translation = new a.Vector3(...this.camera.position)),
              (this.movementSpeed = c),
              (this.options = u),
              this.RegisterLook(),
              this.RegisterLookToggle(),
              this.RegisterMove();
          }
          Update() {
            super.Update(),
              this.scene.deltaTime < 0.001
                ? this.camera.position.lerp(this.translation, 1e3 * this.scene.deltaTime)
                : this.camera.position.lerp(this.translation, 0.5);
          }
          RegisterLookToggle() {
            this.options.toggleLook &&
              l.InputManager.RegisterHandler("keydown", () => {
                Array.from(l.InputManager.GetActiveKeys()).some((t) =>
                  this.options.lookToggleKeys.includes(t)
                ) && (this.lookToggle = !this.lookToggle);
              });
          }
          RegisterLook() {
            l.InputManager.RegisterHandler("mousemove", () => {
              let t = Array.from(l.InputManager.GetActiveKeys());
              if (this.options.toggleLook && !this.lookToggle) return;
              if (this.options.keyDownLook && !t.some((t) => this.options.lookHeldKeys.includes(t)))
                return;
              let e = l.InputManager.GetMouseDirection(),
                n = e.x / window.innerWidth,
                i = e.y / window.innerHeight;
              (this.phi += -n * this.movementSpeed),
                (this.theta = (0, c.clamp)(
                  this.theta + -i * this.movementSpeed,
                  -Math.PI / 3,
                  Math.PI / 3
                ));
              let r = new a.Quaternion();
              r.setFromAxisAngle(new a.Vector3(0, 1, 0), this.phi);
              let s = new a.Quaternion();
              s.setFromAxisAngle(new a.Vector3(1, 0, 0), this.theta);
              let o = new a.Quaternion();
              o.multiplyQuaternions(r, s), this.camera.rotation.setFromQuaternion(o);
            });
          }
          RegisterMove() {
            l.InputManager.RegisterHandler("keydown", () => {
              let t = Array.from(l.InputManager.GetActiveKeys()),
                e = 1;
              e = this.scene.deltaTime < 0.001 ? 500 * this.scene.deltaTime : 0.25;
              let n = this.GetForwardVector(this.movementSpeed * e),
                i = this.GetLeftVector(this.movementSpeed * e);
              t.some((t) => this.options.forwardKeys.includes(t)) && this.translation.add(n),
                t.some((t) => this.options.leftKeys.includes(t)) && this.translation.add(i),
                t.some((t) => this.options.backKeys.includes(t)) && this.translation.sub(n),
                t.some((t) => this.options.rightKeys.includes(t)) && this.translation.sub(i),
                this.options.enableJump &&
                  t.some((t) => this.options.jumpKeys.includes(t)) &&
                  this.Jump();
            });
          }
          Jump() {
            let t = new a.Vector3(0, 1, 0).multiplyScalar(this.options.jumpHeight);
            this.translation.add(t);
          }
        }
        e.FirstPersonCamera = u;
      },
      35: (t, e) => {
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.InputManager = void 0);
        class n {
          constructor() {
            console.log("creating new input manager"),
              (n.instance = this),
              window.addEventListener("keydown", (t) => {
                let e = t.code;
                n.Keys.add(e), n.previous_inputs.push(e), n.RunHandlers("keydown");
              }),
              window.addEventListener("keyup", (t) => {
                n.Keys.delete(t.code), n.RunHandlers("keyup");
              }),
              window.addEventListener("mousemove", (t) => {
                (n.prevMouseX = n.mouseX),
                  (n.prevMouseY = n.mouseY),
                  (n.mouseX = t.pageX - window.innerWidth / 2),
                  (n.mouseY = t.pageY - window.innerHeight / 2),
                  n.RunHandlers("mousemove");
              }),
              window.addEventListener("mousedown", (t) => {
                switch (t.button) {
                  case 1:
                    n.previous_inputs.push("Mouse1"), n.Keys.add("Mouse1");
                  case 2:
                    n.previous_inputs.push("Mouse2"), n.Keys.add("Mouse2");
                  default:
                    n.previous_inputs.push("_Mouse1"), n.Keys.add("_Mouse1");
                }
                n.RunHandlers("mousedown");
              }),
              window.addEventListener("mouseup", (t) => {
                switch (t.button) {
                  case 1:
                    n.Keys.delete("Mouse1");
                  case 2:
                    n.Keys.delete("Mouse2");
                  default:
                    n.Keys.delete("_Mouse1");
                }
                n.RunHandlers("mouseup");
              });
          }
          static GetMousePosition() {
            return { x: n.mouseX, y: n.mouseY };
          }
          static GetMouseDirection() {
            let t = n.mouseX - n.prevMouseX,
              e = n.mouseY - n.prevMouseY;
            return { x: t, y: e, magnitude: Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)) };
          }
          static GetActiveKeys() {
            return n.Keys;
          }
          static GetInputHistory() {
            return n.previous_inputs;
          }
          static RunHandlers(t) {
            for (const e of n.handlers) e.type === t && e.function();
          }
          static RegisterHandler(t, e) {
            if (!t) throw new Error("register event handler requires an event type");
            let i = { id: this.handlers.length + 1, function: e, type: t };
            return n.handlers.push(i), i;
          }
        }
        (e.InputManager = n),
          (n.mouseX = 0),
          (n.mouseY = 0),
          (n.prevMouseX = 0),
          (n.prevMouseY = 0),
          (n.previous_inputs = []),
          (n.Keys = new Set()),
          (n.handlers = []);
      },
      150: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.Scene = void 0);
        const a = s(n(232)),
          o = n(35),
          l = n(958),
          c = n(474),
          h = n(165),
          u = n(9);
        e.Scene = class {
          constructor(t, e = !1) {
            (this.isActive = !1),
              (this.objects = []),
              (this.frame = 0),
              (this.frame_counter = 0),
              (this.programStartTime = 0),
              (this.fpsStartTime = 0),
              (this.fpsCounter = null),
              (this.fps = 0),
              (this.avgFPS = 0),
              (this.deltaTime = 0),
              (this.currentTime = 0),
              (this.sceneName = t),
              (this.trackFPS = e),
              (this.appScene = new a.Scene()),
              (this.primitiveObjects = new h.Primitives(this)),
              (this.inputManager = new o.InputManager()),
              (this.cameraManager = new l.CameraManager(this)),
              (this.audioManager = new u.AudioManager(this)),
              window.addEventListener("resize", () => {
                var t, e;
                if (
                  null != this.renderer &&
                  null != this.parent &&
                  (null ===
                    (e =
                      null === (t = this.cameraManager) || void 0 === t ? void 0 : t.MainCamera) ||
                  void 0 === e
                    ? void 0
                    : e.camera) instanceof a.PerspectiveCamera
                ) {
                  const t = this.parent.clientWidth,
                    e = this.parent.clientHeight;
                  this.renderer.setSize(t, e),
                    this.cameraManager &&
                      this.cameraManager.MainCamera &&
                      ((this.cameraManager.MainCamera.camera.aspect = t / e),
                      this.cameraManager.MainCamera.camera.updateProjectionMatrix());
                }
              });
          }
          Start(t = () => {}) {
            return this.isActive
              ? new Promise((t) => t())
              : ((this.frame = 0),
                (this.frame_counter = 0),
                (this.programStartTime = 0),
                (this.isActive = !0),
                new Promise((e) => {
                  const n = () => {
                    let e = performance.now();
                    if (
                      (0 === this.frame && (this.programStartTime = performance.now()),
                      this.Update(),
                      !this.cameraManager)
                    )
                      throw new Error("Three js camera must be initialized to start the scene");
                    if (!this.cameraManager.MainCamera)
                      throw new Error("Three js camera must be initialized to start the scene");
                    if (!this.cameraManager.MainCamera.camera)
                      throw new Error("Three js camera must be initialized to start the scene");
                    if (!this.appScene)
                      throw new Error("Three js scene must be initialized to start the scene");
                    if (!this.renderer)
                      throw new Error("Renderer must be initialized to start the scene");
                    this.isActive &&
                      (requestAnimationFrame(n),
                      this.trackFPS &&
                        (0 === this.frame && (this.fpsStartTime = this.programStartTime),
                        (this.frame += 1),
                        (this.frame_counter += 1),
                        this.CalculateFPS()),
                      t(),
                      this.renderer.render(this.appScene, this.cameraManager.MainCamera.camera),
                      this.cameraManager.Update(),
                      c.UIManager.Update(),
                      (this.deltaTime = (performance.now() - e) / 1e3));
                  };
                  n(), e();
                }));
          }
          Stop() {
            this.isActive = !1;
          }
          Update() {
            this.previousFrame = Object.assign({}, this);
          }
          ShowFPS() {
            this.fpsCounter && (this.fpsCounter.style.display = "flex");
          }
          CalculateFPS() {
            this.currentTime = performance.now();
            let t = this.currentTime - this.programStartTime,
              e = this.currentTime - this.fpsStartTime;
            this.fpsStartTime || (this.fpsStartTime = this.currentTime),
              e >= 1e3 &&
                ((this.avgFPS = Math.floor(this.frame / (t / 1e3))),
                (this.fps = Math.floor(this.frame_counter / (e / 1e3))),
                (this.frame_counter = 0),
                (this.fpsStartTime = this.currentTime)),
              this.fpsCounter &&
                (this.fpsCounter.innerText = `fps: ${this.fps}, \navg: ${this.avgFPS}`);
          }
          HideFPS() {
            this.fpsCounter && (this.fpsCounter.style.display = "none");
          }
        };
      },
      979: function (t, e, n) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (t, e, n, i) {
                  void 0 === i && (i = n);
                  var r = Object.getOwnPropertyDescriptor(e, n);
                  (r && !("get" in r ? !e.__esModule : r.writable || r.configurable)) ||
                    (r = {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }),
                    Object.defineProperty(t, i, r);
                }
              : function (t, e, n, i) {
                  void 0 === i && (i = n), (t[i] = e[n]);
                }),
          r =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (t, e) {
                  Object.defineProperty(t, "default", { enumerable: !0, value: e });
                }
              : function (t, e) {
                  t.default = e;
                }),
          s =
            (this && this.__importStar) ||
            function (t) {
              if (t && t.__esModule) return t;
              var e = {};
              if (null != t)
                for (var n in t)
                  "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
              return r(e, t), e;
            };
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.SceneManager = void 0);
        const a = s(n(232)),
          o = n(150),
          l = n(474);
        e.SceneManager = class {
          constructor() {
            (this.scenes = []),
              (this.activeSceneIndex = 0),
              window.ActiveSceneManagers
                ? window.ActiveSceneManagers.push(this)
                : (window.ActiveSceneManagers = [this]),
              (this.UIManager = new l.UIManager());
          }
          CreateScene(t, e, n = !0, i = !0, r = !0) {
            if (this.scenes.find((t) => t.sceneName == e)) return;
            if (!t) return;
            let s = new o.Scene(e, r);
            if (
              ((s.parent = t),
              (s.canvas = document.createElement("canvas")),
              (s.canvas.id = e),
              s.parent.appendChild(s.canvas),
              s.canvas.addEventListener("contextmenu", function (t) {
                t.preventDefault();
              }),
              n && s.cameraManager.CreateCamera(),
              i && s.primitiveObjects.CreateAmbientLight(),
              (s.renderer = new a.WebGLRenderer({
                canvas: s.canvas,
                antialias: !0,
                powerPreference: "high-performance",
              })),
              s.renderer.setSize(t.clientWidth, t.clientHeight),
              r)
            ) {
              let t = document.querySelector("#" + s.sceneName + "-fps-counter");
              if (t) return void (s.fpsCounter = t);
              (s.fpsCounter = document.createElement("span")),
                (s.fpsCounter.id = s.sceneName + "-fps-counter"),
                document.body.appendChild(s.fpsCounter),
                (s.fpsCounter.innerText = `fps: ${s.fps}, avg: ${s.avgFPS}`),
                (s.fpsCounter.style.position = "absolute"),
                (s.fpsCounter.style.top = "5px"),
                (s.fpsCounter.style.left = "5px"),
                (s.fpsCounter.style.color = "#3ab3ff");
            }
            this.scenes.push(s), null == this.activeScene && (this.activeScene = s);
          }
          NextScene() {
            this.activeSceneIndex + 1 <= this.scenes.length &&
              ((this.activeSceneIndex += 1),
              this.activeScene && this.activeScene.Stop(),
              (this.activeScene = this.scenes[this.activeSceneIndex]),
              this.activeScene.Start());
          }
          PreviousScene() {
            this.activeSceneIndex - 1 >= 0 &&
              ((this.activeSceneIndex -= 1),
              this.activeScene && this.activeScene.Stop(),
              (this.activeScene = this.scenes[this.activeSceneIndex]),
              this.activeScene.Start());
          }
          LoadScene(t) {
            let e = this.scenes.find((e) => e.sceneName == t);
            e &&
              ((this.activeSceneIndex = this.scenes.indexOf(e)),
              this.activeScene && this.activeScene.Stop(),
              (this.activeScene = e),
              this.activeScene.Start());
          }
        };
      },
      485: (t, e, n) => {
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.Screen = void 0);
        const i = n(474);
        e.Screen = class {
          constructor(t, e, n, r) {
            (this.html = null),
              (this.name = t),
              fetch(e)
                .then((t) => t.text())
                .then((t) => {
                  (this.html = t),
                    i.UIManager.activeScreen == this && this.Initialize(i.UIManager.root);
                }),
              n && (this.onLoadFunction = n),
              r && (this.updateFunction = r);
          }
          Update() {
            this.updateFunction && this.updateFunction();
          }
          Initialize(t) {
            if (this.html) {
              let e = document.createElement("div");
              (e.id = "ui-screen-" + this.name),
                (e.innerHTML = this.html),
                (this.node = e),
                t instanceof HTMLElement && t.appendChild(this.node),
                this.onLoadFunction && this.onLoadFunction();
            }
          }
          Destroy() {
            this.node && i.UIManager.root.removeChild(this.node);
          }
        };
      },
      474: (t, e, n) => {
        Object.defineProperty(e, "__esModule", { value: !0 }), (e.UIManager = void 0);
        const i = n(485);
        class r {
          constructor(t) {
            let e = document.createElement("div");
            (e.id = "ui-manager-root"),
              document.body.appendChild(e),
              (r.root = e),
              (r.root.style.position = "absolute"),
              (r.root.style.height = "100%"),
              (r.root.style.width = "100%"),
              (r.root.style.cursor = "crosshair"),
              t && (r.screens = t);
          }
          static Update() {
            r.activeScreen.Update();
          }
          RegisterScreens(t, e = 0) {
            this.DestroyActiveScreen(),
              (r.screens = t),
              (r.screenIndex = e),
              (r.activeScreen = r.screens[r.screenIndex]),
              this.UpdateActiveScreen();
          }
          DestroyActiveScreen() {
            r.activeScreen instanceof i.Screen &&
              null != r.activeScreen.name &&
              r.activeScreen.Destroy();
          }
          UpdateActiveScreen() {
            r.activeScreen instanceof i.Screen && r.activeScreen.Initialize(r.root);
          }
          NextScreen() {
            r.screenIndex + 1 < r.screens.length &&
              (r.screenIndex++,
              this.DestroyActiveScreen(),
              (r.activeScreen = r.screens[r.screenIndex]),
              this.UpdateActiveScreen());
          }
          PreviousScreen() {
            r.screenIndex - 1 >= 0 &&
              (r.screenIndex--,
              this.DestroyActiveScreen(),
              (r.activeScreen = r.screens[r.screenIndex]),
              this.UpdateActiveScreen());
          }
          AdvanceToScreen(t) {
            let e = r.screens.find((e) => e.name == t);
            e &&
              ((r.screenIndex = r.screens.indexOf(e)),
              this.DestroyActiveScreen(),
              (r.activeScreen = e),
              this.UpdateActiveScreen());
          }
        }
        (e.UIManager = r), (r.screenIndex = 0);
      },
      922: (t, e, n) => {
        n.d(e, { Z: () => o });
        var i = n(537),
          r = n.n(i),
          s = n(645),
          a = n.n(s)()(r());
        a.push([
          t.id,
          "body {\n    margin: 0;\n    background-color: black;\n    min-height: 100vh;\n    min-width: 100vw;\n    display: flex;\n    justify-content: center;\n    overflow: hidden;\n    font-family: monospace;\n}\n\n#three-root {\n    height: 100vh;\n    width: 100vw;\n}\n\ncanvas {\n    height: 100% !important;\n    width: 100% !important;\n    background-color: black;\n    overflow: hidden;\n}",
          "",
          {
            version: 3,
            sources: ["webpack://./Demo/src/index.css"],
            names: [],
            mappings:
              "AAAA;IACI,SAAS;IACT,uBAAuB;IACvB,iBAAiB;IACjB,gBAAgB;IAChB,aAAa;IACb,uBAAuB;IACvB,gBAAgB;IAChB,sBAAsB;AAC1B;;AAEA;IACI,aAAa;IACb,YAAY;AAChB;;AAEA;IACI,uBAAuB;IACvB,sBAAsB;IACtB,uBAAuB;IACvB,gBAAgB;AACpB",
            sourcesContent: [
              "body {\r\n    margin: 0;\r\n    background-color: black;\r\n    min-height: 100vh;\r\n    min-width: 100vw;\r\n    display: flex;\r\n    justify-content: center;\r\n    overflow: hidden;\r\n    font-family: monospace;\r\n}\r\n\r\n#three-root {\r\n    height: 100vh;\r\n    width: 100vw;\r\n}\r\n\r\ncanvas {\r\n    height: 100% !important;\r\n    width: 100% !important;\r\n    background-color: black;\r\n    overflow: hidden;\r\n}",
            ],
            sourceRoot: "",
          },
        ]);
        const o = a;
      },
      287: (t, e, n) => {
        n.d(e, { Z: () => d });
        var i = n(537),
          r = n.n(i),
          s = n(645),
          a = n.n(s),
          o = n(667),
          l = n.n(o),
          c = new URL(n(145), n.b),
          h = a()(r()),
          u = l()(c);
        h.push([
          t.id,
          `@font-face {\n    font-family: 'BebasNeue';\n    src: url(${u});\n}\n\n.screen-one-outer {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n}\n\n\n.wasd-container {\n    position: absolute;\n    left: 5px;\n    bottom: 5px;\n    display: flex;\n    flex-direction: column;\n    padding: 20px;\n    border-radius: 20px;\n    background-color: rgba(0, 0, 0, 0.258);\n}\n\n.mouse-container {\n    position: absolute;\n    right: 5px;\n    bottom: 5px;\n    display: flex;\n    flex-direction: column;\n    padding: 20px;\n    border-radius: 20px;\n    background-color: rgba(0, 0, 0, 0.258);\n}\n\n.wasd-top {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 100%;\n    margin-bottom: 10px;\n}\n\n.wasd-bottom {\n    display: flex;\n    align-items: center;\n    justify-content: space-evenly;\n    width: fit-content;\n    margin-left: auto;\n    margin-right: auto;\n}\n\n.key {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border: 1px solid white;\n    color: black;\n    font-weight: bold;\n    background-color: white;\n    height: 45px;\n    width: 45px;\n    min-height: 45px;\n    min-width: 45px;\n    max-height: 45px;\n    max-width: 45px;\n    border-radius: 5px;\n    box-shadow: 0px 4px 0px 3px rgb(177, 176, 176);\n    margin-left: 10px;\n    margin-right: 10px;\n}\n\n\n.right-mouse {\n    max-height: 100px;\n}\n\n.welcome {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n}\n\n.text {\n    display: flex;\n    margin: 1px;\n    opacity: 0;\n    transition: opacity 2s linear;\n    font-family: 'BebasNeue';\n}\n\n.text-1 {\n    color: white;\n    font-size: 60px;\n    opacity: 0;\n}\n\n.text-2 {\n    color: white;\n    font-size: 60px;\n    opacity: 0;\n}\n\n.text-3 {\n    color: rgb(233, 254, 0);\n    font-size: 60px;\n    opacity: 0;\n}\n\n.text-4 {\n    color: rgb(0, 178, 254);\n    font-size: 45px;\n    background-color: transparent;\n    padding: 0;\n    opacity: 0;\n}`,
          "",
          {
            version: 3,
            sources: ["webpack://./Demo/src/ui/screenOne.css"],
            names: [],
            mappings:
              "AAAA;IACI,wBAAwB;IACxB,4CAA2C;AAC/C;;AAEA;IACI,kBAAkB;IAClB,YAAY;IACZ,WAAW;AACf;;;AAGA;IACI,kBAAkB;IAClB,SAAS;IACT,WAAW;IACX,aAAa;IACb,sBAAsB;IACtB,aAAa;IACb,mBAAmB;IACnB,sCAAsC;AAC1C;;AAEA;IACI,kBAAkB;IAClB,UAAU;IACV,WAAW;IACX,aAAa;IACb,sBAAsB;IACtB,aAAa;IACb,mBAAmB;IACnB,sCAAsC;AAC1C;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,WAAW;IACX,mBAAmB;AACvB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,6BAA6B;IAC7B,kBAAkB;IAClB,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,uBAAuB;IACvB,YAAY;IACZ,iBAAiB;IACjB,uBAAuB;IACvB,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,eAAe;IACf,gBAAgB;IAChB,eAAe;IACf,kBAAkB;IAClB,8CAA8C;IAC9C,iBAAiB;IACjB,kBAAkB;AACtB;;;AAGA;IACI,iBAAiB;AACrB;;AAEA;IACI,kBAAkB;IAClB,YAAY;IACZ,WAAW;IACX,aAAa;IACb,sBAAsB;IACtB,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;IACI,aAAa;IACb,WAAW;IACX,UAAU;IACV,6BAA6B;IAC7B,wBAAwB;AAC5B;;AAEA;IACI,YAAY;IACZ,eAAe;IACf,UAAU;AACd;;AAEA;IACI,YAAY;IACZ,eAAe;IACf,UAAU;AACd;;AAEA;IACI,uBAAuB;IACvB,eAAe;IACf,UAAU;AACd;;AAEA;IACI,uBAAuB;IACvB,eAAe;IACf,6BAA6B;IAC7B,UAAU;IACV,UAAU;AACd",
            sourcesContent: [
              "@font-face {\r\n    font-family: 'BebasNeue';\r\n    src: url('../assets/BebasNeue-Regular.ttf');\r\n}\r\n\r\n.screen-one-outer {\r\n    position: absolute;\r\n    height: 100%;\r\n    width: 100%;\r\n}\r\n\r\n\r\n.wasd-container {\r\n    position: absolute;\r\n    left: 5px;\r\n    bottom: 5px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    padding: 20px;\r\n    border-radius: 20px;\r\n    background-color: rgba(0, 0, 0, 0.258);\r\n}\r\n\r\n.mouse-container {\r\n    position: absolute;\r\n    right: 5px;\r\n    bottom: 5px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    padding: 20px;\r\n    border-radius: 20px;\r\n    background-color: rgba(0, 0, 0, 0.258);\r\n}\r\n\r\n.wasd-top {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: 100%;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.wasd-bottom {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-evenly;\r\n    width: fit-content;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n}\r\n\r\n.key {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    border: 1px solid white;\r\n    color: black;\r\n    font-weight: bold;\r\n    background-color: white;\r\n    height: 45px;\r\n    width: 45px;\r\n    min-height: 45px;\r\n    min-width: 45px;\r\n    max-height: 45px;\r\n    max-width: 45px;\r\n    border-radius: 5px;\r\n    box-shadow: 0px 4px 0px 3px rgb(177, 176, 176);\r\n    margin-left: 10px;\r\n    margin-right: 10px;\r\n}\r\n\r\n\r\n.right-mouse {\r\n    max-height: 100px;\r\n}\r\n\r\n.welcome {\r\n    position: absolute;\r\n    height: 100%;\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n}\r\n\r\n.text {\r\n    display: flex;\r\n    margin: 1px;\r\n    opacity: 0;\r\n    transition: opacity 2s linear;\r\n    font-family: 'BebasNeue';\r\n}\r\n\r\n.text-1 {\r\n    color: white;\r\n    font-size: 60px;\r\n    opacity: 0;\r\n}\r\n\r\n.text-2 {\r\n    color: white;\r\n    font-size: 60px;\r\n    opacity: 0;\r\n}\r\n\r\n.text-3 {\r\n    color: rgb(233, 254, 0);\r\n    font-size: 60px;\r\n    opacity: 0;\r\n}\r\n\r\n.text-4 {\r\n    color: rgb(0, 178, 254);\r\n    font-size: 45px;\r\n    background-color: transparent;\r\n    padding: 0;\r\n    opacity: 0;\r\n}",
            ],
            sourceRoot: "",
          },
        ]);
        const d = h;
      },
      645: (t) => {
        t.exports = function (t) {
          var e = [];
          return (
            (e.toString = function () {
              return this.map(function (e) {
                var n = "",
                  i = void 0 !== e[5];
                return (
                  e[4] && (n += "@supports (".concat(e[4], ") {")),
                  e[2] && (n += "@media ".concat(e[2], " {")),
                  i && (n += "@layer".concat(e[5].length > 0 ? " ".concat(e[5]) : "", " {")),
                  (n += t(e)),
                  i && (n += "}"),
                  e[2] && (n += "}"),
                  e[4] && (n += "}"),
                  n
                );
              }).join("");
            }),
            (e.i = function (t, n, i, r, s) {
              "string" == typeof t && (t = [[null, t, void 0]]);
              var a = {};
              if (i)
                for (var o = 0; o < this.length; o++) {
                  var l = this[o][0];
                  null != l && (a[l] = !0);
                }
              for (var c = 0; c < t.length; c++) {
                var h = [].concat(t[c]);
                (i && a[h[0]]) ||
                  (void 0 !== s &&
                    (void 0 === h[5] ||
                      (h[1] = "@layer"
                        .concat(h[5].length > 0 ? " ".concat(h[5]) : "", " {")
                        .concat(h[1], "}")),
                    (h[5] = s)),
                  n &&
                    (h[2]
                      ? ((h[1] = "@media ".concat(h[2], " {").concat(h[1], "}")), (h[2] = n))
                      : (h[2] = n)),
                  r &&
                    (h[4]
                      ? ((h[1] = "@supports (".concat(h[4], ") {").concat(h[1], "}")), (h[4] = r))
                      : (h[4] = "".concat(r))),
                  e.push(h));
              }
            }),
            e
          );
        };
      },
      667: (t) => {
        t.exports = function (t, e) {
          return (
            e || (e = {}),
            t
              ? ((t = String(t.__esModule ? t.default : t)),
                /^['"].*['"]$/.test(t) && (t = t.slice(1, -1)),
                e.hash && (t += e.hash),
                /["'() \t\n]|(%20)/.test(t) || e.needQuotes
                  ? '"'.concat(t.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"')
                  : t)
              : t
          );
        };
      },
      537: (t) => {
        t.exports = function (t) {
          var e = t[1],
            n = t[3];
          if (!n) return e;
          if ("function" == typeof btoa) {
            var i = btoa(unescape(encodeURIComponent(JSON.stringify(n)))),
              r = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(i),
              s = "/*# ".concat(r, " */");
            return [e].concat([s]).join("\n");
          }
          return [e].join("\n");
        };
      },
      379: (t) => {
        var e = [];
        function n(t) {
          for (var n = -1, i = 0; i < e.length; i++)
            if (e[i].identifier === t) {
              n = i;
              break;
            }
          return n;
        }
        function i(t, i) {
          for (var s = {}, a = [], o = 0; o < t.length; o++) {
            var l = t[o],
              c = i.base ? l[0] + i.base : l[0],
              h = s[c] || 0,
              u = "".concat(c, " ").concat(h);
            s[c] = h + 1;
            var d = n(u),
              p = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] };
            if (-1 !== d) e[d].references++, e[d].updater(p);
            else {
              var f = r(p, i);
              (i.byIndex = o), e.splice(o, 0, { identifier: u, updater: f, references: 1 });
            }
            a.push(u);
          }
          return a;
        }
        function r(t, e) {
          var n = e.domAPI(e);
          return (
            n.update(t),
            function (e) {
              if (e) {
                if (
                  e.css === t.css &&
                  e.media === t.media &&
                  e.sourceMap === t.sourceMap &&
                  e.supports === t.supports &&
                  e.layer === t.layer
                )
                  return;
                n.update((t = e));
              } else n.remove();
            }
          );
        }
        t.exports = function (t, r) {
          var s = i((t = t || []), (r = r || {}));
          return function (t) {
            t = t || [];
            for (var a = 0; a < s.length; a++) {
              var o = n(s[a]);
              e[o].references--;
            }
            for (var l = i(t, r), c = 0; c < s.length; c++) {
              var h = n(s[c]);
              0 === e[h].references && (e[h].updater(), e.splice(h, 1));
            }
            s = l;
          };
        };
      },
      569: (t) => {
        var e = {};
        t.exports = function (t, n) {
          var i = (function (t) {
            if (void 0 === e[t]) {
              var n = document.querySelector(t);
              if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement)
                try {
                  n = n.contentDocument.head;
                } catch (t) {
                  n = null;
                }
              e[t] = n;
            }
            return e[t];
          })(t);
          if (!i)
            throw new Error(
              "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
            );
          i.appendChild(n);
        };
      },
      216: (t) => {
        t.exports = function (t) {
          var e = document.createElement("style");
          return t.setAttributes(e, t.attributes), t.insert(e, t.options), e;
        };
      },
      565: (t, e, n) => {
        t.exports = function (t) {
          var e = n.nc;
          e && t.setAttribute("nonce", e);
        };
      },
      795: (t) => {
        t.exports = function (t) {
          if ("undefined" == typeof document)
            return { update: function () {}, remove: function () {} };
          var e = t.insertStyleElement(t);
          return {
            update: function (n) {
              !(function (t, e, n) {
                var i = "";
                n.supports && (i += "@supports (".concat(n.supports, ") {")),
                  n.media && (i += "@media ".concat(n.media, " {"));
                var r = void 0 !== n.layer;
                r && (i += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")),
                  (i += n.css),
                  r && (i += "}"),
                  n.media && (i += "}"),
                  n.supports && (i += "}");
                var s = n.sourceMap;
                s &&
                  "undefined" != typeof btoa &&
                  (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(
                    btoa(unescape(encodeURIComponent(JSON.stringify(s)))),
                    " */"
                  )),
                  e.styleTagTransform(i, t, e.options);
              })(e, t, n);
            },
            remove: function () {
              !(function (t) {
                if (null === t.parentNode) return !1;
                t.parentNode.removeChild(t);
              })(e);
            },
          };
        };
      },
      589: (t) => {
        t.exports = function (t, e) {
          if (e.styleSheet) e.styleSheet.cssText = t;
          else {
            for (; e.firstChild; ) e.removeChild(e.firstChild);
            e.appendChild(document.createTextNode(t));
          }
        };
      },
      145: (t, e, n) => {
        t.exports = n.p + "BebasNeue-Regular.ttf";
      },
      232: (t, e) => {
        const n = "160",
          i = 1,
          r = 2,
          s = 3,
          a = 100,
          o = 204,
          l = 205,
          c = 0,
          h = 1,
          u = 2,
          d = 0,
          p = 1,
          f = 2,
          m = 3,
          g = 4,
          _ = 5,
          v = 6,
          x = "attached",
          y = "detached",
          M = 300,
          S = 301,
          b = 302,
          E = 303,
          T = 304,
          A = 306,
          w = 1e3,
          R = 1001,
          C = 1002,
          L = 1003,
          P = 1004,
          I = 1005,
          U = 1006,
          N = 1007,
          D = 1008,
          O = 1009,
          B = 1012,
          F = 1013,
          z = 1014,
          H = 1015,
          G = 1016,
          k = 1017,
          V = 1018,
          W = 1020,
          X = 1023,
          j = 1026,
          q = 1027,
          Y = 1029,
          K = 1031,
          Z = 1033,
          J = 33776,
          Q = 33777,
          $ = 33778,
          tt = 33779,
          et = 35840,
          nt = 35841,
          it = 35842,
          rt = 35843,
          st = 36196,
          at = 37492,
          ot = 37496,
          lt = 37808,
          ct = 37809,
          ht = 37810,
          ut = 37811,
          dt = 37812,
          pt = 37813,
          ft = 37814,
          mt = 37815,
          gt = 37816,
          _t = 37817,
          vt = 37818,
          xt = 37819,
          yt = 37820,
          Mt = 37821,
          St = 36492,
          bt = 36494,
          Et = 36495,
          Tt = 36284,
          At = 36285,
          wt = 36286,
          Rt = 2300,
          Ct = 2301,
          Lt = 2302,
          Pt = 2400,
          It = 2401,
          Ut = 2402,
          Nt = 2501,
          Dt = 3e3,
          Ot = 3001,
          Bt = "",
          Ft = "srgb",
          zt = "srgb-linear",
          Ht = "display-p3",
          Gt = "display-p3-linear",
          kt = "linear",
          Vt = "srgb",
          Wt = "rec709",
          Xt = "p3",
          jt = 7680,
          qt = 35044,
          Yt = "300 es",
          Kt = 1035,
          Zt = 2e3,
          Jt = 2001;
        class Qt {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
              t.target = null;
            }
          }
        }
        const $t = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ];
        let te = 1234567;
        const ee = Math.PI / 180,
          ne = 180 / Math.PI;
        function ie() {
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0;
          return (
            $t[255 & t] +
            $t[(t >> 8) & 255] +
            $t[(t >> 16) & 255] +
            $t[(t >> 24) & 255] +
            "-" +
            $t[255 & e] +
            $t[(e >> 8) & 255] +
            "-" +
            $t[((e >> 16) & 15) | 64] +
            $t[(e >> 24) & 255] +
            "-" +
            $t[(63 & n) | 128] +
            $t[(n >> 8) & 255] +
            "-" +
            $t[(n >> 16) & 255] +
            $t[(n >> 24) & 255] +
            $t[255 & i] +
            $t[(i >> 8) & 255] +
            $t[(i >> 16) & 255] +
            $t[(i >> 24) & 255]
          ).toLowerCase();
        }
        function re(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function se(t, e) {
          return ((t % e) + e) % e;
        }
        function ae(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function oe(t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        }
        function le(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        function ce(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return t / 4294967295;
            case Uint16Array:
              return t / 65535;
            case Uint8Array:
              return t / 255;
            case Int32Array:
              return Math.max(t / 2147483647, -1);
            case Int16Array:
              return Math.max(t / 32767, -1);
            case Int8Array:
              return Math.max(t / 127, -1);
            default:
              throw new Error("Invalid component type.");
          }
        }
        function he(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return Math.round(4294967295 * t);
            case Uint16Array:
              return Math.round(65535 * t);
            case Uint8Array:
              return Math.round(255 * t);
            case Int32Array:
              return Math.round(2147483647 * t);
            case Int16Array:
              return Math.round(32767 * t);
            case Int8Array:
              return Math.round(127 * t);
            default:
              throw new Error("Invalid component type.");
          }
        }
        const ue = {
          DEG2RAD: ee,
          RAD2DEG: ne,
          generateUUID: ie,
          clamp: re,
          euclideanModulo: se,
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e);
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0;
          },
          lerp: ae,
          damp: function (t, e, n, i) {
            return ae(t, e, 1 - Math.exp(-n * i));
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(se(t, 2 * e) - e);
          },
          smoothstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          seededRandom: function (t) {
            void 0 !== t && (te = t);
            let e = (te += 1831565813);
            return (
              (e = Math.imul(e ^ (e >>> 15), 1 | e)),
              (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
              ((e ^ (e >>> 14)) >>> 0) / 4294967296
            );
          },
          degToRad: function (t) {
            return t * ee;
          },
          radToDeg: function (t) {
            return t * ne;
          },
          isPowerOfTwo: oe,
          ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
          },
          floorPowerOfTwo: le,
          setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const s = Math.cos,
              a = Math.sin,
              o = s(n / 2),
              l = a(n / 2),
              c = s((e + i) / 2),
              h = a((e + i) / 2),
              u = s((e - i) / 2),
              d = a((e - i) / 2),
              p = s((i - e) / 2),
              f = a((i - e) / 2);
            switch (r) {
              case "XYX":
                t.set(o * h, l * u, l * d, o * c);
                break;
              case "YZY":
                t.set(l * d, o * h, l * u, o * c);
                break;
              case "ZXZ":
                t.set(l * u, l * d, o * h, o * c);
                break;
              case "XZX":
                t.set(o * h, l * f, l * p, o * c);
                break;
              case "YXY":
                t.set(l * p, o * h, l * f, o * c);
                break;
              case "ZYZ":
                t.set(l * f, l * p, o * h, o * c);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    r
                );
            }
          },
          normalize: he,
          denormalize: ce,
        };
        class de {
          constructor(t = 0, e = 0) {
            (de.prototype.isVector2 = !0), (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6]), (this.y = i[1] * e + i[4] * n + i[7]), this
            );
          }
          min(t) {
            return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
          }
          max(t) {
            return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
          }
          floor() {
            return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
          }
          ceil() {
            return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
          }
          round() {
            return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
          }
          roundToZero() {
            return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(re(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
          }
          lerpVectors(t, e, n) {
            return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this;
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e) {
            return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              s = this.y - t.y;
            return (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this;
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y;
          }
        }
        class pe {
          constructor(t, e, n, i, r, s, a, o, l) {
            (pe.prototype.isMatrix3 = !0),
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              void 0 !== t && this.set(t, e, n, i, r, s, a, o, l);
          }
          set(t, e, n, i, r, s, a, o, l) {
            const c = this.elements;
            return (
              (c[0] = t),
              (c[1] = i),
              (c[2] = a),
              (c[3] = e),
              (c[4] = r),
              (c[5] = o),
              (c[6] = n),
              (c[7] = s),
              (c[8] = l),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              a = n[3],
              o = n[6],
              l = n[1],
              c = n[4],
              h = n[7],
              u = n[2],
              d = n[5],
              p = n[8],
              f = i[0],
              m = i[3],
              g = i[6],
              _ = i[1],
              v = i[4],
              x = i[7],
              y = i[2],
              M = i[5],
              S = i[8];
            return (
              (r[0] = s * f + a * _ + o * y),
              (r[3] = s * m + a * v + o * M),
              (r[6] = s * g + a * x + o * S),
              (r[1] = l * f + c * _ + h * y),
              (r[4] = l * m + c * v + h * M),
              (r[7] = l * g + c * x + h * S),
              (r[2] = u * f + d * _ + p * y),
              (r[5] = u * m + d * v + p * M),
              (r[8] = u * g + d * x + p * S),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8];
            return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o;
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8],
              h = c * s - a * l,
              u = a * o - c * r,
              d = l * r - s * o,
              p = e * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return (
              (t[0] = h * f),
              (t[1] = (i * l - c * n) * f),
              (t[2] = (a * n - i * s) * f),
              (t[3] = u * f),
              (t[4] = (c * e - i * o) * f),
              (t[5] = (i * r - a * e) * f),
              (t[6] = d * f),
              (t[7] = (n * o - l * e) * f),
              (t[8] = (s * e - n * r) * f),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, i, r, s, a) {
            const o = Math.cos(r),
              l = Math.sin(r);
            return (
              this.set(
                n * o,
                n * l,
                -n * (o * s + l * a) + s + t,
                -i * l,
                i * o,
                -i * (-l * s + o * a) + a + e,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(t, e) {
            return this.premultiply(fe.makeScale(t, e)), this;
          }
          rotate(t) {
            return this.premultiply(fe.makeRotation(-t)), this;
          }
          translate(t, e) {
            return this.premultiply(fe.makeTranslation(t, e)), this;
          }
          makeTranslation(t, e) {
            return (
              t.isVector2
                ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
                : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
              this
            );
          }
          makeRotation(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
          }
          makeScale(t, e) {
            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        const fe = new pe();
        function me(t) {
          for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
          return !1;
        }
        const ge = {
          Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
        };
        function _e(t, e) {
          return new ge[t](e);
        }
        function ve(t) {
          return document.createElementNS("http://www.w3.org/1999/xhtml", t);
        }
        function xe() {
          const t = ve("canvas");
          return (t.style.display = "block"), t;
        }
        const ye = {};
        function Me(t) {
          t in ye || ((ye[t] = !0), console.warn(t));
        }
        const Se = new pe().set(
            0.8224621,
            0.177538,
            0,
            0.0331941,
            0.9668058,
            0,
            0.0170827,
            0.0723974,
            0.9105199
          ),
          be = new pe().set(
            1.2249401,
            -0.2249404,
            0,
            -0.0420569,
            1.0420571,
            0,
            -0.0196376,
            -0.0786361,
            1.0982735
          ),
          Ee = {
            [zt]: { transfer: kt, primaries: Wt, toReference: (t) => t, fromReference: (t) => t },
            [Ft]: {
              transfer: Vt,
              primaries: Wt,
              toReference: (t) => t.convertSRGBToLinear(),
              fromReference: (t) => t.convertLinearToSRGB(),
            },
            [Gt]: {
              transfer: kt,
              primaries: Xt,
              toReference: (t) => t.applyMatrix3(be),
              fromReference: (t) => t.applyMatrix3(Se),
            },
            [Ht]: {
              transfer: Vt,
              primaries: Xt,
              toReference: (t) => t.convertSRGBToLinear().applyMatrix3(be),
              fromReference: (t) => t.applyMatrix3(Se).convertLinearToSRGB(),
            },
          },
          Te = new Set([zt, Gt]),
          Ae = {
            enabled: !0,
            _workingColorSpace: zt,
            get workingColorSpace() {
              return this._workingColorSpace;
            },
            set workingColorSpace(t) {
              if (!Te.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
              this._workingColorSpace = t;
            },
            convert: function (t, e, n) {
              if (!1 === this.enabled || e === n || !e || !n) return t;
              const i = Ee[e].toReference;
              return (0, Ee[n].fromReference)(i(t));
            },
            fromWorkingColorSpace: function (t, e) {
              return this.convert(t, this._workingColorSpace, e);
            },
            toWorkingColorSpace: function (t, e) {
              return this.convert(t, e, this._workingColorSpace);
            },
            getPrimaries: function (t) {
              return Ee[t].primaries;
            },
            getTransfer: function (t) {
              return t === Bt ? kt : Ee[t].transfer;
            },
          };
        function we(t) {
          return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function Re(t) {
          return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        let Ce;
        class Le {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === Ce && (Ce = ve("canvas")), (Ce.width = t.width), (Ce.height = t.height);
              const n = Ce.getContext("2d");
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = Ce);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  t
                ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
          static sRGBToLinear(t) {
            if (
              ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const e = ve("canvas");
              (e.width = t.width), (e.height = t.height);
              const n = e.getContext("2d");
              n.drawImage(t, 0, 0, t.width, t.height);
              const i = n.getImageData(0, 0, t.width, t.height),
                r = i.data;
              for (let t = 0; t < r.length; t++) r[t] = 255 * we(r[t] / 255);
              return n.putImageData(i, 0, 0), e;
            }
            if (t.data) {
              const e = t.data.slice(0);
              for (let t = 0; t < e.length; t++)
                e instanceof Uint8Array || e instanceof Uint8ClampedArray
                  ? (e[t] = Math.floor(255 * we(e[t] / 255)))
                  : (e[t] = we(e[t]));
              return { data: e, width: t.width, height: t.height };
            }
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              t
            );
          }
        }
        let Pe = 0;
        class Ie {
          constructor(t = null) {
            (this.isSource = !0),
              Object.defineProperty(this, "id", { value: Pe++ }),
              (this.uuid = ie()),
              (this.data = t),
              (this.version = 0);
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
            const n = { uuid: this.uuid, url: "" },
              i = this.data;
            if (null !== i) {
              let t;
              if (Array.isArray(i)) {
                t = [];
                for (let e = 0, n = i.length; e < n; e++)
                  i[e].isDataTexture ? t.push(Ue(i[e].image)) : t.push(Ue(i[e]));
              } else t = Ue(i);
              n.url = t;
            }
            return e || (t.images[this.uuid] = n), n;
          }
        }
        function Ue(t) {
          return ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ? Le.getDataURL(t)
            : t.data
            ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
            : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
        }
        let Ne = 0;
        class De extends Qt {
          constructor(
            t = De.DEFAULT_IMAGE,
            e = De.DEFAULT_MAPPING,
            n = 1001,
            i = 1001,
            r = 1006,
            s = 1008,
            a = 1023,
            o = 1009,
            l = De.DEFAULT_ANISOTROPY,
            c = ""
          ) {
            super(),
              (this.isTexture = !0),
              Object.defineProperty(this, "id", { value: Ne++ }),
              (this.uuid = ie()),
              (this.name = ""),
              (this.source = new Ie(t)),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.channel = 0),
              (this.wrapS = n),
              (this.wrapT = i),
              (this.magFilter = r),
              (this.minFilter = s),
              (this.anisotropy = l),
              (this.format = a),
              (this.internalFormat = null),
              (this.type = o),
              (this.offset = new de(0, 0)),
              (this.repeat = new de(1, 1)),
              (this.center = new de(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new pe()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              "string" == typeof c
                ? (this.colorSpace = c)
                : (Me("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                  (this.colorSpace = c === Ot ? Ft : Bt)),
              (this.userData = {}),
              (this.version = 0),
              (this.onUpdate = null),
              (this.isRenderTargetTexture = !1),
              (this.needsPMREMUpdate = !1);
          }
          get image() {
            return this.source.data;
          }
          set image(t = null) {
            this.source.data = t;
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.source = t.source),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.channel = t.channel),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.colorSpace = t.colorSpace),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              (this.needsUpdate = !0),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            const n = {
              metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(t).uuid,
              mapping: this.mapping,
              channel: this.channel,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              internalFormat: this.internalFormat,
              type: this.type,
              colorSpace: this.colorSpace,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              generateMipmaps: this.generateMipmaps,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            return (
              Object.keys(this.userData).length > 0 && (n.userData = this.userData),
              e || (t.textures[this.uuid] = n),
              n
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(t) {
            if (this.mapping !== M) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case w:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case R:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case C:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case w:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case R:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case C:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && (this.version++, (this.source.needsUpdate = !0));
          }
          get encoding() {
            return (
              Me("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
              this.colorSpace === Ft ? Ot : Dt
            );
          }
          set encoding(t) {
            Me("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
              (this.colorSpace = t === Ot ? Ft : Bt);
          }
        }
        (De.DEFAULT_IMAGE = null), (De.DEFAULT_MAPPING = M), (De.DEFAULT_ANISOTROPY = 1);
        class Oe {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (Oe.prototype.isVector4 = !0), (this.x = t), (this.y = e), (this.z = n), (this.w = i);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              s = t.elements;
            return (
              (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
              (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
              (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
              (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const s = 0.01,
              a = 0.1,
              o = t.elements,
              l = o[0],
              c = o[4],
              h = o[8],
              u = o[1],
              d = o[5],
              p = o[9],
              f = o[2],
              m = o[6],
              g = o[10];
            if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
              if (
                Math.abs(c + u) < a &&
                Math.abs(h + f) < a &&
                Math.abs(p + m) < a &&
                Math.abs(l + d + g - 3) < a
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (l + 1) / 2,
                o = (d + 1) / 2,
                _ = (g + 1) / 2,
                v = (c + u) / 4,
                x = (h + f) / 4,
                y = (p + m) / 4;
              return (
                t > o && t > _
                  ? t < s
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(t)), (i = v / n), (r = x / n))
                  : o > _
                  ? o < s
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(o)), (n = v / i), (r = y / i))
                  : _ < s
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(_)), (n = x / r), (i = y / r)),
                this.set(n, i, r, e),
                this
              );
            }
            let _ = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
            return (
              Math.abs(_) < 0.001 && (_ = 1),
              (this.x = (m - p) / _),
              (this.y = (h - f) / _),
              (this.z = (u - c) / _),
              (this.w = Math.acos((l + d + g - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)),
              (this.y = Math.trunc(this.y)),
              (this.z = Math.trunc(this.z)),
              (this.w = Math.trunc(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
          }
        }
        class Be extends Qt {
          constructor(t = 1, e = 1, n = {}) {
            super(),
              (this.isRenderTarget = !0),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new Oe(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new Oe(0, 0, t, e));
            const i = { width: t, height: e, depth: 1 };
            void 0 !== n.encoding &&
              (Me(
                "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
              ),
              (n.colorSpace = n.encoding === Ot ? Ft : Bt)),
              (n = Object.assign(
                {
                  generateMipmaps: !1,
                  internalFormat: null,
                  minFilter: U,
                  depthBuffer: !0,
                  stencilBuffer: !1,
                  depthTexture: null,
                  samples: 0,
                },
                n
              )),
              (this.texture = new De(
                i,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.colorSpace
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.flipY = !1),
              (this.texture.generateMipmaps = n.generateMipmaps),
              (this.texture.internalFormat = n.internalFormat),
              (this.depthBuffer = n.depthBuffer),
              (this.stencilBuffer = n.stencilBuffer),
              (this.depthTexture = n.depthTexture),
              (this.samples = n.samples);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.scissor.copy(t.scissor),
              (this.scissorTest = t.scissorTest),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.texture.isRenderTargetTexture = !0);
            const e = Object.assign({}, t.texture.image);
            return (
              (this.texture.source = new Ie(e)),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
              (this.samples = t.samples),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        class Fe extends Be {
          constructor(t = 1, e = 1, n = {}) {
            super(t, e, n), (this.isWebGLRenderTarget = !0);
          }
        }
        class ze extends De {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.isDataArrayTexture = !0),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = L),
              (this.minFilter = L),
              (this.wrapR = R),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        class He extends De {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.isData3DTexture = !0),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = L),
              (this.minFilter = L),
              (this.wrapR = R),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        class Ge {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this.isQuaternion = !0), (this._x = t), (this._y = e), (this._z = n), (this._w = i);
          }
          static slerpFlat(t, e, n, i, r, s, a) {
            let o = n[i + 0],
              l = n[i + 1],
              c = n[i + 2],
              h = n[i + 3];
            const u = r[s + 0],
              d = r[s + 1],
              p = r[s + 2],
              f = r[s + 3];
            if (0 === a) return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h);
            if (1 === a) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f);
            if (h !== f || o !== u || l !== d || c !== p) {
              let t = 1 - a;
              const e = o * u + l * d + c * p + h * f,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e;
              if (i > Number.EPSILON) {
                const r = Math.sqrt(i),
                  s = Math.atan2(r, e * n);
                (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
              }
              const r = a * n;
              if (
                ((o = o * t + u * r),
                (l = l * t + d * r),
                (c = c * t + p * r),
                (h = h * t + f * r),
                t === 1 - a)
              ) {
                const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                (o *= t), (l *= t), (c *= t), (h *= t);
              }
            }
            (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
          }
          static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const a = n[i],
              o = n[i + 1],
              l = n[i + 2],
              c = n[i + 3],
              h = r[s],
              u = r[s + 1],
              d = r[s + 2],
              p = r[s + 3];
            return (
              (t[e] = a * p + c * h + o * d - l * u),
              (t[e + 1] = o * p + c * u + l * h - a * d),
              (t[e + 2] = l * p + c * d + a * u - o * h),
              (t[e + 3] = c * p - a * h - o * u - l * d),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e = !0) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._order,
              a = Math.cos,
              o = Math.sin,
              l = a(n / 2),
              c = a(i / 2),
              h = a(r / 2),
              u = o(n / 2),
              d = o(i / 2),
              p = o(r / 2);
            switch (s) {
              case "XYZ":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "YXZ":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              case "ZXY":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "ZYX":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              case "YZX":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "XZY":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
                );
            }
            return !0 === e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              i = Math.sin(n);
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              i = e[4],
              r = e[8],
              s = e[1],
              a = e[5],
              o = e[9],
              l = e[2],
              c = e[6],
              h = e[10],
              u = n + a + h;
            if (u > 0) {
              const t = 0.5 / Math.sqrt(u + 1);
              (this._w = 0.25 / t),
                (this._x = (c - o) * t),
                (this._y = (r - l) * t),
                (this._z = (s - i) * t);
            } else if (n > a && n > h) {
              const t = 2 * Math.sqrt(1 + n - a - h);
              (this._w = (c - o) / t),
                (this._x = 0.25 * t),
                (this._y = (i + s) / t),
                (this._z = (r + l) / t);
            } else if (a > h) {
              const t = 2 * Math.sqrt(1 + a - n - h);
              (this._w = (r - l) / t),
                (this._x = (i + s) / t),
                (this._y = 0.25 * t),
                (this._z = (o + c) / t);
            } else {
              const t = 2 * Math.sqrt(1 + h - n - a);
              (this._w = (s - i) / t),
                (this._x = (r + l) / t),
                (this._y = (o + c) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
                    : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(re(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this
            );
          }
          dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
          }
          lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
          }
          length() {
            return Math.sqrt(
              this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t) {
            return this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._w,
              a = e._x,
              o = e._y,
              l = e._z,
              c = e._w;
            return (
              (this._x = n * c + s * a + i * l - r * o),
              (this._y = i * c + s * o + r * a - n * l),
              (this._z = r * c + s * l + n * o - i * a),
              (this._w = s * c - n * a - i * o - r * l),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              i = this._y,
              r = this._z,
              s = this._w;
            let a = s * t._w + n * t._x + i * t._y + r * t._z;
            if (
              (a < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (a = -a))
                : this.copy(t),
              a >= 1)
            )
              return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * s + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * i + e * this._y),
                (this._z = t * r + e * this._z),
                this.normalize(),
                this
              );
            }
            const l = Math.sqrt(o),
              c = Math.atan2(l, a),
              h = Math.sin((1 - e) * c) / l,
              u = Math.sin(e * c) / l;
            return (
              (this._w = s * h + this._w * u),
              (this._x = n * h + this._x * u),
              (this._y = i * h + this._y * u),
              (this._z = r * h + this._z * u),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            return this.copy(t).slerp(e, n);
          }
          random() {
            const t = Math.random(),
              e = Math.sqrt(1 - t),
              n = Math.sqrt(t),
              i = 2 * Math.PI * Math.random(),
              r = 2 * Math.PI * Math.random();
            return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i));
          }
          equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this._onChangeCallback(),
              this
            );
          }
          toJSON() {
            return this.toArray();
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
          }
        }
        class ke {
          constructor(t = 0, e = 0, n = 0) {
            (ke.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
          }
          set(t, e, n) {
            return void 0 === n && (n = this.z), (this.x = t), (this.y = e), (this.z = n), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
          }
          applyEuler(t) {
            return this.applyQuaternion(We.setFromEuler(t));
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(We.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              a = t.z,
              o = t.w,
              l = 2 * (s * i - a * n),
              c = 2 * (a * e - r * i),
              h = 2 * (r * n - s * e);
            return (
              (this.x = e + o * l + s * h - a * c),
              (this.y = n + o * c + a * l - r * h),
              (this.z = i + o * h + r * c - s * l),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)),
              (this.y = Math.trunc(this.y)),
              (this.z = Math.trunc(this.z)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t) {
            return this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = e.x,
              a = e.y,
              o = e.z;
            return (
              (this.x = i * o - r * a), (this.y = r * s - n * o), (this.z = n * a - i * s), this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return Ve.copy(this).projectOnVector(t), this.sub(Ve);
          }
          reflect(t) {
            return this.sub(Ve.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(re(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z;
            return e * e + n * n + i * i;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return (
              (this.x = i * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = i * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this;
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = i), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          setFromEuler(t) {
            return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
          }
          setFromColor(t) {
            return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e) {
            return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this;
          }
          random() {
            return (
              (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this
            );
          }
          randomDirection() {
            const t = 2 * (Math.random() - 0.5),
              e = Math.random() * Math.PI * 2,
              n = Math.sqrt(1 - t ** 2);
            return (this.x = n * Math.cos(e)), (this.y = n * Math.sin(e)), (this.z = t), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
          }
        }
        const Ve = new ke(),
          We = new Ge();
        class Xe {
          constructor(t = new ke(1 / 0, 1 / 0, 1 / 0), e = new ke(-1 / 0, -1 / 0, -1 / 0)) {
            (this.isBox3 = !0), (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(qe.fromArray(t, e));
            return this;
          }
          setFromBufferAttribute(t) {
            this.makeEmpty();
            for (let e = 0, n = t.count; e < n; e++)
              this.expandByPoint(qe.fromBufferAttribute(t, e));
            return this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = qe.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t, e = !1) {
            return this.makeEmpty(), this.expandByObject(t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
          }
          getCenter(t) {
            return this.isEmpty()
              ? t.set(0, 0, 0)
              : t.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t, e = !1) {
            t.updateWorldMatrix(!1, !1);
            const n = t.geometry;
            if (void 0 !== n) {
              const i = n.getAttribute("position");
              if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
                for (let e = 0, n = i.count; e < n; e++)
                  !0 === t.isMesh ? t.getVertexPosition(e, qe) : qe.fromBufferAttribute(i, e),
                    qe.applyMatrix4(t.matrixWorld),
                    this.expandByPoint(qe);
              else
                void 0 !== t.boundingBox
                  ? (null === t.boundingBox && t.computeBoundingBox(), Ye.copy(t.boundingBox))
                  : (null === n.boundingBox && n.computeBoundingBox(), Ye.copy(n.boundingBox)),
                  Ye.applyMatrix4(t.matrixWorld),
                  this.union(Ye);
            }
            const i = t.children;
            for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return e.set(
              (t.x - this.min.x) / (this.max.x - this.min.x),
              (t.y - this.min.y) / (this.max.y - this.min.y),
              (t.z - this.min.z) / (this.max.z - this.min.z)
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, qe), qe.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(en),
              nn.subVectors(this.max, en),
              Ke.subVectors(t.a, en),
              Ze.subVectors(t.b, en),
              Je.subVectors(t.c, en),
              Qe.subVectors(Ze, Ke),
              $e.subVectors(Je, Ze),
              tn.subVectors(Ke, Je);
            let e = [
              0,
              -Qe.z,
              Qe.y,
              0,
              -$e.z,
              $e.y,
              0,
              -tn.z,
              tn.y,
              Qe.z,
              0,
              -Qe.x,
              $e.z,
              0,
              -$e.x,
              tn.z,
              0,
              -tn.x,
              -Qe.y,
              Qe.x,
              0,
              -$e.y,
              $e.x,
              0,
              -tn.y,
              tn.x,
              0,
            ];
            return (
              !!an(e, Ke, Ze, Je, nn) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!an(e, Ke, Ze, Je, nn) &&
                (rn.crossVectors(Qe, $e), (e = [rn.x, rn.y, rn.z]), an(e, Ke, Ze, Je, nn)))
            );
          }
          clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max);
          }
          distanceToPoint(t) {
            return this.clampPoint(t, qe).distanceTo(t);
          }
          getBoundingSphere(t) {
            return (
              this.isEmpty()
                ? t.makeEmpty()
                : (this.getCenter(t.center), (t.radius = 0.5 * this.getSize(qe).length())),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (je[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                je[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                je[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                je[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                je[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                je[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                je[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                je[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(je)),
              this
            );
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        const je = [new ke(), new ke(), new ke(), new ke(), new ke(), new ke(), new ke(), new ke()],
          qe = new ke(),
          Ye = new Xe(),
          Ke = new ke(),
          Ze = new ke(),
          Je = new ke(),
          Qe = new ke(),
          $e = new ke(),
          tn = new ke(),
          en = new ke(),
          nn = new ke(),
          rn = new ke(),
          sn = new ke();
        function an(t, e, n, i, r) {
          for (let s = 0, a = t.length - 3; s <= a; s += 3) {
            sn.fromArray(t, s);
            const a = r.x * Math.abs(sn.x) + r.y * Math.abs(sn.y) + r.z * Math.abs(sn.z),
              o = e.dot(sn),
              l = n.dot(sn),
              c = i.dot(sn);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
          }
          return !0;
        }
        const on = new Xe(),
          ln = new ke(),
          cn = new ke();
        class hn {
          constructor(t = new ke(), e = -1) {
            (this.isSphere = !0), (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : on.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
            return (this.radius = Math.sqrt(i)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius;
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return this.isEmpty()
              ? (t.makeEmpty(), t)
              : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
            ln.subVectors(t, this.center);
            const e = ln.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.addScaledVector(ln, n / t), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return t.isEmpty()
              ? this
              : this.isEmpty()
              ? (this.copy(t), this)
              : (!0 === this.center.equals(t.center)
                  ? (this.radius = Math.max(this.radius, t.radius))
                  : (cn.subVectors(t.center, this.center).setLength(t.radius),
                    this.expandByPoint(ln.copy(t.center).add(cn)),
                    this.expandByPoint(ln.copy(t.center).sub(cn))),
                this);
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const un = new ke(),
          dn = new ke(),
          pn = new ke(),
          fn = new ke(),
          mn = new ke(),
          gn = new ke(),
          _n = new ke();
        class vn {
          constructor(t = new ke(), e = new ke(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
          }
          at(t, e) {
            return e.copy(this.origin).addScaledVector(this.direction, t);
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, un)), this;
          }
          closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.origin).addScaledVector(this.direction, n);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = un.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (un.copy(this.origin).addScaledVector(this.direction, e), un.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, i) {
            dn.copy(t).add(e).multiplyScalar(0.5),
              pn.copy(e).sub(t).normalize(),
              fn.copy(this.origin).sub(dn);
            const r = 0.5 * t.distanceTo(e),
              s = -this.direction.dot(pn),
              a = fn.dot(this.direction),
              o = -fn.dot(pn),
              l = fn.lengthSq(),
              c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0)
              if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
                if (u >= -p)
                  if (u <= p) {
                    const t = 1 / c;
                    (h *= t), (u *= t), (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
                  } else
                    (u = r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                else (u = -r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
              else
                u <= -p
                  ? ((h = Math.max(0, -(-s * r + a))),
                    (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                    (d = -h * h + u * (u + 2 * o) + l))
                  : u <= p
                  ? ((h = 0), (u = Math.min(Math.max(-r, -o), r)), (d = u * (u + 2 * o) + l))
                  : ((h = Math.max(0, -(s * r + a))),
                    (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
                    (d = -h * h + u * (u + 2 * o) + l));
            else
              (u = s > 0 ? -r : r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
            return (
              n && n.copy(this.origin).addScaledVector(this.direction, h),
              i && i.copy(dn).addScaledVector(pn, u),
              d
            );
          }
          intersectSphere(t, e) {
            un.subVectors(t.center, this.origin);
            const n = un.dot(this.direction),
              i = un.dot(un) - n * n,
              r = t.radius * t.radius;
            if (i > r) return null;
            const s = Math.sqrt(r - i),
              a = n - s,
              o = n + s;
            return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, i, r, s, a, o;
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              h = 1 / this.direction.z,
              u = this.origin;
            return (
              l >= 0
                ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
                : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
              c >= 0
                ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
                : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
              n > s || r > i
                ? null
                : ((r > n || isNaN(n)) && (n = r),
                  (s < i || isNaN(i)) && (i = s),
                  h >= 0
                    ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
                    : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
                  n > o || a > i
                    ? null
                    : ((a > n || n != n) && (n = a),
                      (o < i || i != i) && (i = o),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, un);
          }
          intersectTriangle(t, e, n, i, r) {
            mn.subVectors(e, t), gn.subVectors(n, t), _n.crossVectors(mn, gn);
            let s,
              a = this.direction.dot(_n);
            if (a > 0) {
              if (i) return null;
              s = 1;
            } else {
              if (!(a < 0)) return null;
              (s = -1), (a = -a);
            }
            fn.subVectors(this.origin, t);
            const o = s * this.direction.dot(gn.crossVectors(fn, gn));
            if (o < 0) return null;
            const l = s * this.direction.dot(mn.cross(fn));
            if (l < 0) return null;
            if (o + l > a) return null;
            const c = -s * fn.dot(_n);
            return c < 0 ? null : this.at(c / a, r);
          }
          applyMatrix4(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
          }
          equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class xn {
          constructor(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            (xn.prototype.isMatrix4 = !0),
              (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              void 0 !== t && this.set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m);
          }
          set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = s),
              (g[9] = a),
              (g[13] = o),
              (g[2] = l),
              (g[6] = c),
              (g[10] = h),
              (g[14] = u),
              (g[3] = d),
              (g[7] = p),
              (g[11] = f),
              (g[15] = m),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
          }
          clone() {
            return new xn().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              i = 1 / yn.setFromMatrixColumn(t, 0).length(),
              r = 1 / yn.setFromMatrixColumn(t, 1).length(),
              s = 1 / yn.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * i),
              (e[1] = n[1] * i),
              (e[2] = n[2] * i),
              (e[3] = 0),
              (e[4] = n[4] * r),
              (e[5] = n[5] * r),
              (e[6] = n[6] * r),
              (e[7] = 0),
              (e[8] = n[8] * s),
              (e[9] = n[9] * s),
              (e[10] = n[10] * s),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              s = Math.cos(n),
              a = Math.sin(n),
              o = Math.cos(i),
              l = Math.sin(i),
              c = Math.cos(r),
              h = Math.sin(r);
            if ("XYZ" === t.order) {
              const t = s * c,
                n = s * h,
                i = a * c,
                r = a * h;
              (e[0] = o * c),
                (e[4] = -o * h),
                (e[8] = l),
                (e[1] = n + i * l),
                (e[5] = t - r * l),
                (e[9] = -a * o),
                (e[2] = r - t * l),
                (e[6] = i + n * l),
                (e[10] = s * o);
            } else if ("YXZ" === t.order) {
              const t = o * c,
                n = o * h,
                i = l * c,
                r = l * h;
              (e[0] = t + r * a),
                (e[4] = i * a - n),
                (e[8] = s * l),
                (e[1] = s * h),
                (e[5] = s * c),
                (e[9] = -a),
                (e[2] = n * a - i),
                (e[6] = r + t * a),
                (e[10] = s * o);
            } else if ("ZXY" === t.order) {
              const t = o * c,
                n = o * h,
                i = l * c,
                r = l * h;
              (e[0] = t - r * a),
                (e[4] = -s * h),
                (e[8] = i + n * a),
                (e[1] = n + i * a),
                (e[5] = s * c),
                (e[9] = r - t * a),
                (e[2] = -s * l),
                (e[6] = a),
                (e[10] = s * o);
            } else if ("ZYX" === t.order) {
              const t = s * c,
                n = s * h,
                i = a * c,
                r = a * h;
              (e[0] = o * c),
                (e[4] = i * l - n),
                (e[8] = t * l + r),
                (e[1] = o * h),
                (e[5] = r * l + t),
                (e[9] = n * l - i),
                (e[2] = -l),
                (e[6] = a * o),
                (e[10] = s * o);
            } else if ("YZX" === t.order) {
              const t = s * o,
                n = s * l,
                i = a * o,
                r = a * l;
              (e[0] = o * c),
                (e[4] = r - t * h),
                (e[8] = i * h + n),
                (e[1] = h),
                (e[5] = s * c),
                (e[9] = -a * c),
                (e[2] = -l * c),
                (e[6] = n * h + i),
                (e[10] = t - r * h);
            } else if ("XZY" === t.order) {
              const t = s * o,
                n = s * l,
                i = a * o,
                r = a * l;
              (e[0] = o * c),
                (e[4] = -h),
                (e[8] = l * c),
                (e[1] = t * h + r),
                (e[5] = s * c),
                (e[9] = n * h - i),
                (e[2] = i * h - n),
                (e[6] = a * c),
                (e[10] = r * h + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(Sn, t, bn);
          }
          lookAt(t, e, n) {
            const i = this.elements;
            return (
              An.subVectors(t, e),
              0 === An.lengthSq() && (An.z = 1),
              An.normalize(),
              En.crossVectors(n, An),
              0 === En.lengthSq() &&
                (1 === Math.abs(n.z) ? (An.x += 1e-4) : (An.z += 1e-4),
                An.normalize(),
                En.crossVectors(n, An)),
              En.normalize(),
              Tn.crossVectors(An, En),
              (i[0] = En.x),
              (i[4] = Tn.x),
              (i[8] = An.x),
              (i[1] = En.y),
              (i[5] = Tn.y),
              (i[9] = An.y),
              (i[2] = En.z),
              (i[6] = Tn.z),
              (i[10] = An.z),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              a = n[4],
              o = n[8],
              l = n[12],
              c = n[1],
              h = n[5],
              u = n[9],
              d = n[13],
              p = n[2],
              f = n[6],
              m = n[10],
              g = n[14],
              _ = n[3],
              v = n[7],
              x = n[11],
              y = n[15],
              M = i[0],
              S = i[4],
              b = i[8],
              E = i[12],
              T = i[1],
              A = i[5],
              w = i[9],
              R = i[13],
              C = i[2],
              L = i[6],
              P = i[10],
              I = i[14],
              U = i[3],
              N = i[7],
              D = i[11],
              O = i[15];
            return (
              (r[0] = s * M + a * T + o * C + l * U),
              (r[4] = s * S + a * A + o * L + l * N),
              (r[8] = s * b + a * w + o * P + l * D),
              (r[12] = s * E + a * R + o * I + l * O),
              (r[1] = c * M + h * T + u * C + d * U),
              (r[5] = c * S + h * A + u * L + d * N),
              (r[9] = c * b + h * w + u * P + d * D),
              (r[13] = c * E + h * R + u * I + d * O),
              (r[2] = p * M + f * T + m * C + g * U),
              (r[6] = p * S + f * A + m * L + g * N),
              (r[10] = p * b + f * w + m * P + g * D),
              (r[14] = p * E + f * R + m * I + g * O),
              (r[3] = _ * M + v * T + x * C + y * U),
              (r[7] = _ * S + v * A + x * L + y * N),
              (r[11] = _ * b + v * w + x * P + y * D),
              (r[15] = _ * E + v * R + x * I + y * O),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              s = t[1],
              a = t[5],
              o = t[9],
              l = t[13],
              c = t[2],
              h = t[6],
              u = t[10],
              d = t[14];
            return (
              t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) +
              t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) +
              t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) +
              t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const i = this.elements;
            return (
              t.isVector3
                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                : ((i[12] = t), (i[13] = e), (i[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8],
              h = t[9],
              u = t[10],
              d = t[11],
              p = t[12],
              f = t[13],
              m = t[14],
              g = t[15],
              _ = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
              v = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
              x = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
              y = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
              M = e * _ + n * v + i * x + r * y;
            if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const S = 1 / M;
            return (
              (t[0] = _ * S),
              (t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * S),
              (t[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * S),
              (t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * S),
              (t[4] = v * S),
              (t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * S),
              (t[6] = (p * o * r - s * m * r - p * i * l + e * m * l + s * i * g - e * o * g) * S),
              (t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * S),
              (t[8] = x * S),
              (t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * S),
              (t[10] = (s * f * r - p * a * r + p * n * l - e * f * l - s * n * g + e * a * g) * S),
              (t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * S),
              (t[12] = y * S),
              (t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * S),
              (t[14] = (p * a * i - s * f * i - p * n * o + e * f * o + s * n * m - e * a * m) * S),
              (t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * S),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z;
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i));
          }
          makeTranslation(t, e, n) {
            return (
              t.isVector3
                ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
                : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
              this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              s = t.x,
              a = t.y,
              o = t.z,
              l = r * s,
              c = r * a;
            return (
              this.set(
                l * s + n,
                l * a - i * o,
                l * o + i * a,
                0,
                l * a + i * o,
                c * a + n,
                c * o - i * s,
                0,
                l * o - i * a,
                c * o + i * s,
                r * o * o + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
          }
          makeShear(t, e, n, i, r, s) {
            return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
          }
          compose(t, e, n) {
            const i = this.elements,
              r = e._x,
              s = e._y,
              a = e._z,
              o = e._w,
              l = r + r,
              c = s + s,
              h = a + a,
              u = r * l,
              d = r * c,
              p = r * h,
              f = s * c,
              m = s * h,
              g = a * h,
              _ = o * l,
              v = o * c,
              x = o * h,
              y = n.x,
              M = n.y,
              S = n.z;
            return (
              (i[0] = (1 - (f + g)) * y),
              (i[1] = (d + x) * y),
              (i[2] = (p - v) * y),
              (i[3] = 0),
              (i[4] = (d - x) * M),
              (i[5] = (1 - (u + g)) * M),
              (i[6] = (m + _) * M),
              (i[7] = 0),
              (i[8] = (p + v) * S),
              (i[9] = (m - _) * S),
              (i[10] = (1 - (u + f)) * S),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const i = this.elements;
            let r = yn.set(i[0], i[1], i[2]).length();
            const s = yn.set(i[4], i[5], i[6]).length(),
              a = yn.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
              (t.x = i[12]),
              (t.y = i[13]),
              (t.z = i[14]),
              Mn.copy(this);
            const o = 1 / r,
              l = 1 / s,
              c = 1 / a;
            return (
              (Mn.elements[0] *= o),
              (Mn.elements[1] *= o),
              (Mn.elements[2] *= o),
              (Mn.elements[4] *= l),
              (Mn.elements[5] *= l),
              (Mn.elements[6] *= l),
              (Mn.elements[8] *= c),
              (Mn.elements[9] *= c),
              (Mn.elements[10] *= c),
              e.setFromRotationMatrix(Mn),
              (n.x = r),
              (n.y = s),
              (n.z = a),
              this
            );
          }
          makePerspective(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
              l = (2 * r) / (e - t),
              c = (2 * r) / (n - i),
              h = (e + t) / (e - t),
              u = (n + i) / (n - i);
            let d, p;
            if (a === Zt) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
            else {
              if (a !== Jt)
                throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
              (d = -s / (s - r)), (p = (-s * r) / (s - r));
            }
            return (
              (o[0] = l),
              (o[4] = 0),
              (o[8] = h),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = c),
              (o[9] = u),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = d),
              (o[14] = p),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
              l = 1 / (e - t),
              c = 1 / (n - i),
              h = 1 / (s - r),
              u = (e + t) * l,
              d = (n + i) * c;
            let p, f;
            if (a === Zt) (p = (s + r) * h), (f = -2 * h);
            else {
              if (a !== Jt)
                throw new Error(
                  "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
                );
              (p = r * h), (f = -1 * h);
            }
            return (
              (o[0] = 2 * l),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -u),
              (o[1] = 0),
              (o[5] = 2 * c),
              (o[9] = 0),
              (o[13] = -d),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = f),
              (o[14] = -p),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        const yn = new ke(),
          Mn = new xn(),
          Sn = new ke(0, 0, 0),
          bn = new ke(1, 1, 1),
          En = new ke(),
          Tn = new ke(),
          An = new ke(),
          wn = new xn(),
          Rn = new Ge();
        class Cn {
          constructor(t = 0, e = 0, n = 0, i = Cn.DEFAULT_ORDER) {
            (this.isEuler = !0), (this._x = t), (this._y = e), (this._z = n), (this._order = i);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, i = this._order) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e = this._order, n = !0) {
            const i = t.elements,
              r = i[0],
              s = i[4],
              a = i[8],
              o = i[1],
              l = i[5],
              c = i[9],
              h = i[2],
              u = i[6],
              d = i[10];
            switch (e) {
              case "XYZ":
                (this._y = Math.asin(re(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                    : ((this._x = Math.atan2(u, l)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-re(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                    : ((this._y = Math.atan2(-h, r)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(re(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
                    : ((this._y = 0), (this._z = Math.atan2(o, r)));
                break;
              case "ZYX":
                (this._y = Math.asin(-re(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
                    : ((this._x = 0), (this._z = Math.atan2(-s, l)));
                break;
              case "YZX":
                (this._z = Math.asin(re(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
                    : ((this._x = 0), (this._y = Math.atan2(a, d)));
                break;
              case "XZY":
                (this._z = Math.asin(-re(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
                    : ((this._x = Math.atan2(-c, d)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e
                );
            }
            return (this._order = e), !0 === n && this._onChangeCallback(), this;
          }
          setFromQuaternion(t, e, n) {
            return wn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(wn, e, n);
          }
          setFromVector3(t, e = this._order) {
            return this.set(t.x, t.y, t.z, e);
          }
          reorder(t) {
            return Rn.setFromEuler(this), this.setFromQuaternion(Rn, t);
          }
          equals(t) {
            return (
              t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        }
        Cn.DEFAULT_ORDER = "XYZ";
        class Ln {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = ((1 << t) | 0) >>> 0;
          }
          enable(t) {
            this.mask |= (1 << t) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0;
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return 0 != (this.mask & t.mask);
          }
          isEnabled(t) {
            return 0 != (this.mask & ((1 << t) | 0));
          }
        }
        let Pn = 0;
        const In = new ke(),
          Un = new Ge(),
          Nn = new xn(),
          Dn = new ke(),
          On = new ke(),
          Bn = new ke(),
          Fn = new Ge(),
          zn = new ke(1, 0, 0),
          Hn = new ke(0, 1, 0),
          Gn = new ke(0, 0, 1),
          kn = { type: "added" },
          Vn = { type: "removed" };
        class Wn extends Qt {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", { value: Pn++ }),
              (this.uuid = ie()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = Wn.DEFAULT_UP.clone());
            const t = new ke(),
              e = new Cn(),
              n = new Ge(),
              i = new ke(1, 1, 1);
            e._onChange(function () {
              n.setFromEuler(e, !1);
            }),
              n._onChange(function () {
                e.setFromQuaternion(n, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: e },
                quaternion: { configurable: !0, enumerable: !0, value: n },
                scale: { configurable: !0, enumerable: !0, value: i },
                modelViewMatrix: { value: new xn() },
                normalMatrix: { value: new pe() },
              }),
              (this.matrix = new xn()),
              (this.matrixWorld = new xn()),
              (this.matrixAutoUpdate = Wn.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldAutoUpdate = Wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.layers = new Ln()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeShadow() {}
          onAfterShadow() {}
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, e) {
            return Un.setFromAxisAngle(t, e), this.quaternion.multiply(Un), this;
          }
          rotateOnWorldAxis(t, e) {
            return Un.setFromAxisAngle(t, e), this.quaternion.premultiply(Un), this;
          }
          rotateX(t) {
            return this.rotateOnAxis(zn, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(Hn, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(Gn, t);
          }
          translateOnAxis(t, e) {
            return (
              In.copy(t).applyQuaternion(this.quaternion),
              this.position.add(In.multiplyScalar(e)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(zn, t);
          }
          translateY(t) {
            return this.translateOnAxis(Hn, t);
          }
          translateZ(t) {
            return this.translateOnAxis(Gn, t);
          }
          localToWorld(t) {
            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
          }
          worldToLocal(t) {
            return (
              this.updateWorldMatrix(!0, !1), t.applyMatrix4(Nn.copy(this.matrixWorld).invert())
            );
          }
          lookAt(t, e, n) {
            t.isVector3 ? Dn.copy(t) : Dn.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
              On.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? Nn.lookAt(On, Dn, this.up)
                : Nn.lookAt(Dn, On, this.up),
              this.quaternion.setFromRotationMatrix(Nn),
              i &&
                (Nn.extractRotation(i.matrixWorld),
                Un.setFromRotationMatrix(Nn),
                this.quaternion.premultiply(Un.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(kn))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
              return this;
            }
            const e = this.children.indexOf(t);
            return (
              -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Vn)), this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            return this.remove(...this.children);
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              Nn.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1), Nn.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(Nn),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
              const i = this.children[n].getObjectByProperty(t, e);
              if (void 0 !== i) return i;
            }
          }
          getObjectsByProperty(t, e, n = []) {
            this[t] === e && n.push(this);
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) i[r].getObjectsByProperty(t, e, n);
            return n;
          }
          getWorldPosition(t) {
            return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
          }
          getWorldQuaternion(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(On, t, Bn), t;
          }
          getWorldScale(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(On, Fn, t), t;
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
          }
          traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              (!0 !== i.matrixWorldAutoUpdate && !0 !== t) || i.updateMatrixWorld(t);
            }
          }
          updateWorldMatrix(t, e) {
            const n = this.parent;
            if (
              (!0 === t &&
                null !== n &&
                !0 === n.matrixWorldAutoUpdate &&
                n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
              !0 === e)
            ) {
              const t = this.children;
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }));
            const i = {};
            function r(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((i.uuid = this.uuid),
              (i.type = this.type),
              "" !== this.name && (i.name = this.name),
              !0 === this.castShadow && (i.castShadow = !0),
              !0 === this.receiveShadow && (i.receiveShadow = !0),
              !1 === this.visible && (i.visible = !1),
              !1 === this.frustumCulled && (i.frustumCulled = !1),
              0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 && (i.userData = this.userData),
              (i.layers = this.layers.mask),
              (i.matrix = this.matrix.toArray()),
              (i.up = this.up.toArray()),
              !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((i.type = "InstancedMesh"),
                (i.count = this.count),
                (i.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
              this.isBatchedMesh &&
                ((i.type = "BatchedMesh"),
                (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
                (i.sortObjects = this.sortObjects),
                (i.drawRanges = this._drawRanges),
                (i.reservedRanges = this._reservedRanges),
                (i.visibility = this._visibility),
                (i.active = this._active),
                (i.bounds = this._bounds.map((t) => ({
                  boxInitialized: t.boxInitialized,
                  boxMin: t.box.min.toArray(),
                  boxMax: t.box.max.toArray(),
                  sphereInitialized: t.sphereInitialized,
                  sphereRadius: t.sphere.radius,
                  sphereCenter: t.sphere.center.toArray(),
                }))),
                (i.maxGeometryCount = this._maxGeometryCount),
                (i.maxVertexCount = this._maxVertexCount),
                (i.maxIndexCount = this._maxIndexCount),
                (i.geometryInitialized = this._geometryInitialized),
                (i.geometryCount = this._geometryCount),
                (i.matricesTexture = this._matricesTexture.toJSON(t)),
                null !== this.boundingSphere &&
                  (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius,
                  }),
                null !== this.boundingBox &&
                  (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray(),
                  })),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (i.background = this.background.toJSON())
                  : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (i.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              i.geometry = r(t.geometries, this.geometry);
              const e = this.geometry.parameters;
              if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    r(t.shapes, i);
                  }
                else r(t.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((i.bindMode = this.bindMode),
                (i.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, i = this.material.length; n < i; n++)
                  e.push(r(t.materials, this.material[n]));
                i.material = e;
              } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
              i.children = [];
              for (let e = 0; e < this.children.length; e++)
                i.children.push(this.children[e].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              i.animations = [];
              for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                i.animations.push(r(t.animations, n));
              }
            }
            if (e) {
              const e = s(t.geometries),
                i = s(t.materials),
                r = s(t.textures),
                a = s(t.images),
                o = s(t.shapes),
                l = s(t.skeletons),
                c = s(t.animations),
                h = s(t.nodes);
              e.length > 0 && (n.geometries = e),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                a.length > 0 && (n.images = a),
                o.length > 0 && (n.shapes = o),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c),
                h.length > 0 && (n.nodes = h);
            }
            return (n.object = i), n;
            function s(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, e = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.animations = t.animations.slice()),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === e)
            )
              for (let e = 0; e < t.children.length; e++) {
                const n = t.children[e];
                this.add(n.clone());
              }
            return this;
          }
        }
        (Wn.DEFAULT_UP = new ke(0, 1, 0)),
          (Wn.DEFAULT_MATRIX_AUTO_UPDATE = !0),
          (Wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
        const Xn = new ke(),
          jn = new ke(),
          qn = new ke(),
          Yn = new ke(),
          Kn = new ke(),
          Zn = new ke(),
          Jn = new ke(),
          Qn = new ke(),
          $n = new ke(),
          ti = new ke();
        let ei = !1;
        class ni {
          constructor(t = new ke(), e = new ke(), n = new ke()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, i) {
            i.subVectors(n, e), Xn.subVectors(t, e), i.cross(Xn);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, i, r) {
            Xn.subVectors(i, e), jn.subVectors(n, e), qn.subVectors(t, e);
            const s = Xn.dot(Xn),
              a = Xn.dot(jn),
              o = Xn.dot(qn),
              l = jn.dot(jn),
              c = jn.dot(qn),
              h = s * l - a * a;
            if (0 === h) return r.set(0, 0, 0), null;
            const u = 1 / h,
              d = (l * o - a * c) * u,
              p = (s * c - a * o) * u;
            return r.set(1 - d - p, p, d);
          }
          static containsPoint(t, e, n, i) {
            return (
              null !== this.getBarycoord(t, e, n, i, Yn) &&
              Yn.x >= 0 &&
              Yn.y >= 0 &&
              Yn.x + Yn.y <= 1
            );
          }
          static getUV(t, e, n, i, r, s, a, o) {
            return (
              !1 === ei &&
                (console.warn(
                  "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
                ),
                (ei = !0)),
              this.getInterpolation(t, e, n, i, r, s, a, o)
            );
          }
          static getInterpolation(t, e, n, i, r, s, a, o) {
            return null === this.getBarycoord(t, e, n, i, Yn)
              ? ((o.x = 0), (o.y = 0), "z" in o && (o.z = 0), "w" in o && (o.w = 0), null)
              : (o.setScalar(0),
                o.addScaledVector(r, Yn.x),
                o.addScaledVector(s, Yn.y),
                o.addScaledVector(a, Yn.z),
                o);
          }
          static isFrontFacing(t, e, n, i) {
            return Xn.subVectors(n, e), jn.subVectors(t, e), Xn.cross(jn).dot(i) < 0;
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
          }
          setFromAttributeAndIndices(t, e, n, i) {
            return (
              this.a.fromBufferAttribute(t, e),
              this.b.fromBufferAttribute(t, n),
              this.c.fromBufferAttribute(t, i),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              Xn.subVectors(this.c, this.b),
              jn.subVectors(this.a, this.b),
              0.5 * Xn.cross(jn).length()
            );
          }
          getMidpoint(t) {
            return t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          }
          getNormal(t) {
            return ni.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c);
          }
          getBarycoord(t, e) {
            return ni.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, i, r) {
            return (
              !1 === ei &&
                (console.warn(
                  "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
                ),
                (ei = !0)),
              ni.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            );
          }
          getInterpolation(t, e, n, i, r) {
            return ni.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
          }
          containsPoint(t) {
            return ni.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return ni.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            const n = this.a,
              i = this.b,
              r = this.c;
            let s, a;
            Kn.subVectors(i, n), Zn.subVectors(r, n), Qn.subVectors(t, n);
            const o = Kn.dot(Qn),
              l = Zn.dot(Qn);
            if (o <= 0 && l <= 0) return e.copy(n);
            $n.subVectors(t, i);
            const c = Kn.dot($n),
              h = Zn.dot($n);
            if (c >= 0 && h <= c) return e.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0)
              return (s = o / (o - c)), e.copy(n).addScaledVector(Kn, s);
            ti.subVectors(t, r);
            const d = Kn.dot(ti),
              p = Zn.dot(ti);
            if (p >= 0 && d <= p) return e.copy(r);
            const f = d * l - o * p;
            if (f <= 0 && l >= 0 && p <= 0)
              return (a = l / (l - p)), e.copy(n).addScaledVector(Zn, a);
            const m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0)
              return (
                Jn.subVectors(r, i),
                (a = (h - c) / (h - c + (d - p))),
                e.copy(i).addScaledVector(Jn, a)
              );
            const g = 1 / (m + f + u);
            return (
              (s = f * g), (a = u * g), e.copy(n).addScaledVector(Kn, s).addScaledVector(Zn, a)
            );
          }
          equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
          }
        }
        const ii = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074,
          },
          ri = { h: 0, s: 0, l: 0 },
          si = { h: 0, s: 0, l: 0 };
        function ai(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        class oi {
          constructor(t, e, n) {
            return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(t, e, n);
          }
          set(t, e, n) {
            if (void 0 === e && void 0 === n) {
              const e = t;
              e && e.isColor
                ? this.copy(e)
                : "number" == typeof e
                ? this.setHex(e)
                : "string" == typeof e && this.setStyle(e);
            } else this.setRGB(t, e, n);
            return this;
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t, e = Ft) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              Ae.toWorkingColorSpace(this, e),
              this
            );
          }
          setRGB(t, e, n, i = Ae.workingColorSpace) {
            return (this.r = t), (this.g = e), (this.b = n), Ae.toWorkingColorSpace(this, i), this;
          }
          setHSL(t, e, n, i = Ae.workingColorSpace) {
            if (((t = se(t, 1)), (e = re(e, 0, 1)), (n = re(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n;
            else {
              const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                r = 2 * n - i;
              (this.r = ai(r, i, t + 1 / 3)),
                (this.g = ai(r, i, t)),
                (this.b = ai(r, i, t - 1 / 3));
            }
            return Ae.toWorkingColorSpace(this, i), this;
          }
          setStyle(t, e = Ft) {
            function n(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
            }
            let i;
            if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
              let r;
              const s = i[1],
                a = i[2];
              switch (s) {
                case "rgb":
                case "rgba":
                  if ((r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
                    return (
                      n(r[4]),
                      this.setRGB(
                        Math.min(255, parseInt(r[1], 10)) / 255,
                        Math.min(255, parseInt(r[2], 10)) / 255,
                        Math.min(255, parseInt(r[3], 10)) / 255,
                        e
                      )
                    );
                  if (
                    (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                  )
                    return (
                      n(r[4]),
                      this.setRGB(
                        Math.min(100, parseInt(r[1], 10)) / 100,
                        Math.min(100, parseInt(r[2], 10)) / 100,
                        Math.min(100, parseInt(r[3], 10)) / 100,
                        e
                      )
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (r =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        a
                      ))
                  )
                    return (
                      n(r[4]),
                      this.setHSL(
                        parseFloat(r[1]) / 360,
                        parseFloat(r[2]) / 100,
                        parseFloat(r[3]) / 100,
                        e
                      )
                    );
                  break;
                default:
                  console.warn("THREE.Color: Unknown color model " + t);
              }
            } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const n = i[1],
                r = n.length;
              if (3 === r)
                return this.setRGB(
                  parseInt(n.charAt(0), 16) / 15,
                  parseInt(n.charAt(1), 16) / 15,
                  parseInt(n.charAt(2), 16) / 15,
                  e
                );
              if (6 === r) return this.setHex(parseInt(n, 16), e);
              console.warn("THREE.Color: Invalid hex color " + t);
            } else if (t && t.length > 0) return this.setColorName(t, e);
            return this;
          }
          setColorName(t, e = Ft) {
            const n = ii[t.toLowerCase()];
            return (
              void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copySRGBToLinear(t) {
            return (this.r = we(t.r)), (this.g = we(t.g)), (this.b = we(t.b)), this;
          }
          copyLinearToSRGB(t) {
            return (this.r = Re(t.r)), (this.g = Re(t.g)), (this.b = Re(t.b)), this;
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex(t = Ft) {
            return (
              Ae.fromWorkingColorSpace(li.copy(this), t),
              65536 * Math.round(re(255 * li.r, 0, 255)) +
                256 * Math.round(re(255 * li.g, 0, 255)) +
                Math.round(re(255 * li.b, 0, 255))
            );
          }
          getHexString(t = Ft) {
            return ("000000" + this.getHex(t).toString(16)).slice(-6);
          }
          getHSL(t, e = Ae.workingColorSpace) {
            Ae.fromWorkingColorSpace(li.copy(this), e);
            const n = li.r,
              i = li.g,
              r = li.b,
              s = Math.max(n, i, r),
              a = Math.min(n, i, r);
            let o, l;
            const c = (a + s) / 2;
            if (a === s) (o = 0), (l = 0);
            else {
              const t = s - a;
              switch (((l = c <= 0.5 ? t / (s + a) : t / (2 - s - a)), s)) {
                case n:
                  o = (i - r) / t + (i < r ? 6 : 0);
                  break;
                case i:
                  o = (r - n) / t + 2;
                  break;
                case r:
                  o = (n - i) / t + 4;
              }
              o /= 6;
            }
            return (t.h = o), (t.s = l), (t.l = c), t;
          }
          getRGB(t, e = Ae.workingColorSpace) {
            return (
              Ae.fromWorkingColorSpace(li.copy(this), e),
              (t.r = li.r),
              (t.g = li.g),
              (t.b = li.b),
              t
            );
          }
          getStyle(t = Ft) {
            Ae.fromWorkingColorSpace(li.copy(this), t);
            const e = li.r,
              n = li.g,
              i = li.b;
            return t !== Ft
              ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
              : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`;
          }
          offsetHSL(t, e, n) {
            return this.getHSL(ri), this.setHSL(ri.h + t, ri.s + e, ri.l + n);
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(ri), t.getHSL(si);
            const n = ae(ri.h, si.h, e),
              i = ae(ri.s, si.s, e),
              r = ae(ri.l, si.l, e);
            return this.setHSL(n, i, r), this;
          }
          setFromVector3(t) {
            return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
          }
          applyMatrix3(t) {
            const e = this.r,
              n = this.g,
              i = this.b,
              r = t.elements;
            return (
              (this.r = r[0] * e + r[3] * n + r[6] * i),
              (this.g = r[1] * e + r[4] * n + r[7] * i),
              (this.b = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this;
          }
          toJSON() {
            return this.getHex();
          }
          *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
          }
        }
        const li = new oi();
        oi.NAMES = ii;
        let ci = 0;
        class hi extends Qt {
          constructor() {
            super(),
              (this.isMaterial = !0),
              Object.defineProperty(this, "id", { value: ci++ }),
              (this.uuid = ie()),
              (this.name = ""),
              (this.type = "Material"),
              (this.blending = 1),
              (this.side = 0),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.transparent = !1),
              (this.alphaHash = !1),
              (this.blendSrc = o),
              (this.blendDst = l),
              (this.blendEquation = a),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.blendColor = new oi(0, 0, 0)),
              (this.blendAlpha = 0),
              (this.depthFunc = 3),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = 519),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = jt),
              (this.stencilZFail = jt),
              (this.stencilZPass = jt),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.forceSinglePass = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0),
              (this._alphaTest = 0);
          }
          get alphaTest() {
            return this._alphaTest;
          }
          set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                  continue;
                }
                const i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
              }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = { textures: {}, images: {} });
            const n = {
              metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" },
            };
            function i(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              "" !== this.name && (n.name = this.name),
              this.color && this.color.isColor && (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              void 0 !== this.sheen && (n.sheen = this.sheen),
              this.sheenColor &&
                this.sheenColor.isColor &&
                (n.sheenColor = this.sheenColor.getHex()),
              void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
              this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
              this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
              void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
              this.specularColor &&
                this.specularColor.isColor &&
                (n.specularColor = this.specularColor.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              void 0 !== this.iridescence && (n.iridescence = this.iridescence),
              void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
              void 0 !== this.iridescenceThicknessRange &&
                (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
              this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
              this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
              void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
              void 0 !== this.anisotropyRotation &&
                (n.anisotropyRotation = this.anisotropyRotation),
              this.anisotropyMap &&
                this.anisotropyMap.isTexture &&
                (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
              this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
              this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
              this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                void 0 !== this.combine && (n.combine = this.combine)),
              void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.transmission && (n.transmission = this.transmission),
              this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
              void 0 !== this.thickness && (n.thickness = this.thickness),
              this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
              void 0 !== this.attenuationDistance &&
                this.attenuationDistance !== 1 / 0 &&
                (n.attenuationDistance = this.attenuationDistance),
              void 0 !== this.attenuationColor &&
                (n.attenuationColor = this.attenuationColor.getHex()),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (n.blending = this.blending),
              0 !== this.side && (n.side = this.side),
              !0 === this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              !0 === this.transparent && (n.transparent = !0),
              this.blendSrc !== o && (n.blendSrc = this.blendSrc),
              this.blendDst !== l && (n.blendDst = this.blendDst),
              this.blendEquation !== a && (n.blendEquation = this.blendEquation),
              null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
              null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
              null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
              this.blendColor &&
                this.blendColor.isColor &&
                (n.blendColor = this.blendColor.getHex()),
              0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
              3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
              !1 === this.depthTest && (n.depthTest = this.depthTest),
              !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
              !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
              255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
              519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
              0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
              255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
              this.stencilFail !== jt && (n.stencilFail = this.stencilFail),
              this.stencilZFail !== jt && (n.stencilZFail = this.stencilZFail),
              this.stencilZPass !== jt && (n.stencilZPass = this.stencilZPass),
              !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
              void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
              void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaHash && (n.alphaHash = !0),
              !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
              !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
              !0 === this.forceSinglePass && (n.forceSinglePass = !0),
              !0 === this.wireframe && (n.wireframe = !0),
              this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.flatShading && (n.flatShading = !0),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              !1 === this.fog && (n.fog = !1),
              Object.keys(this.userData).length > 0 && (n.userData = this.userData),
              e)
            ) {
              const e = i(t.textures),
                r = i(t.images);
              e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
            }
            return n;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.name = t.name),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              this.blendColor.copy(t.blendColor),
              (this.blendAlpha = t.blendAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaHash = t.alphaHash),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.forceSinglePass = t.forceSinglePass),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        class ui extends hi {
          constructor(t) {
            super(),
              (this.isMeshBasicMaterial = !0),
              (this.type = "MeshBasicMaterial"),
              (this.color = new oi(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = c),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        const di = pi();
        function pi() {
          const t = new ArrayBuffer(4),
            e = new Float32Array(t),
            n = new Uint32Array(t),
            i = new Uint32Array(512),
            r = new Uint32Array(512);
          for (let t = 0; t < 256; ++t) {
            const e = t - 127;
            e < -27
              ? ((i[t] = 0), (i[256 | t] = 32768), (r[t] = 24), (r[256 | t] = 24))
              : e < -14
              ? ((i[t] = 1024 >> (-e - 14)),
                (i[256 | t] = (1024 >> (-e - 14)) | 32768),
                (r[t] = -e - 1),
                (r[256 | t] = -e - 1))
              : e <= 15
              ? ((i[t] = (e + 15) << 10),
                (i[256 | t] = ((e + 15) << 10) | 32768),
                (r[t] = 13),
                (r[256 | t] = 13))
              : e < 128
              ? ((i[t] = 31744), (i[256 | t] = 64512), (r[t] = 24), (r[256 | t] = 24))
              : ((i[t] = 31744), (i[256 | t] = 64512), (r[t] = 13), (r[256 | t] = 13));
          }
          const s = new Uint32Array(2048),
            a = new Uint32Array(64),
            o = new Uint32Array(64);
          for (let t = 1; t < 1024; ++t) {
            let e = t << 13,
              n = 0;
            for (; 0 == (8388608 & e); ) (e <<= 1), (n -= 8388608);
            (e &= -8388609), (n += 947912704), (s[t] = e | n);
          }
          for (let t = 1024; t < 2048; ++t) s[t] = 939524096 + ((t - 1024) << 13);
          for (let t = 1; t < 31; ++t) a[t] = t << 23;
          (a[31] = 1199570944), (a[32] = 2147483648);
          for (let t = 33; t < 63; ++t) a[t] = 2147483648 + ((t - 32) << 23);
          a[63] = 3347054592;
          for (let t = 1; t < 64; ++t) 32 !== t && (o[t] = 1024);
          return {
            floatView: e,
            uint32View: n,
            baseTable: i,
            shiftTable: r,
            mantissaTable: s,
            exponentTable: a,
            offsetTable: o,
          };
        }
        function fi(t) {
          Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            (t = re(t, -65504, 65504)),
            (di.floatView[0] = t);
          const e = di.uint32View[0],
            n = (e >> 23) & 511;
          return di.baseTable[n] + ((8388607 & e) >> di.shiftTable[n]);
        }
        function mi(t) {
          const e = t >> 10;
          return (
            (di.uint32View[0] =
              di.mantissaTable[di.offsetTable[e] + (1023 & t)] + di.exponentTable[e]),
            di.floatView[0]
          );
        }
        const gi = { toHalfFloat: fi, fromHalfFloat: mi },
          _i = new ke(),
          vi = new de();
        class xi {
          constructor(t, e, n = !1) {
            if (Array.isArray(t))
              throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            (this.isBufferAttribute = !0),
              (this.name = ""),
              (this.array = t),
              (this.itemSize = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.normalized = n),
              (this.usage = qt),
              (this._updateRange = { offset: 0, count: -1 }),
              (this.updateRanges = []),
              (this.gpuType = H),
              (this.version = 0);
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          get updateRange() {
            return (
              console.warn(
                "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
              ),
              this._updateRange
            );
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          addUpdateRange(t, e) {
            this.updateRanges.push({ start: t, count: e });
          }
          clearUpdateRanges() {
            this.updateRanges.length = 0;
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.usage = t.usage),
              (this.gpuType = t.gpuType),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this;
          }
          copyArray(t) {
            return this.array.set(t), this;
          }
          applyMatrix3(t) {
            if (2 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                vi.fromBufferAttribute(this, e), vi.applyMatrix3(t), this.setXY(e, vi.x, vi.y);
            else if (3 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                _i.fromBufferAttribute(this, e),
                  _i.applyMatrix3(t),
                  this.setXYZ(e, _i.x, _i.y, _i.z);
            return this;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
              _i.fromBufferAttribute(this, e), _i.applyMatrix4(t), this.setXYZ(e, _i.x, _i.y, _i.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              _i.fromBufferAttribute(this, e),
                _i.applyNormalMatrix(t),
                this.setXYZ(e, _i.x, _i.y, _i.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              _i.fromBufferAttribute(this, e),
                _i.transformDirection(t),
                this.setXYZ(e, _i.x, _i.y, _i.z);
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          getComponent(t, e) {
            let n = this.array[t * this.itemSize + e];
            return this.normalized && (n = ce(n, this.array)), n;
          }
          setComponent(t, e, n) {
            return (
              this.normalized && (n = he(n, this.array)),
              (this.array[t * this.itemSize + e] = n),
              this
            );
          }
          getX(t) {
            let e = this.array[t * this.itemSize];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          setX(t, e) {
            return (
              this.normalized && (e = he(e, this.array)), (this.array[t * this.itemSize] = e), this
            );
          }
          getY(t) {
            let e = this.array[t * this.itemSize + 1];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          setY(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.array[t * this.itemSize + 1] = e),
              this
            );
          }
          getZ(t) {
            let e = this.array[t * this.itemSize + 2];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          setZ(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.array[t * this.itemSize + 2] = e),
              this
            );
          }
          getW(t) {
            let e = this.array[t * this.itemSize + 3];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          setW(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.array[t * this.itemSize + 3] = e),
              this
            );
          }
          setXY(t, e, n) {
            return (
              (t *= this.itemSize),
              this.normalized && ((e = he(e, this.array)), (n = he(n, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = he(e, this.array)), (n = he(n, this.array)), (i = he(i, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = he(e, this.array)),
                (n = he(n, this.array)),
                (i = he(i, this.array)),
                (r = he(r, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              (this.array[t + 3] = r),
              this
            );
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            const t = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.from(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (t.name = this.name),
              this.usage !== qt && (t.usage = this.usage),
              t
            );
          }
        }
        class yi extends xi {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        class Mi extends xi {
          constructor(t, e, n) {
            super(new Uint32Array(t), e, n);
          }
        }
        class Si extends xi {
          constructor(t, e, n) {
            super(new Float32Array(t), e, n);
          }
        }
        let bi = 0;
        const Ei = new xn(),
          Ti = new Wn(),
          Ai = new ke(),
          wi = new Xe(),
          Ri = new Xe(),
          Ci = new ke();
        class Li extends Qt {
          constructor() {
            super(),
              (this.isBufferGeometry = !0),
              Object.defineProperty(this, "id", { value: bi++ }),
              (this.uuid = ie()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(t) {
            return (
              Array.isArray(t) ? (this.index = new (me(t) ? Mi : yi)(t, 1)) : (this.index = t), this
            );
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          setAttribute(t, e) {
            return (this.attributes[t] = e), this;
          }
          deleteAttribute(t) {
            return delete this.attributes[t], this;
          }
          hasAttribute(t) {
            return void 0 !== this.attributes[t];
          }
          addGroup(t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          }
          applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new pe().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const i = this.attributes.tangent;
            return (
              void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(t) {
            return Ei.makeRotationFromQuaternion(t), this.applyMatrix4(Ei), this;
          }
          rotateX(t) {
            return Ei.makeRotationX(t), this.applyMatrix4(Ei), this;
          }
          rotateY(t) {
            return Ei.makeRotationY(t), this.applyMatrix4(Ei), this;
          }
          rotateZ(t) {
            return Ei.makeRotationZ(t), this.applyMatrix4(Ei), this;
          }
          translate(t, e, n) {
            return Ei.makeTranslation(t, e, n), this.applyMatrix4(Ei), this;
          }
          scale(t, e, n) {
            return Ei.makeScale(t, e, n), this.applyMatrix4(Ei), this;
          }
          lookAt(t) {
            return Ti.lookAt(t), Ti.updateMatrix(), this.applyMatrix4(Ti.matrix), this;
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(Ai).negate(),
              this.translate(Ai.x, Ai.y, Ai.z),
              this
            );
          }
          setFromPoints(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              e.push(i.x, i.y, i.z || 0);
            }
            return this.setAttribute("position", new Si(e, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Xe());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(
                  new ke(-1 / 0, -1 / 0, -1 / 0),
                  new ke(1 / 0, 1 / 0, 1 / 0)
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  wi.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Ci.addVectors(this.boundingBox.min, wi.min),
                        this.boundingBox.expandByPoint(Ci),
                        Ci.addVectors(this.boundingBox.max, wi.max),
                        this.boundingBox.expandByPoint(Ci))
                      : (this.boundingBox.expandByPoint(wi.min),
                        this.boundingBox.expandByPoint(wi.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new hn());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new ke(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((wi.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Ri.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Ci.addVectors(wi.min, Ri.min),
                        wi.expandByPoint(Ci),
                        Ci.addVectors(wi.max, Ri.max),
                        wi.expandByPoint(Ci))
                      : (wi.expandByPoint(Ri.min), wi.expandByPoint(Ri.max));
                }
              wi.getCenter(n);
              let i = 0;
              for (let e = 0, r = t.count; e < r; e++)
                Ci.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(Ci)));
              if (e)
                for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r],
                    a = this.morphTargetsRelative;
                  for (let e = 0, r = s.count; e < r; e++)
                    Ci.fromBufferAttribute(s, e),
                      a && (Ai.fromBufferAttribute(t, e), Ci.add(Ai)),
                      (i = Math.max(i, n.distanceToSquared(Ci)));
                }
              (this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          }
          computeTangents() {
            const t = this.index,
              e = this.attributes;
            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
              return void console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
            const n = t.array,
              i = e.position.array,
              r = e.normal.array,
              s = e.uv.array,
              a = i.length / 3;
            !1 === this.hasAttribute("tangent") &&
              this.setAttribute("tangent", new xi(new Float32Array(4 * a), 4));
            const o = this.getAttribute("tangent").array,
              l = [],
              c = [];
            for (let t = 0; t < a; t++) (l[t] = new ke()), (c[t] = new ke());
            const h = new ke(),
              u = new ke(),
              d = new ke(),
              p = new de(),
              f = new de(),
              m = new de(),
              g = new ke(),
              _ = new ke();
            function v(t, e, n) {
              h.fromArray(i, 3 * t),
                u.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(s, 2 * t),
                f.fromArray(s, 2 * e),
                m.fromArray(s, 2 * n),
                u.sub(h),
                d.sub(h),
                f.sub(p),
                m.sub(p);
              const r = 1 / (f.x * m.y - m.x * f.y);
              isFinite(r) &&
                (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                _.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(_),
                c[e].add(_),
                c[n].add(_));
            }
            let x = this.groups;
            0 === x.length && (x = [{ start: 0, count: n.length }]);
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3) v(n[t + 0], n[t + 1], n[t + 2]);
            }
            const y = new ke(),
              M = new ke(),
              S = new ke(),
              b = new ke();
            function E(t) {
              S.fromArray(r, 3 * t), b.copy(S);
              const e = l[t];
              y.copy(e), y.sub(S.multiplyScalar(S.dot(e))).normalize(), M.crossVectors(b, e);
              const n = M.dot(c[t]) < 0 ? -1 : 1;
              (o[4 * t] = y.x), (o[4 * t + 1] = y.y), (o[4 * t + 2] = y.z), (o[4 * t + 3] = n);
            }
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3) E(n[t + 0]), E(n[t + 1]), E(n[t + 2]);
            }
          }
          computeVertexNormals() {
            const t = this.index,
              e = this.getAttribute("position");
            if (void 0 !== e) {
              let n = this.getAttribute("normal");
              if (void 0 === n)
                (n = new xi(new Float32Array(3 * e.count), 3)), this.setAttribute("normal", n);
              else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const i = new ke(),
                r = new ke(),
                s = new ke(),
                a = new ke(),
                o = new ke(),
                l = new ke(),
                c = new ke(),
                h = new ke();
              if (t)
                for (let u = 0, d = t.count; u < d; u += 3) {
                  const d = t.getX(u + 0),
                    p = t.getX(u + 1),
                    f = t.getX(u + 2);
                  i.fromBufferAttribute(e, d),
                    r.fromBufferAttribute(e, p),
                    s.fromBufferAttribute(e, f),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    a.fromBufferAttribute(n, d),
                    o.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, f),
                    a.add(c),
                    o.add(c),
                    l.add(c),
                    n.setXYZ(d, a.x, a.y, a.z),
                    n.setXYZ(p, o.x, o.y, o.z),
                    n.setXYZ(f, l.x, l.y, l.z);
                }
              else
                for (let t = 0, a = e.count; t < a; t += 3)
                  i.fromBufferAttribute(e, t + 0),
                    r.fromBufferAttribute(e, t + 1),
                    s.fromBufferAttribute(e, t + 2),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          }
          normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              Ci.fromBufferAttribute(t, e), Ci.normalize(), t.setXYZ(e, Ci.x, Ci.y, Ci.z);
          }
          toNonIndexed() {
            function t(t, e) {
              const n = t.array,
                i = t.itemSize,
                r = t.normalized,
                s = new n.constructor(e.length * i);
              let a = 0,
                o = 0;
              for (let r = 0, l = e.length; r < l; r++) {
                a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                for (let t = 0; t < i; t++) s[o++] = n[a++];
              }
              return new xi(s, i, r);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            const e = new Li(),
              n = this.index.array,
              i = this.attributes;
            for (const r in i) {
              const s = t(i[r], n);
              e.setAttribute(r, s);
            }
            const r = this.morphAttributes;
            for (const i in r) {
              const s = [],
                a = r[i];
              for (let e = 0, i = a.length; e < i; e++) {
                const i = t(a[e], n);
                s.push(i);
              }
              e.morphAttributes[i] = s;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, n = s.length; t < n; t++) {
              const n = s[t];
              e.addGroup(n.start, n.count, n.materialIndex);
            }
            return e;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              "" !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 && (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = { attributes: {} };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const e in n) {
              const i = n[e];
              t.data.attributes[e] = i.toJSON(t.data);
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                s = [];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                s.push(i.toJSON(t.data));
              }
              s.length > 0 && ((i[e] = s), (r = !0));
            }
            r &&
              ((t.data.morphAttributes = i),
              (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return (
              null !== a &&
                (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }),
              t
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
              const n = i[t];
              this.setAttribute(t, n.clone(e));
            }
            const r = t.morphAttributes;
            for (const t in r) {
              const n = [],
                i = r[t];
              for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
              this.morphAttributes[t] = n;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t];
              this.addGroup(e.start, e.count, e.materialIndex);
            }
            const a = t.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = t.boundingSphere;
            return (
              null !== o && (this.boundingSphere = o.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        const Pi = new xn(),
          Ii = new vn(),
          Ui = new hn(),
          Ni = new ke(),
          Di = new ke(),
          Oi = new ke(),
          Bi = new ke(),
          Fi = new ke(),
          zi = new ke(),
          Hi = new de(),
          Gi = new de(),
          ki = new de(),
          Vi = new ke(),
          Wi = new ke(),
          Xi = new ke(),
          ji = new ke(),
          qi = new ke();
        class Yi extends Wn {
          constructor(t = new Li(), e = new ui()) {
            super(),
              (this.isMesh = !0),
              (this.type = "Mesh"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
              (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
          getVertexPosition(t, e) {
            const n = this.geometry,
              i = n.attributes.position,
              r = n.morphAttributes.position,
              s = n.morphTargetsRelative;
            e.fromBufferAttribute(i, t);
            const a = this.morphTargetInfluences;
            if (r && a) {
              zi.set(0, 0, 0);
              for (let n = 0, i = r.length; n < i; n++) {
                const i = a[n],
                  o = r[n];
                0 !== i &&
                  (Fi.fromBufferAttribute(o, t),
                  s ? zi.addScaledVector(Fi, i) : zi.addScaledVector(Fi.sub(e), i));
              }
              e.add(zi);
            }
            return e;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.material,
              r = this.matrixWorld;
            if (void 0 !== i) {
              if (
                (null === n.boundingSphere && n.computeBoundingSphere(),
                Ui.copy(n.boundingSphere),
                Ui.applyMatrix4(r),
                Ii.copy(t.ray).recast(t.near),
                !1 === Ui.containsPoint(Ii.origin))
              ) {
                if (null === Ii.intersectSphere(Ui, Ni)) return;
                if (Ii.origin.distanceToSquared(Ni) > (t.far - t.near) ** 2) return;
              }
              Pi.copy(r).invert(),
                Ii.copy(t.ray).applyMatrix4(Pi),
                (null !== n.boundingBox && !1 === Ii.intersectsBox(n.boundingBox)) ||
                  this._computeIntersections(t, e, Ii);
            }
          }
          _computeIntersections(t, e, n) {
            let i;
            const r = this.geometry,
              s = this.material,
              a = r.index,
              o = r.attributes.position,
              l = r.attributes.uv,
              c = r.attributes.uv1,
              h = r.attributes.normal,
              u = r.groups,
              d = r.drawRange;
            if (null !== a)
              if (Array.isArray(s))
                for (let r = 0, o = u.length; r < o; r++) {
                  const o = u[r],
                    p = s[o.materialIndex];
                  for (
                    let r = Math.max(o.start, d.start),
                      s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count));
                    r < s;
                    r += 3
                  )
                    (i = Ki(this, p, t, n, l, c, h, a.getX(r), a.getX(r + 1), a.getX(r + 2))),
                      i &&
                        ((i.faceIndex = Math.floor(r / 3)),
                        (i.face.materialIndex = o.materialIndex),
                        e.push(i));
                }
              else
                for (
                  let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count);
                  r < o;
                  r += 3
                )
                  (i = Ki(this, s, t, n, l, c, h, a.getX(r), a.getX(r + 1), a.getX(r + 2))),
                    i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
            else if (void 0 !== o)
              if (Array.isArray(s))
                for (let r = 0, a = u.length; r < a; r++) {
                  const a = u[r],
                    p = s[a.materialIndex];
                  for (
                    let r = Math.max(a.start, d.start),
                      s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count));
                    r < s;
                    r += 3
                  )
                    (i = Ki(this, p, t, n, l, c, h, r, r + 1, r + 2)),
                      i &&
                        ((i.faceIndex = Math.floor(r / 3)),
                        (i.face.materialIndex = a.materialIndex),
                        e.push(i));
                }
              else
                for (
                  let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count);
                  r < a;
                  r += 3
                )
                  (i = Ki(this, s, t, n, l, c, h, r, r + 1, r + 2)),
                    i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
          }
        }
        function Ki(t, e, n, i, r, s, a, o, l, c) {
          t.getVertexPosition(o, Di), t.getVertexPosition(l, Oi), t.getVertexPosition(c, Bi);
          const h = (function (t, e, n, i, r, s, a, o) {
            let l;
            if (
              ((l =
                1 === e.side
                  ? i.intersectTriangle(a, s, r, !0, o)
                  : i.intersectTriangle(r, s, a, 0 === e.side, o)),
              null === l)
            )
              return null;
            qi.copy(o), qi.applyMatrix4(t.matrixWorld);
            const c = n.ray.origin.distanceTo(qi);
            return c < n.near || c > n.far ? null : { distance: c, point: qi.clone(), object: t };
          })(t, e, n, i, Di, Oi, Bi, ji);
          if (h) {
            r &&
              (Hi.fromBufferAttribute(r, o),
              Gi.fromBufferAttribute(r, l),
              ki.fromBufferAttribute(r, c),
              (h.uv = ni.getInterpolation(ji, Di, Oi, Bi, Hi, Gi, ki, new de()))),
              s &&
                (Hi.fromBufferAttribute(s, o),
                Gi.fromBufferAttribute(s, l),
                ki.fromBufferAttribute(s, c),
                (h.uv1 = ni.getInterpolation(ji, Di, Oi, Bi, Hi, Gi, ki, new de())),
                (h.uv2 = h.uv1)),
              a &&
                (Vi.fromBufferAttribute(a, o),
                Wi.fromBufferAttribute(a, l),
                Xi.fromBufferAttribute(a, c),
                (h.normal = ni.getInterpolation(ji, Di, Oi, Bi, Vi, Wi, Xi, new ke())),
                h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
            const t = { a: o, b: l, c, normal: new ke(), materialIndex: 0 };
            ni.getNormal(Di, Oi, Bi, t.normal), (h.face = t);
          }
          return h;
        }
        class Zi extends Li {
          constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
            super(),
              (this.type = "BoxGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s,
              });
            const a = this;
            (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
            const o = [],
              l = [],
              c = [],
              h = [];
            let u = 0,
              d = 0;
            function p(t, e, n, i, r, s, p, f, m, g, _) {
              const v = s / m,
                x = p / g,
                y = s / 2,
                M = p / 2,
                S = f / 2,
                b = m + 1,
                E = g + 1;
              let T = 0,
                A = 0;
              const w = new ke();
              for (let s = 0; s < E; s++) {
                const a = s * x - M;
                for (let o = 0; o < b; o++) {
                  const u = o * v - y;
                  (w[t] = u * i),
                    (w[e] = a * r),
                    (w[n] = S),
                    l.push(w.x, w.y, w.z),
                    (w[t] = 0),
                    (w[e] = 0),
                    (w[n] = f > 0 ? 1 : -1),
                    c.push(w.x, w.y, w.z),
                    h.push(o / m),
                    h.push(1 - s / g),
                    (T += 1);
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < m; e++) {
                  const n = u + e + b * t,
                    i = u + e + b * (t + 1),
                    r = u + (e + 1) + b * (t + 1),
                    s = u + (e + 1) + b * t;
                  o.push(n, i, s), o.push(i, r, s), (A += 6);
                }
              a.addGroup(d, A, _), (d += A), (u += T);
            }
            p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
              p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
              p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
              p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
              p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
              p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
              this.setIndex(o),
              this.setAttribute("position", new Si(l, 3)),
              this.setAttribute("normal", new Si(c, 3)),
              this.setAttribute("uv", new Si(h, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new Zi(
              t.width,
              t.height,
              t.depth,
              t.widthSegments,
              t.heightSegments,
              t.depthSegments
            );
          }
        }
        function Ji(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
              const r = t[n][i];
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? r.isRenderTargetTexture
                  ? (console.warn(
                      "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                    ),
                    (e[n][i] = null))
                  : (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r);
            }
          }
          return e;
        }
        function Qi(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const i = Ji(t[n]);
            for (const t in i) e[t] = i[t];
          }
          return e;
        }
        function $i(t) {
          return null === t.getRenderTarget() ? t.outputColorSpace : Ae.workingColorSpace;
        }
        const tr = { clone: Ji, merge: Qi };
        class er extends hi {
          constructor(t) {
            super(),
              (this.isShaderMaterial = !0),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.uniformsGroups = []),
              (this.vertexShader =
                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
              (this.fragmentShader =
                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.forceSinglePass = !0),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
                clipCullDistance: !1,
              }),
              (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== t && this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = Ji(t.uniforms)),
              (this.uniformsGroups = (function (t) {
                const e = [];
                for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                return e;
              })(t.uniformsGroups)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.fog = t.fog),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const n in this.uniforms) {
              const i = this.uniforms[n].value;
              i && i.isTexture
                ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
                : i && i.isColor
                ? (e.uniforms[n] = { type: "c", value: i.getHex() })
                : i && i.isVector2
                ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
                : i && i.isVector3
                ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
                : i && i.isVector4
                ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
                : i && i.isMatrix3
                ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
                : i && i.isMatrix4
                ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
                : (e.uniforms[n] = { value: i });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader),
              (e.lights = this.lights),
              (e.clipping = this.clipping);
            const n = {};
            for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }
        }
        class nr extends Wn {
          constructor() {
            super(),
              (this.isCamera = !0),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new xn()),
              (this.projectionMatrix = new xn()),
              (this.projectionMatrixInverse = new xn()),
              (this.coordinateSystem = Zt);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              (this.coordinateSystem = t.coordinateSystem),
              this
            );
          }
          getWorldDirection(t) {
            return super.getWorldDirection(t).negate();
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class ir extends nr {
          constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
            super(),
              (this.isPerspectiveCamera = !0),
              (this.type = "PerspectiveCamera"),
              (this.fov = t),
              (this.zoom = 1),
              (this.near = n),
              (this.far = i),
              (this.focus = 10),
              (this.aspect = e),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          }
          setFocalLength(t) {
            const e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * ne * Math.atan(e)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            const t = Math.tan(0.5 * ee * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          }
          getEffectiveFOV() {
            return 2 * ne * Math.atan(Math.tan(0.5 * ee * this.fov) / this.zoom);
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(t, e, n, i, r, s) {
            (this.aspect = t / e),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = this.near;
            let e = (t * Math.tan(0.5 * ee * this.fov)) / this.zoom,
              n = 2 * e,
              i = this.aspect * n,
              r = -0.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
              const t = s.fullWidth,
                a = s.fullHeight;
              (r += (s.offsetX * i) / t),
                (e -= (s.offsetY * n) / a),
                (i *= s.width / t),
                (n *= s.height / a);
            }
            const a = this.filmOffset;
            0 !== a && (r += (t * a) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                r,
                r + i,
                e,
                e - n,
                t,
                this.far,
                this.coordinateSystem
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view && (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          }
        }
        const rr = -90;
        class sr extends Wn {
          constructor(t, e, n) {
            super(),
              (this.type = "CubeCamera"),
              (this.renderTarget = n),
              (this.coordinateSystem = null),
              (this.activeMipmapLevel = 0);
            const i = new ir(rr, 1, t, e);
            (i.layers = this.layers), this.add(i);
            const r = new ir(rr, 1, t, e);
            (r.layers = this.layers), this.add(r);
            const s = new ir(rr, 1, t, e);
            (s.layers = this.layers), this.add(s);
            const a = new ir(rr, 1, t, e);
            (a.layers = this.layers), this.add(a);
            const o = new ir(rr, 1, t, e);
            (o.layers = this.layers), this.add(o);
            const l = new ir(rr, 1, t, e);
            (l.layers = this.layers), this.add(l);
          }
          updateCoordinateSystem() {
            const t = this.coordinateSystem,
              e = this.children.concat(),
              [n, i, r, s, a, o] = e;
            for (const t of e) this.remove(t);
            if (t === Zt)
              n.up.set(0, 1, 0),
                n.lookAt(1, 0, 0),
                i.up.set(0, 1, 0),
                i.lookAt(-1, 0, 0),
                r.up.set(0, 0, -1),
                r.lookAt(0, 1, 0),
                s.up.set(0, 0, 1),
                s.lookAt(0, -1, 0),
                a.up.set(0, 1, 0),
                a.lookAt(0, 0, 1),
                o.up.set(0, 1, 0),
                o.lookAt(0, 0, -1);
            else {
              if (t !== Jt)
                throw new Error(
                  "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t
                );
              n.up.set(0, -1, 0),
                n.lookAt(-1, 0, 0),
                i.up.set(0, -1, 0),
                i.lookAt(1, 0, 0),
                r.up.set(0, 0, 1),
                r.lookAt(0, 1, 0),
                s.up.set(0, 0, -1),
                s.lookAt(0, -1, 0),
                a.up.set(0, -1, 0),
                a.lookAt(0, 0, 1),
                o.up.set(0, -1, 0),
                o.lookAt(0, 0, -1);
            }
            for (const t of e) this.add(t), t.updateMatrixWorld();
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const { renderTarget: n, activeMipmapLevel: i } = this;
            this.coordinateSystem !== t.coordinateSystem &&
              ((this.coordinateSystem = t.coordinateSystem), this.updateCoordinateSystem());
            const [r, s, a, o, l, c] = this.children,
              h = t.getRenderTarget(),
              u = t.getActiveCubeFace(),
              d = t.getActiveMipmapLevel(),
              p = t.xr.enabled;
            t.xr.enabled = !1;
            const f = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0, i),
              t.render(e, r),
              t.setRenderTarget(n, 1, i),
              t.render(e, s),
              t.setRenderTarget(n, 2, i),
              t.render(e, a),
              t.setRenderTarget(n, 3, i),
              t.render(e, o),
              t.setRenderTarget(n, 4, i),
              t.render(e, l),
              (n.texture.generateMipmaps = f),
              t.setRenderTarget(n, 5, i),
              t.render(e, c),
              t.setRenderTarget(h, u, d),
              (t.xr.enabled = p),
              (n.texture.needsPMREMUpdate = !0);
          }
        }
        class ar extends De {
          constructor(t, e, n, i, r, s, a, o, l, c) {
            super((t = void 0 !== t ? t : []), (e = void 0 !== e ? e : S), n, i, r, s, a, o, l, c),
              (this.isCubeTexture = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        class or extends Fe {
          constructor(t = 1, e = {}) {
            super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
            const n = { width: t, height: t, depth: 1 },
              i = [n, n, n, n, n, n];
            void 0 !== e.encoding &&
              (Me(
                "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
              ),
              (e.colorSpace = e.encoding === Ot ? Ft : Bt)),
              (this.texture = new ar(
                i,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.colorSpace
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : U);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.colorSpace = e.colorSpace),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = { tEquirect: { value: null } },
              i =
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              r =
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
              s = new Zi(5, 5, 5),
              a = new er({
                name: "CubemapFromEquirect",
                uniforms: Ji(n),
                vertexShader: i,
                fragmentShader: r,
                side: 1,
                blending: 0,
              });
            a.uniforms.tEquirect.value = e;
            const o = new Yi(s, a),
              l = e.minFilter;
            return (
              e.minFilter === D && (e.minFilter = U),
              new sr(1, 10, this).update(t, o),
              (e.minFilter = l),
              o.geometry.dispose(),
              o.material.dispose(),
              this
            );
          }
          clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r);
          }
        }
        const lr = new ke(),
          cr = new ke(),
          hr = new pe();
        class ur {
          constructor(t = new ke(1, 0, 0), e = 0) {
            (this.isPlane = !0), (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
          }
          setFromCoplanarPoints(t, e, n) {
            const i = lr.subVectors(n, e).cross(cr.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this;
          }
          copy(t) {
            return this.normal.copy(t.normal), (this.constant = t.constant), this;
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
          }
          intersectLine(t, e) {
            const n = t.delta(lr),
              i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant);
          }
          applyMatrix4(t, e) {
            const n = e || hr.getNormalMatrix(t),
              i = this.coplanarPoint(lr).applyMatrix4(t),
              r = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -i.dot(r)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const dr = new hn(),
          pr = new ke();
        class fr {
          constructor(
            t = new ur(),
            e = new ur(),
            n = new ur(),
            i = new ur(),
            r = new ur(),
            s = new ur()
          ) {
            this.planes = [t, e, n, i, r, s];
          }
          set(t, e, n, i, r, s) {
            const a = this.planes;
            return (
              a[0].copy(t),
              a[1].copy(e),
              a[2].copy(n),
              a[3].copy(i),
              a[4].copy(r),
              a[5].copy(s),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t, e = 2e3) {
            const n = this.planes,
              i = t.elements,
              r = i[0],
              s = i[1],
              a = i[2],
              o = i[3],
              l = i[4],
              c = i[5],
              h = i[6],
              u = i[7],
              d = i[8],
              p = i[9],
              f = i[10],
              m = i[11],
              g = i[12],
              _ = i[13],
              v = i[14],
              x = i[15];
            if (
              (n[0].setComponents(o - r, u - l, m - d, x - g).normalize(),
              n[1].setComponents(o + r, u + l, m + d, x + g).normalize(),
              n[2].setComponents(o + s, u + c, m + p, x + _).normalize(),
              n[3].setComponents(o - s, u - c, m - p, x - _).normalize(),
              n[4].setComponents(o - a, u - h, m - f, x - v).normalize(),
              e === Zt)
            )
              n[5].setComponents(o + a, u + h, m + f, x + v).normalize();
            else {
              if (e !== Jt)
                throw new Error(
                  "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e
                );
              n[5].setComponents(a, h, f, v).normalize();
            }
            return this;
          }
          intersectsObject(t) {
            if (void 0 !== t.boundingSphere)
              null === t.boundingSphere && t.computeBoundingSphere(),
                dr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
            else {
              const e = t.geometry;
              null === e.boundingSphere && e.computeBoundingSphere(),
                dr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
            }
            return this.intersectsSphere(dr);
          }
          intersectsSprite(t) {
            return (
              dr.center.set(0, 0, 0),
              (dr.radius = 0.7071067811865476),
              dr.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(dr)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              i = -t.radius;
            for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1;
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const i = e[n];
              if (
                ((pr.x = i.normal.x > 0 ? t.max.x : t.min.x),
                (pr.y = i.normal.y > 0 ? t.max.y : t.min.y),
                (pr.z = i.normal.z > 0 ? t.max.z : t.min.z),
                i.distanceToPoint(pr) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function mr() {
          let t = null,
            e = !1,
            n = null,
            i = null;
          function r(e, s) {
            n(e, s), (i = t.requestAnimationFrame(r));
          }
          return {
            start: function () {
              !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(i), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function gr(t, e) {
          const n = e.isWebGL2,
            i = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = i.get(e);
              n && (t.deleteBuffer(n.buffer), i.delete(e));
            },
            update: function (e, r) {
              if (e.isGLBufferAttribute) {
                const t = i.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  i.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const s = i.get(e);
              if (void 0 === s)
                i.set(
                  e,
                  (function (e, i) {
                    const r = e.array,
                      s = e.usage,
                      a = r.byteLength,
                      o = t.createBuffer();
                    let l;
                    if (
                      (t.bindBuffer(i, o),
                      t.bufferData(i, r, s),
                      e.onUploadCallback(),
                      r instanceof Float32Array)
                    )
                      l = t.FLOAT;
                    else if (r instanceof Uint16Array)
                      if (e.isFloat16BufferAttribute) {
                        if (!n)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                        l = t.HALF_FLOAT;
                      } else l = t.UNSIGNED_SHORT;
                    else if (r instanceof Int16Array) l = t.SHORT;
                    else if (r instanceof Uint32Array) l = t.UNSIGNED_INT;
                    else if (r instanceof Int32Array) l = t.INT;
                    else if (r instanceof Int8Array) l = t.BYTE;
                    else if (r instanceof Uint8Array) l = t.UNSIGNED_BYTE;
                    else {
                      if (!(r instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " + r
                        );
                      l = t.UNSIGNED_BYTE;
                    }
                    return {
                      buffer: o,
                      type: l,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: e.version,
                      size: a,
                    };
                  })(e, r)
                );
              else if (s.version < e.version) {
                if (s.size !== e.array.byteLength)
                  throw new Error(
                    "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
                  );
                !(function (e, i, r) {
                  const s = i.array,
                    a = i._updateRange,
                    o = i.updateRanges;
                  if (
                    (t.bindBuffer(r, e),
                    -1 === a.count && 0 === o.length && t.bufferSubData(r, 0, s),
                    0 !== o.length)
                  ) {
                    for (let e = 0, i = o.length; e < i; e++) {
                      const i = o[e];
                      n
                        ? t.bufferSubData(r, i.start * s.BYTES_PER_ELEMENT, s, i.start, i.count)
                        : t.bufferSubData(
                            r,
                            i.start * s.BYTES_PER_ELEMENT,
                            s.subarray(i.start, i.start + i.count)
                          );
                    }
                    i.clearUpdateRanges();
                  }
                  -1 !== a.count &&
                    (n
                      ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count)
                      : t.bufferSubData(
                          r,
                          a.offset * s.BYTES_PER_ELEMENT,
                          s.subarray(a.offset, a.offset + a.count)
                        ),
                    (a.count = -1)),
                    i.onUploadCallback();
                })(s.buffer, e, r),
                  (s.version = e.version);
              }
            },
          };
        }
        class _r extends Li {
          constructor(t = 1, e = 1, n = 1, i = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i });
            const r = t / 2,
              s = e / 2,
              a = Math.floor(n),
              o = Math.floor(i),
              l = a + 1,
              c = o + 1,
              h = t / a,
              u = e / o,
              d = [],
              p = [],
              f = [],
              m = [];
            for (let t = 0; t < c; t++) {
              const e = t * u - s;
              for (let n = 0; n < l; n++) {
                const i = n * h - r;
                p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - t / o);
              }
            }
            for (let t = 0; t < o; t++)
              for (let e = 0; e < a; e++) {
                const n = e + l * t,
                  i = e + l * (t + 1),
                  r = e + 1 + l * (t + 1),
                  s = e + 1 + l * t;
                d.push(n, i, s), d.push(i, r, s);
              }
            this.setIndex(d),
              this.setAttribute("position", new Si(p, 3)),
              this.setAttribute("normal", new Si(f, 3)),
              this.setAttribute("uv", new Si(m, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new _r(t.width, t.height, t.widthSegments, t.heightSegments);
          }
        }
        const vr = {
            alphahash_fragment:
              "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment:
              "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment:
              "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment:
              "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment:
              "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment:
              "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex:
              "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            batching_vertex:
              "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
            begin_vertex:
              "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex:
              "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs:
              "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment:
              "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment:
              "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common:
              "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment:
              "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex:
              "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment:
              "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
            envmap_fragment:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex:
              "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment:
              "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment:
              "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment:
              "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment:
              "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment:
              "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment:
              "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment:
              "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment:
              "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin:
              "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment:
              "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment:
              "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment:
              "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment:
              "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment:
              "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment:
              "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin:
              "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps:
              "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end:
              "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment:
              "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment:
              "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment:
              "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment:
              "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex:
              "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex:
              "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex:
              "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex:
              "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin:
              "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps:
              "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex:
              "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment:
              "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin:
              "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment:
              "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment:
              "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment:
              "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing:
              "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment:
              "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex:
              "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment:
              "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment:
              "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment:
              "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment:
              "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment:
              "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex:
              "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex:
              "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment:
              "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex:
              "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex:
              "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex:
              "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex:
              "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment:
              "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment:
              "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment:
              "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment:
              "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment:
              "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment:
              "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex:
              "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert:
              "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag:
              "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag:
              "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag:
              "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert:
              "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag:
              "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert:
              "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag:
              "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag:
              "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert:
              "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert:
              "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert:
              "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag:
              "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert:
              "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag:
              "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert:
              "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag:
              "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert:
              "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag:
              "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert:
              "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag:
              "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert:
              "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag:
              "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert:
              "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert:
              "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag:
              "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert:
              "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          },
          xr = {
            common: {
              diffuse: { value: new oi(16777215) },
              opacity: { value: 1 },
              map: { value: null },
              mapTransform: { value: new pe() },
              alphaMap: { value: null },
              alphaMapTransform: { value: new pe() },
              alphaTest: { value: 0 },
            },
            specularmap: {
              specularMap: { value: null },
              specularMapTransform: { value: new pe() },
            },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              ior: { value: 1.5 },
              refractionRatio: { value: 0.98 },
            },
            aomap: {
              aoMap: { value: null },
              aoMapIntensity: { value: 1 },
              aoMapTransform: { value: new pe() },
            },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 },
              lightMapTransform: { value: new pe() },
            },
            bumpmap: {
              bumpMap: { value: null },
              bumpMapTransform: { value: new pe() },
              bumpScale: { value: 1 },
            },
            normalmap: {
              normalMap: { value: null },
              normalMapTransform: { value: new pe() },
              normalScale: { value: new de(1, 1) },
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementMapTransform: { value: new pe() },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 },
            },
            emissivemap: {
              emissiveMap: { value: null },
              emissiveMapTransform: { value: new pe() },
            },
            metalnessmap: {
              metalnessMap: { value: null },
              metalnessMapTransform: { value: new pe() },
            },
            roughnessmap: {
              roughnessMap: { value: null },
              roughnessMapTransform: { value: new pe() },
            },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new oi(16777215) },
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: { value: [], properties: { direction: {}, color: {} } },
              directionalLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                },
              },
              spotLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              spotLightMap: { value: [] },
              spotShadowMap: { value: [] },
              spotLightMatrix: { value: [] },
              pointLights: {
                value: [],
                properties: { color: {}, position: {}, decay: {}, distance: {} },
              },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {},
                },
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
              },
              rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
              },
              ltc_1: { value: null },
              ltc_2: { value: null },
            },
            points: {
              diffuse: { value: new oi(16777215) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              alphaMap: { value: null },
              alphaMapTransform: { value: new pe() },
              alphaTest: { value: 0 },
              uvTransform: { value: new pe() },
            },
            sprite: {
              diffuse: { value: new oi(16777215) },
              opacity: { value: 1 },
              center: { value: new de(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              mapTransform: { value: new pe() },
              alphaMap: { value: null },
              alphaMapTransform: { value: new pe() },
              alphaTest: { value: 0 },
            },
          },
          yr = {
            basic: {
              uniforms: Qi([xr.common, xr.specularmap, xr.envmap, xr.aomap, xr.lightmap, xr.fog]),
              vertexShader: vr.meshbasic_vert,
              fragmentShader: vr.meshbasic_frag,
            },
            lambert: {
              uniforms: Qi([
                xr.common,
                xr.specularmap,
                xr.envmap,
                xr.aomap,
                xr.lightmap,
                xr.emissivemap,
                xr.bumpmap,
                xr.normalmap,
                xr.displacementmap,
                xr.fog,
                xr.lights,
                { emissive: { value: new oi(0) } },
              ]),
              vertexShader: vr.meshlambert_vert,
              fragmentShader: vr.meshlambert_frag,
            },
            phong: {
              uniforms: Qi([
                xr.common,
                xr.specularmap,
                xr.envmap,
                xr.aomap,
                xr.lightmap,
                xr.emissivemap,
                xr.bumpmap,
                xr.normalmap,
                xr.displacementmap,
                xr.fog,
                xr.lights,
                {
                  emissive: { value: new oi(0) },
                  specular: { value: new oi(1118481) },
                  shininess: { value: 30 },
                },
              ]),
              vertexShader: vr.meshphong_vert,
              fragmentShader: vr.meshphong_frag,
            },
            standard: {
              uniforms: Qi([
                xr.common,
                xr.envmap,
                xr.aomap,
                xr.lightmap,
                xr.emissivemap,
                xr.bumpmap,
                xr.normalmap,
                xr.displacementmap,
                xr.roughnessmap,
                xr.metalnessmap,
                xr.fog,
                xr.lights,
                {
                  emissive: { value: new oi(0) },
                  roughness: { value: 1 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 },
                },
              ]),
              vertexShader: vr.meshphysical_vert,
              fragmentShader: vr.meshphysical_frag,
            },
            toon: {
              uniforms: Qi([
                xr.common,
                xr.aomap,
                xr.lightmap,
                xr.emissivemap,
                xr.bumpmap,
                xr.normalmap,
                xr.displacementmap,
                xr.gradientmap,
                xr.fog,
                xr.lights,
                { emissive: { value: new oi(0) } },
              ]),
              vertexShader: vr.meshtoon_vert,
              fragmentShader: vr.meshtoon_frag,
            },
            matcap: {
              uniforms: Qi([
                xr.common,
                xr.bumpmap,
                xr.normalmap,
                xr.displacementmap,
                xr.fog,
                { matcap: { value: null } },
              ]),
              vertexShader: vr.meshmatcap_vert,
              fragmentShader: vr.meshmatcap_frag,
            },
            points: {
              uniforms: Qi([xr.points, xr.fog]),
              vertexShader: vr.points_vert,
              fragmentShader: vr.points_frag,
            },
            dashed: {
              uniforms: Qi([
                xr.common,
                xr.fog,
                { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
              ]),
              vertexShader: vr.linedashed_vert,
              fragmentShader: vr.linedashed_frag,
            },
            depth: {
              uniforms: Qi([xr.common, xr.displacementmap]),
              vertexShader: vr.depth_vert,
              fragmentShader: vr.depth_frag,
            },
            normal: {
              uniforms: Qi([
                xr.common,
                xr.bumpmap,
                xr.normalmap,
                xr.displacementmap,
                { opacity: { value: 1 } },
              ]),
              vertexShader: vr.meshnormal_vert,
              fragmentShader: vr.meshnormal_frag,
            },
            sprite: {
              uniforms: Qi([xr.sprite, xr.fog]),
              vertexShader: vr.sprite_vert,
              fragmentShader: vr.sprite_frag,
            },
            background: {
              uniforms: {
                uvTransform: { value: new pe() },
                t2D: { value: null },
                backgroundIntensity: { value: 1 },
              },
              vertexShader: vr.background_vert,
              fragmentShader: vr.background_frag,
            },
            backgroundCube: {
              uniforms: {
                envMap: { value: null },
                flipEnvMap: { value: -1 },
                backgroundBlurriness: { value: 0 },
                backgroundIntensity: { value: 1 },
              },
              vertexShader: vr.backgroundCube_vert,
              fragmentShader: vr.backgroundCube_frag,
            },
            cube: {
              uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
              vertexShader: vr.cube_vert,
              fragmentShader: vr.cube_frag,
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: vr.equirect_vert,
              fragmentShader: vr.equirect_frag,
            },
            distanceRGBA: {
              uniforms: Qi([
                xr.common,
                xr.displacementmap,
                {
                  referencePosition: { value: new ke() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1e3 },
                },
              ]),
              vertexShader: vr.distanceRGBA_vert,
              fragmentShader: vr.distanceRGBA_frag,
            },
            shadow: {
              uniforms: Qi([
                xr.lights,
                xr.fog,
                { color: { value: new oi(0) }, opacity: { value: 1 } },
              ]),
              vertexShader: vr.shadow_vert,
              fragmentShader: vr.shadow_frag,
            },
          };
        yr.physical = {
          uniforms: Qi([
            yr.standard.uniforms,
            {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatMapTransform: { value: new pe() },
              clearcoatNormalMap: { value: null },
              clearcoatNormalMapTransform: { value: new pe() },
              clearcoatNormalScale: { value: new de(1, 1) },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatRoughnessMapTransform: { value: new pe() },
              iridescence: { value: 0 },
              iridescenceMap: { value: null },
              iridescenceMapTransform: { value: new pe() },
              iridescenceIOR: { value: 1.3 },
              iridescenceThicknessMinimum: { value: 100 },
              iridescenceThicknessMaximum: { value: 400 },
              iridescenceThicknessMap: { value: null },
              iridescenceThicknessMapTransform: { value: new pe() },
              sheen: { value: 0 },
              sheenColor: { value: new oi(0) },
              sheenColorMap: { value: null },
              sheenColorMapTransform: { value: new pe() },
              sheenRoughness: { value: 1 },
              sheenRoughnessMap: { value: null },
              sheenRoughnessMapTransform: { value: new pe() },
              transmission: { value: 0 },
              transmissionMap: { value: null },
              transmissionMapTransform: { value: new pe() },
              transmissionSamplerSize: { value: new de() },
              transmissionSamplerMap: { value: null },
              thickness: { value: 0 },
              thicknessMap: { value: null },
              thicknessMapTransform: { value: new pe() },
              attenuationDistance: { value: 0 },
              attenuationColor: { value: new oi(0) },
              specularColor: { value: new oi(1, 1, 1) },
              specularColorMap: { value: null },
              specularColorMapTransform: { value: new pe() },
              specularIntensity: { value: 1 },
              specularIntensityMap: { value: null },
              specularIntensityMapTransform: { value: new pe() },
              anisotropyVector: { value: new de() },
              anisotropyMap: { value: null },
              anisotropyMapTransform: { value: new pe() },
            },
          ]),
          vertexShader: vr.meshphysical_vert,
          fragmentShader: vr.meshphysical_frag,
        };
        const Mr = { r: 0, b: 0, g: 0 };
        function Sr(t, e, n, i, r, s, a) {
          const o = new oi(0);
          let l,
            c,
            h = !0 === s ? 0 : 1,
            u = null,
            d = 0,
            p = null;
          function f(e, n) {
            e.getRGB(Mr, $i(t)), i.buffers.color.setClear(Mr.r, Mr.g, Mr.b, n, a);
          }
          return {
            getClearColor: function () {
              return o;
            },
            setClearColor: function (t, e = 1) {
              o.set(t), (h = e), f(o, h);
            },
            getClearAlpha: function () {
              return h;
            },
            setClearAlpha: function (t) {
              (h = t), f(o, h);
            },
            render: function (s, m) {
              let g = !1,
                _ = !0 === m.isScene ? m.background : null;
              _ && _.isTexture && (_ = (m.backgroundBlurriness > 0 ? n : e).get(_)),
                null === _ ? f(o, h) : _ && _.isColor && (f(_, 1), (g = !0));
              const v = t.xr.getEnvironmentBlendMode();
              "additive" === v
                ? i.buffers.color.setClear(0, 0, 0, 1, a)
                : "alpha-blend" === v && i.buffers.color.setClear(0, 0, 0, 0, a),
                (t.autoClear || g) &&
                  t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                _ && (_.isCubeTexture || _.mapping === A)
                  ? (void 0 === c &&
                      ((c = new Yi(
                        new Zi(1, 1, 1),
                        new er({
                          name: "BackgroundCubeMaterial",
                          uniforms: Ji(yr.backgroundCube.uniforms),
                          vertexShader: yr.backgroundCube.vertexShader,
                          fragmentShader: yr.backgroundCube.fragmentShader,
                          side: 1,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      c.geometry.deleteAttribute("normal"),
                      c.geometry.deleteAttribute("uv"),
                      (c.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(c.material, "envMap", {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      r.update(c)),
                    (c.material.uniforms.envMap.value = _),
                    (c.material.uniforms.flipEnvMap.value =
                      _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1),
                    (c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness),
                    (c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity),
                    (c.material.toneMapped = Ae.getTransfer(_.colorSpace) !== Vt),
                    (u === _ && d === _.version && p === t.toneMapping) ||
                      ((c.material.needsUpdate = !0),
                      (u = _),
                      (d = _.version),
                      (p = t.toneMapping)),
                    c.layers.enableAll(),
                    s.unshift(c, c.geometry, c.material, 0, 0, null))
                  : _ &&
                    _.isTexture &&
                    (void 0 === l &&
                      ((l = new Yi(
                        new _r(2, 2),
                        new er({
                          name: "BackgroundMaterial",
                          uniforms: Ji(yr.background.uniforms),
                          vertexShader: yr.background.vertexShader,
                          fragmentShader: yr.background.fragmentShader,
                          side: 0,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      l.geometry.deleteAttribute("normal"),
                      Object.defineProperty(l.material, "map", {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      r.update(l)),
                    (l.material.uniforms.t2D.value = _),
                    (l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity),
                    (l.material.toneMapped = Ae.getTransfer(_.colorSpace) !== Vt),
                    !0 === _.matrixAutoUpdate && _.updateMatrix(),
                    l.material.uniforms.uvTransform.value.copy(_.matrix),
                    (u === _ && d === _.version && p === t.toneMapping) ||
                      ((l.material.needsUpdate = !0),
                      (u = _),
                      (d = _.version),
                      (p = t.toneMapping)),
                    l.layers.enableAll(),
                    s.unshift(l, l.geometry, l.material, 0, 0, null));
            },
          };
        }
        function br(t, e, n, i) {
          const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            a = i.isWebGL2 || null !== s,
            o = {},
            l = p(null);
          let c = l,
            h = !1;
          function u(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
          }
          function d(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
          }
          function p(t) {
            const e = [],
              n = [],
              i = [];
            for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: i,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function f() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function m(t) {
            g(t, 0);
          }
          function g(n, r) {
            const s = c.newAttributes,
              a = c.enabledAttributes,
              o = c.attributeDivisors;
            (s[n] = 1),
              0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
              o[n] !== r &&
                ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                  i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
                ](n, r),
                (o[n] = r));
          }
          function _() {
            const e = c.newAttributes,
              n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
              n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
          }
          function v(e, n, i, r, s, a, o) {
            !0 === o
              ? t.vertexAttribIPointer(e, n, i, s, a)
              : t.vertexAttribPointer(e, n, i, r, s, a);
          }
          function x() {
            y(), (h = !0), c !== l && ((c = l), u(c.object));
          }
          function y() {
            (l.geometry = null), (l.program = null), (l.wireframe = !1);
          }
          return {
            setup: function (r, l, d, x, y) {
              let M = !1;
              if (a) {
                const e = (function (e, n, r) {
                  const a = !0 === r.wireframe;
                  let l = o[e.id];
                  void 0 === l && ((l = {}), (o[e.id] = l));
                  let c = l[n.id];
                  void 0 === c && ((c = {}), (l[n.id] = c));
                  let h = c[a];
                  return (
                    void 0 === h &&
                      ((h = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES())),
                      (c[a] = h)),
                    h
                  );
                })(x, d, l);
                c !== e && ((c = e), u(c.object)),
                  (M = (function (t, e, n, i) {
                    const r = c.attributes,
                      s = e.attributes;
                    let a = 0;
                    const o = n.getAttributes();
                    for (const e in o)
                      if (o[e].location >= 0) {
                        const n = r[e];
                        let i = s[e];
                        if (
                          (void 0 === i &&
                            ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix),
                            "instanceColor" === e && t.instanceColor && (i = t.instanceColor)),
                          void 0 === n)
                        )
                          return !0;
                        if (n.attribute !== i) return !0;
                        if (i && n.data !== i.data) return !0;
                        a++;
                      }
                    return c.attributesNum !== a || c.index !== i;
                  })(r, x, d, y)),
                  M &&
                    (function (t, e, n, i) {
                      const r = {},
                        s = e.attributes;
                      let a = 0;
                      const o = n.getAttributes();
                      for (const e in o)
                        if (o[e].location >= 0) {
                          let n = s[e];
                          void 0 === n &&
                            ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix),
                            "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                          const i = {};
                          (i.attribute = n), n && n.data && (i.data = n.data), (r[e] = i), a++;
                        }
                      (c.attributes = r), (c.attributesNum = a), (c.index = i);
                    })(r, x, d, y);
              } else {
                const t = !0 === l.wireframe;
                (c.geometry === x.id && c.program === d.id && c.wireframe === t) ||
                  ((c.geometry = x.id), (c.program = d.id), (c.wireframe = t), (M = !0));
              }
              null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER),
                (M || h) &&
                  ((h = !1),
                  (function (r, s, a, o) {
                    if (
                      !1 === i.isWebGL2 &&
                      (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                      null === e.get("ANGLE_instanced_arrays")
                    )
                      return;
                    f();
                    const l = o.attributes,
                      c = a.getAttributes(),
                      h = s.defaultAttributeValues;
                    for (const e in c) {
                      const s = c[e];
                      if (s.location >= 0) {
                        let a = l[e];
                        if (
                          (void 0 === a &&
                            ("instanceMatrix" === e && r.instanceMatrix && (a = r.instanceMatrix),
                            "instanceColor" === e && r.instanceColor && (a = r.instanceColor)),
                          void 0 !== a)
                        ) {
                          const e = a.normalized,
                            l = a.itemSize,
                            c = n.get(a);
                          if (void 0 === c) continue;
                          const h = c.buffer,
                            u = c.type,
                            d = c.bytesPerElement,
                            p =
                              !0 === i.isWebGL2 &&
                              (u === t.INT || u === t.UNSIGNED_INT || a.gpuType === F);
                          if (a.isInterleavedBufferAttribute) {
                            const n = a.data,
                              i = n.stride,
                              c = a.offset;
                            if (n.isInstancedInterleavedBuffer) {
                              for (let t = 0; t < s.locationSize; t++)
                                g(s.location + t, n.meshPerAttribute);
                              !0 !== r.isInstancedMesh &&
                                void 0 === o._maxInstanceCount &&
                                (o._maxInstanceCount = n.meshPerAttribute * n.count);
                            } else for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                            t.bindBuffer(t.ARRAY_BUFFER, h);
                            for (let t = 0; t < s.locationSize; t++)
                              v(
                                s.location + t,
                                l / s.locationSize,
                                u,
                                e,
                                i * d,
                                (c + (l / s.locationSize) * t) * d,
                                p
                              );
                          } else {
                            if (a.isInstancedBufferAttribute) {
                              for (let t = 0; t < s.locationSize; t++)
                                g(s.location + t, a.meshPerAttribute);
                              !0 !== r.isInstancedMesh &&
                                void 0 === o._maxInstanceCount &&
                                (o._maxInstanceCount = a.meshPerAttribute * a.count);
                            } else for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                            t.bindBuffer(t.ARRAY_BUFFER, h);
                            for (let t = 0; t < s.locationSize; t++)
                              v(
                                s.location + t,
                                l / s.locationSize,
                                u,
                                e,
                                l * d,
                                (l / s.locationSize) * t * d,
                                p
                              );
                          }
                        } else if (void 0 !== h) {
                          const n = h[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(s.location, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(s.location, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(s.location, n);
                                break;
                              default:
                                t.vertexAttrib1fv(s.location, n);
                            }
                        }
                      }
                    }
                    _();
                  })(r, l, d, x),
                  null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer));
            },
            reset: x,
            resetDefaultState: y,
            dispose: function () {
              x();
              for (const t in o) {
                const e = o[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) d(n[t].object), delete n[t];
                  delete e[t];
                }
                delete o[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === o[t.id]) return;
              const e = o[t.id];
              for (const t in e) {
                const n = e[t];
                for (const t in n) d(n[t].object), delete n[t];
                delete e[t];
              }
              delete o[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in o) {
                const n = o[e];
                if (void 0 === n[t.id]) continue;
                const i = n[t.id];
                for (const t in i) d(i[t].object), delete i[t];
                delete n[t.id];
              }
            },
            initAttributes: f,
            enableAttribute: m,
            disableUnusedAttributes: _,
          };
        }
        function Er(t, e, n, i) {
          const r = i.isWebGL2;
          let s;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.render = function (e, i) {
              t.drawArrays(s, e, i), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, a, o) {
              if (0 === o) return;
              let l, c;
              if (r) (l = t), (c = "drawArraysInstanced");
              else if (
                ((l = e.get("ANGLE_instanced_arrays")),
                (c = "drawArraysInstancedANGLE"),
                null === l)
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              l[c](s, i, a, o), n.update(a, s, o);
            }),
            (this.renderMultiDraw = function (t, i, r) {
              if (0 === r) return;
              const a = e.get("WEBGL_multi_draw");
              if (null === a) for (let e = 0; e < r; e++) this.render(t[e], i[e]);
              else {
                a.multiDrawArraysWEBGL(s, t, 0, i, 0, r);
                let e = 0;
                for (let t = 0; t < r; t++) e += i[t];
                n.update(e, s, 1);
              }
            });
        }
        function Tr(t, e, n) {
          let i;
          function r(e) {
            if ("highp" === e) {
              if (
                t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 &&
                t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0
              )
                return "highp";
              e = "mediump";
            }
            return "mediump" === e &&
              t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 &&
              t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0
              ? "mediump"
              : "lowp";
          }
          const s =
            "undefined" != typeof WebGL2RenderingContext &&
            "WebGL2RenderingContext" === t.constructor.name;
          let a = void 0 !== n.precision ? n.precision : "highp";
          const o = r(a);
          o !== a &&
            (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            (a = o));
          const l = s || e.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            d = t.getParameter(t.MAX_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            g = t.getParameter(t.MAX_VARYING_VECTORS),
            _ = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            v = u > 0,
            x = s || e.has("OES_texture_float");
          return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function () {
              if (void 0 !== i) return i;
              if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else i = 0;
              return i;
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: _,
            vertexTextures: v,
            floatFragmentTextures: x,
            floatVertexTextures: v && x,
            maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
          };
        }
        function Ar(t) {
          const e = this;
          let n = null,
            i = 0,
            r = !1,
            s = !1;
          const a = new ur(),
            o = new pe(),
            l = { value: null, needsUpdate: !1 };
          function c(t, n, i, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
              if (((c = l.value), !0 !== r || null === c)) {
                const e = i + 4 * s,
                  r = n.matrixWorldInverse;
                o.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                for (let e = 0, n = i; e !== s; ++e, n += 4)
                  a.copy(t[e]).applyMatrix4(r, o), a.normal.toArray(c, n), (c[n + 3] = a.constant);
              }
              (l.value = c), (l.needsUpdate = !0);
            }
            return (e.numPlanes = s), (e.numIntersection = 0), c;
          }
          (this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e) {
              const n = 0 !== t.length || e || 0 !== i || r;
              return (r = e), (i = t.length), n;
            }),
            (this.beginShadows = function () {
              (s = !0), c(null);
            }),
            (this.endShadows = function () {
              s = !1;
            }),
            (this.setGlobalState = function (t, e) {
              n = c(t, e, 0);
            }),
            (this.setState = function (a, o, h) {
              const u = a.clippingPlanes,
                d = a.clipIntersection,
                p = a.clipShadows,
                f = t.get(a);
              if (!r || null === u || 0 === u.length || (s && !p))
                s
                  ? c(null)
                  : (l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
                    (e.numPlanes = i),
                    (e.numIntersection = 0));
              else {
                const t = s ? 0 : i,
                  e = 4 * t;
                let r = f.clippingState || null;
                (l.value = r), (r = c(u, o, e, h));
                for (let t = 0; t !== e; ++t) r[t] = n[t];
                (f.clippingState = r),
                  (this.numIntersection = d ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function wr(t) {
          let e = new WeakMap();
          function n(t, e) {
            return e === E ? (t.mapping = S) : e === T && (t.mapping = b), t;
          }
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping;
                if (s === E || s === T) {
                  if (e.has(r)) return n(e.get(r).texture, r.mapping);
                  {
                    const s = r.image;
                    if (s && s.height > 0) {
                      const a = new or(s.height / 2);
                      return (
                        a.fromEquirectangularTexture(t, r),
                        e.set(r, a),
                        r.addEventListener("dispose", i),
                        n(a.texture, r.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        class Rr extends nr {
          constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
            super(),
              (this.isOrthographicCamera = !0),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = i),
              (this.near = r),
              (this.far = s),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, i, r, s) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2;
            let r = n - t,
              s = n + t,
              a = i + e,
              o = i - e;
            if (null !== this.view && this.view.enabled) {
              const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (r += t * this.view.offsetX),
                (s = r + t * this.view.width),
                (a -= e * this.view.offsetY),
                (o = a - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              r,
              s,
              a,
              o,
              this.near,
              this.far,
              this.coordinateSystem
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view && (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        const Cr = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          Lr = new Rr(),
          Pr = new oi();
        let Ir = null,
          Ur = 0,
          Nr = 0;
        const Dr = (1 + Math.sqrt(5)) / 2,
          Or = 1 / Dr,
          Br = [
            new ke(1, 1, 1),
            new ke(-1, 1, 1),
            new ke(1, 1, -1),
            new ke(-1, 1, -1),
            new ke(0, Dr, Or),
            new ke(0, Dr, -Or),
            new ke(Or, 0, Dr),
            new ke(-Or, 0, Dr),
            new ke(Dr, Or, 0),
            new ke(-Dr, Or, 0),
          ];
        class Fr {
          constructor(t) {
            (this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._lodMax = 0),
              (this._cubeSize = 0),
              (this._lodPlanes = []),
              (this._sizeLods = []),
              (this._sigmas = []),
              (this._blurMaterial = null),
              (this._cubemapMaterial = null),
              (this._equirectMaterial = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(t, e = 0, n = 0.1, i = 100) {
            (Ir = this._renderer.getRenderTarget()),
              (Ur = this._renderer.getActiveCubeFace()),
              (Nr = this._renderer.getActiveMipmapLevel()),
              this._setSize(256);
            const r = this._allocateTargets();
            return (
              (r.depthBuffer = !0),
              this._sceneToCubeUV(t, n, i, r),
              e > 0 && this._blur(r, 0, 0, e),
              this._applyPMREM(r),
              this._cleanup(r),
              r
            );
          }
          fromEquirectangular(t, e = null) {
            return this._fromTexture(t, e);
          }
          fromCubemap(t, e = null) {
            return this._fromTexture(t, e);
          }
          compileCubemapShader() {
            null === this._cubemapMaterial &&
              ((this._cubemapMaterial = kr()), this._compileMaterial(this._cubemapMaterial));
          }
          compileEquirectangularShader() {
            null === this._equirectMaterial &&
              ((this._equirectMaterial = Gr()), this._compileMaterial(this._equirectMaterial));
          }
          dispose() {
            this._dispose(),
              null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
              null !== this._equirectMaterial && this._equirectMaterial.dispose();
          }
          _setSize(t) {
            (this._lodMax = Math.floor(Math.log2(t))), (this._cubeSize = Math.pow(2, this._lodMax));
          }
          _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
              null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
            for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
          }
          _cleanup(t) {
            this._renderer.setRenderTarget(Ir, Ur, Nr),
              (t.scissorTest = !1),
              Hr(t, 0, 0, t.width, t.height);
          }
          _fromTexture(t, e) {
            t.mapping === S || t.mapping === b
              ? this._setSize(
                  0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width
                )
              : this._setSize(t.image.width / 4),
              (Ir = this._renderer.getRenderTarget()),
              (Ur = this._renderer.getActiveCubeFace()),
              (Nr = this._renderer.getActiveMipmapLevel());
            const n = e || this._allocateTargets();
            return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
          }
          _allocateTargets() {
            const t = 3 * Math.max(this._cubeSize, 112),
              e = 4 * this._cubeSize,
              n = {
                magFilter: U,
                minFilter: U,
                generateMipmaps: !1,
                type: G,
                format: X,
                colorSpace: zt,
                depthBuffer: !1,
              },
              i = zr(t, e, n);
            if (
              null === this._pingPongRenderTarget ||
              this._pingPongRenderTarget.width !== t ||
              this._pingPongRenderTarget.height !== e
            ) {
              null !== this._pingPongRenderTarget && this._dispose(),
                (this._pingPongRenderTarget = zr(t, e, n));
              const { _lodMax: i } = this;
              ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
              } = (function (t) {
                const e = [],
                  n = [],
                  i = [];
                let r = t;
                const s = t - 4 + 1 + Cr.length;
                for (let a = 0; a < s; a++) {
                  const s = Math.pow(2, r);
                  n.push(s);
                  let o = 1 / s;
                  a > t - 4 ? (o = Cr[a - t + 4 - 1]) : 0 === a && (o = 0), i.push(o);
                  const l = 1 / (s - 2),
                    c = -l,
                    h = 1 + l,
                    u = [c, c, h, c, h, h, c, c, h, h, c, h],
                    d = 6,
                    p = 6,
                    f = 3,
                    m = 2,
                    g = 1,
                    _ = new Float32Array(f * p * d),
                    v = new Float32Array(m * p * d),
                    x = new Float32Array(g * p * d);
                  for (let t = 0; t < d; t++) {
                    const e = ((t % 3) * 2) / 3 - 1,
                      n = t > 2 ? 0 : -1,
                      i = [
                        e,
                        n,
                        0,
                        e + 2 / 3,
                        n,
                        0,
                        e + 2 / 3,
                        n + 1,
                        0,
                        e,
                        n,
                        0,
                        e + 2 / 3,
                        n + 1,
                        0,
                        e,
                        n + 1,
                        0,
                      ];
                    _.set(i, f * p * t), v.set(u, m * p * t);
                    const r = [t, t, t, t, t, t];
                    x.set(r, g * p * t);
                  }
                  const y = new Li();
                  y.setAttribute("position", new xi(_, f)),
                    y.setAttribute("uv", new xi(v, m)),
                    y.setAttribute("faceIndex", new xi(x, g)),
                    e.push(y),
                    r > 4 && r--;
                }
                return { lodPlanes: e, sizeLods: n, sigmas: i };
              })(i)),
                (this._blurMaterial = (function (t, e, n) {
                  const i = new Float32Array(20),
                    r = new ke(0, 1, 0);
                  return new er({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: 20,
                      CUBEUV_TEXEL_WIDTH: 1 / e,
                      CUBEUV_TEXEL_HEIGHT: 1 / n,
                      CUBEUV_MAX_MIP: `${t}.0`,
                    },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: i },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: r },
                    },
                    vertexShader:
                      "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader:
                      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                })(i, t, e));
            }
            return i;
          }
          _compileMaterial(t) {
            const e = new Yi(this._lodPlanes[0], t);
            this._renderer.compile(e, Lr);
          }
          _sceneToCubeUV(t, e, n, i) {
            const r = new ir(90, 1, e, n),
              s = [1, -1, 1, 1, 1, 1],
              a = [1, 1, 1, -1, -1, -1],
              o = this._renderer,
              l = o.autoClear,
              c = o.toneMapping;
            o.getClearColor(Pr), (o.toneMapping = d), (o.autoClear = !1);
            const h = new ui({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }),
              u = new Yi(new Zi(), h);
            let p = !1;
            const f = t.background;
            f
              ? f.isColor && (h.color.copy(f), (t.background = null), (p = !0))
              : (h.color.copy(Pr), (p = !0));
            for (let e = 0; e < 6; e++) {
              const n = e % 3;
              0 === n
                ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
                : 1 === n
                ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
                : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e]));
              const l = this._cubeSize;
              Hr(i, n * l, e > 2 ? l : 0, l, l),
                o.setRenderTarget(i),
                p && o.render(u, r),
                o.render(t, r);
            }
            u.geometry.dispose(),
              u.material.dispose(),
              (o.toneMapping = c),
              (o.autoClear = l),
              (t.background = f);
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer,
              i = t.mapping === S || t.mapping === b;
            i
              ? (null === this._cubemapMaterial && (this._cubemapMaterial = kr()),
                (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  !1 === t.isRenderTargetTexture ? -1 : 1))
              : null === this._equirectMaterial && (this._equirectMaterial = Gr());
            const r = i ? this._cubemapMaterial : this._equirectMaterial,
              s = new Yi(this._lodPlanes[0], r);
            r.uniforms.envMap.value = t;
            const a = this._cubeSize;
            Hr(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, Lr);
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < this._lodPlanes.length; e++) {
              const n = Math.sqrt(
                  this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]
                ),
                i = Br[(e - 1) % Br.length];
              this._blur(t, e - 1, e, n, i);
            }
            e.autoClear = n;
          }
          _blur(t, e, n, i, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(t, s, e, n, i, "latitudinal", r),
              this._halfBlur(s, t, n, n, i, "longitudinal", r);
          }
          _halfBlur(t, e, n, i, r, s, a) {
            const o = this._renderer,
              l = this._blurMaterial;
            "latitudinal" !== s &&
              "longitudinal" !== s &&
              console.error("blur direction must be either latitudinal or longitudinal!");
            const c = new Yi(this._lodPlanes[i], l),
              h = l.uniforms,
              u = this._sizeLods[n] - 1,
              d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
              p = r / d,
              f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 &&
              console.warn(
                `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
              );
            const m = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
              const e = t / p,
                n = Math.exp((-e * e) / 2);
              m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
            }
            for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
            (h.envMap.value = t.texture),
              (h.samples.value = f),
              (h.weights.value = m),
              (h.latitudinal.value = "latitudinal" === s),
              a && (h.poleAxis.value = a);
            const { _lodMax: _ } = this;
            (h.dTheta.value = d), (h.mipInt.value = _ - n);
            const v = this._sizeLods[i];
            Hr(e, 3 * v * (i > _ - 4 ? i - _ + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v),
              o.setRenderTarget(e),
              o.render(c, Lr);
          }
        }
        function zr(t, e, n) {
          const i = new Fe(t, e, n);
          return (
            (i.texture.mapping = A), (i.texture.name = "PMREM.cubeUv"), (i.scissorTest = !0), i
          );
        }
        function Hr(t, e, n, i, r) {
          t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
        }
        function Gr() {
          return new er({
            name: "EquirectangularToCubeUV",
            uniforms: { envMap: { value: null } },
            vertexShader:
              "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function kr() {
          return new er({
            name: "CubemapToCubeUV",
            uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
            vertexShader:
              "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function Vr(t) {
          let e = new WeakMap(),
            n = null;
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping,
                  a = s === E || s === T,
                  o = s === S || s === b;
                if (a || o) {
                  if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                    r.needsPMREMUpdate = !1;
                    let i = e.get(r);
                    return (
                      null === n && (n = new Fr(t)),
                      (i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                      e.set(r, i),
                      i.texture
                    );
                  }
                  if (e.has(r)) return e.get(r).texture;
                  {
                    const s = r.image;
                    if (
                      (a && s && s.height > 0) ||
                      (o &&
                        s &&
                        (function (t) {
                          let e = 0;
                          for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                          return 6 === e;
                        })(s))
                    ) {
                      null === n && (n = new Fr(t));
                      const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                      return e.set(r, s), r.addEventListener("dispose", i), s.texture;
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
            },
          };
        }
        function Wr(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let i;
            switch (n) {
              case "WEBGL_depth_texture":
                i =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                i =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                i =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                i =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                i = t.getExtension(n);
            }
            return (e[n] = i), i;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"))
                : (n("WEBGL_depth_texture"),
                  n("OES_texture_float"),
                  n("OES_texture_half_float"),
                  n("OES_texture_half_float_linear"),
                  n("OES_standard_derivatives"),
                  n("OES_element_index_uint"),
                  n("OES_vertex_array_object"),
                  n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float"),
                n("WEBGL_multisampled_render_to_texture");
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                  console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                e
              );
            },
          };
        }
        function Xr(t, e, n, i) {
          const r = {},
            s = new WeakMap();
          function a(t) {
            const o = t.target;
            null !== o.index && e.remove(o.index);
            for (const t in o.attributes) e.remove(o.attributes[t]);
            for (const t in o.morphAttributes) {
              const n = o.morphAttributes[t];
              for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
            }
            o.removeEventListener("dispose", a), delete r[o.id];
            const l = s.get(o);
            l && (e.remove(l), s.delete(o)),
              i.releaseStatesOfGeometry(o),
              !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
              n.memory.geometries--;
          }
          function o(t) {
            const n = [],
              i = t.index,
              r = t.attributes.position;
            let a = 0;
            if (null !== i) {
              const t = i.array;
              a = i.version;
              for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                  r = t[e + 1],
                  s = t[e + 2];
                n.push(i, r, r, s, s, i);
              }
            } else {
              if (void 0 === r) return;
              {
                const t = r.array;
                a = r.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                  const t = e + 0,
                    i = e + 1,
                    r = e + 2;
                  n.push(t, i, i, r, r, t);
                }
              }
            }
            const o = new (me(n) ? Mi : yi)(n, 1);
            o.version = a;
            const l = s.get(t);
            l && e.remove(l), s.set(t, o);
          }
          return {
            get: function (t, e) {
              return (
                !0 === r[e.id] ||
                  (e.addEventListener("dispose", a), (r[e.id] = !0), n.memory.geometries++),
                e
              );
            },
            update: function (n) {
              const i = n.attributes;
              for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
              const r = n.morphAttributes;
              for (const n in r) {
                const i = r[n];
                for (let n = 0, r = i.length; n < r; n++) e.update(i[n], t.ARRAY_BUFFER);
              }
            },
            getWireframeAttribute: function (t) {
              const e = s.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && o(t);
              } else o(t);
              return s.get(t);
            },
          };
        }
        function jr(t, e, n, i) {
          const r = i.isWebGL2;
          let s, a, o;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.setIndex = function (t) {
              (a = t.type), (o = t.bytesPerElement);
            }),
            (this.render = function (e, i) {
              t.drawElements(s, i, a, e * o), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, l, c) {
              if (0 === c) return;
              let h, u;
              if (r) (h = t), (u = "drawElementsInstanced");
              else if (
                ((h = e.get("ANGLE_instanced_arrays")),
                (u = "drawElementsInstancedANGLE"),
                null === h)
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              h[u](s, l, a, i * o, c), n.update(l, s, c);
            }),
            (this.renderMultiDraw = function (t, i, r) {
              if (0 === r) return;
              const l = e.get("WEBGL_multi_draw");
              if (null === l) for (let e = 0; e < r; e++) this.render(t[e] / o, i[e]);
              else {
                l.multiDrawElementsWEBGL(s, i, 0, a, t, 0, r);
                let e = 0;
                for (let t = 0; t < r; t++) e += i[t];
                n.update(e, s, 1);
              }
            });
        }
        function qr(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
            },
            update: function (n, i, r) {
              switch ((e.calls++, i)) {
                case t.TRIANGLES:
                  e.triangles += r * (n / 3);
                  break;
                case t.LINES:
                  e.lines += r * (n / 2);
                  break;
                case t.LINE_STRIP:
                  e.lines += r * (n - 1);
                  break;
                case t.LINE_LOOP:
                  e.lines += r * n;
                  break;
                case t.POINTS:
                  e.points += r * n;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", i);
              }
            },
          };
        }
        function Yr(t, e) {
          return t[0] - e[0];
        }
        function Kr(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function Zr(t, e, n) {
          const i = {},
            r = new Float32Array(8),
            s = new WeakMap(),
            a = new Oe(),
            o = [];
          for (let t = 0; t < 8; t++) o[t] = [t, 0];
          return {
            update: function (l, c, h) {
              const u = l.morphTargetInfluences;
              if (!0 === e.isWebGL2) {
                const d =
                    c.morphAttributes.position ||
                    c.morphAttributes.normal ||
                    c.morphAttributes.color,
                  p = void 0 !== d ? d.length : 0;
                let f = s.get(c);
                if (void 0 === f || f.count !== p) {
                  void 0 !== f && f.texture.dispose();
                  const _ = void 0 !== c.morphAttributes.position,
                    v = void 0 !== c.morphAttributes.normal,
                    x = void 0 !== c.morphAttributes.color,
                    y = c.morphAttributes.position || [],
                    M = c.morphAttributes.normal || [],
                    S = c.morphAttributes.color || [];
                  let b = 0;
                  !0 === _ && (b = 1), !0 === v && (b = 2), !0 === x && (b = 3);
                  let E = c.attributes.position.count * b,
                    T = 1;
                  E > e.maxTextureSize &&
                    ((T = Math.ceil(E / e.maxTextureSize)), (E = e.maxTextureSize));
                  const A = new Float32Array(E * T * 4 * p),
                    w = new ze(A, E, T, p);
                  (w.type = H), (w.needsUpdate = !0);
                  const R = 4 * b;
                  for (let L = 0; L < p; L++) {
                    const P = y[L],
                      I = M[L],
                      U = S[L],
                      N = E * T * 4 * L;
                    for (let D = 0; D < P.count; D++) {
                      const O = D * R;
                      !0 === _ &&
                        (a.fromBufferAttribute(P, D),
                        (A[N + O + 0] = a.x),
                        (A[N + O + 1] = a.y),
                        (A[N + O + 2] = a.z),
                        (A[N + O + 3] = 0)),
                        !0 === v &&
                          (a.fromBufferAttribute(I, D),
                          (A[N + O + 4] = a.x),
                          (A[N + O + 5] = a.y),
                          (A[N + O + 6] = a.z),
                          (A[N + O + 7] = 0)),
                        !0 === x &&
                          (a.fromBufferAttribute(U, D),
                          (A[N + O + 8] = a.x),
                          (A[N + O + 9] = a.y),
                          (A[N + O + 10] = a.z),
                          (A[N + O + 11] = 4 === U.itemSize ? a.w : 1));
                    }
                  }
                  function C() {
                    w.dispose(), s.delete(c), c.removeEventListener("dispose", C);
                  }
                  (f = { count: p, texture: w, size: new de(E, T) }),
                    s.set(c, f),
                    c.addEventListener("dispose", C);
                }
                let m = 0;
                for (let B = 0; B < u.length; B++) m += u[B];
                const g = c.morphTargetsRelative ? 1 : 1 - m;
                h.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
                  h.getUniforms().setValue(t, "morphTargetInfluences", u),
                  h.getUniforms().setValue(t, "morphTargetsTexture", f.texture, n),
                  h.getUniforms().setValue(t, "morphTargetsTextureSize", f.size);
              } else {
                const F = void 0 === u ? 0 : u.length;
                let z = i[c.id];
                if (void 0 === z || z.length !== F) {
                  z = [];
                  for (let X = 0; X < F; X++) z[X] = [X, 0];
                  i[c.id] = z;
                }
                for (let j = 0; j < F; j++) {
                  const q = z[j];
                  (q[0] = j), (q[1] = u[j]);
                }
                z.sort(Kr);
                for (let Y = 0; Y < 8; Y++)
                  Y < F && z[Y][1]
                    ? ((o[Y][0] = z[Y][0]), (o[Y][1] = z[Y][1]))
                    : ((o[Y][0] = Number.MAX_SAFE_INTEGER), (o[Y][1] = 0));
                o.sort(Yr);
                const G = c.morphAttributes.position,
                  k = c.morphAttributes.normal;
                let V = 0;
                for (let K = 0; K < 8; K++) {
                  const Z = o[K],
                    J = Z[0],
                    Q = Z[1];
                  J !== Number.MAX_SAFE_INTEGER && Q
                    ? (G &&
                        c.getAttribute("morphTarget" + K) !== G[J] &&
                        c.setAttribute("morphTarget" + K, G[J]),
                      k &&
                        c.getAttribute("morphNormal" + K) !== k[J] &&
                        c.setAttribute("morphNormal" + K, k[J]),
                      (r[K] = Q),
                      (V += Q))
                    : (G &&
                        !0 === c.hasAttribute("morphTarget" + K) &&
                        c.deleteAttribute("morphTarget" + K),
                      k &&
                        !0 === c.hasAttribute("morphNormal" + K) &&
                        c.deleteAttribute("morphNormal" + K),
                      (r[K] = 0));
                }
                const W = c.morphTargetsRelative ? 1 : 1 - V;
                h.getUniforms().setValue(t, "morphTargetBaseInfluence", W),
                  h.getUniforms().setValue(t, "morphTargetInfluences", r);
              }
            },
          };
        }
        function Jr(t, e, n, i) {
          let r = new WeakMap();
          function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (a) {
              const o = i.render.frame,
                l = a.geometry,
                c = e.get(a, l);
              if (
                (r.get(c) !== o && (e.update(c), r.set(c, o)),
                a.isInstancedMesh &&
                  (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s),
                  r.get(a) !== o &&
                    (n.update(a.instanceMatrix, t.ARRAY_BUFFER),
                    null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER),
                    r.set(a, o))),
                a.isSkinnedMesh)
              ) {
                const t = a.skeleton;
                r.get(t) !== o && (t.update(), r.set(t, o));
              }
              return c;
            },
            dispose: function () {
              r = new WeakMap();
            },
          };
        }
        class Qr extends De {
          constructor(t, e, n, i, r, s, a, o, l, c) {
            if ((c = void 0 !== c ? c : j) !== j && c !== q)
              throw new Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            void 0 === n && c === j && (n = z),
              void 0 === n && c === q && (n = W),
              super(null, i, r, s, a, o, c, n, l),
              (this.isDepthTexture = !0),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== a ? a : L),
              (this.minFilter = void 0 !== o ? o : L),
              (this.flipY = !1),
              (this.generateMipmaps = !1),
              (this.compareFunction = null);
          }
          copy(t) {
            return super.copy(t), (this.compareFunction = t.compareFunction), this;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e;
          }
        }
        const $r = new De(),
          ts = new Qr(1, 1);
        ts.compareFunction = 515;
        const es = new ze(),
          ns = new He(),
          is = new ar(),
          rs = [],
          ss = [],
          as = new Float32Array(16),
          os = new Float32Array(9),
          ls = new Float32Array(4);
        function cs(t, e, n) {
          const i = t[0];
          if (i <= 0 || i > 0) return t;
          const r = e * n;
          let s = rs[r];
          if ((void 0 === s && ((s = new Float32Array(r)), (rs[r] = s)), 0 !== e)) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
          }
          return s;
        }
        function hs(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
          return !0;
        }
        function us(t, e) {
          for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
        }
        function ds(t, e) {
          let n = ss[e];
          void 0 === n && ((n = new Int32Array(e)), (ss[e] = n));
          for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
          return n;
        }
        function ps(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function fs(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (hs(n, e)) return;
            t.uniform2fv(this.addr, e), us(n, e);
          }
        }
        function ms(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b), (n[0] = e.r), (n[1] = e.g), (n[2] = e.b));
          else {
            if (hs(n, e)) return;
            t.uniform3fv(this.addr, e), us(n, e);
          }
        }
        function gs(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (hs(n, e)) return;
            t.uniform4fv(this.addr, e), us(n, e);
          }
        }
        function _s(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (hs(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), us(n, e);
          } else {
            if (hs(n, i)) return;
            ls.set(i), t.uniformMatrix2fv(this.addr, !1, ls), us(n, i);
          }
        }
        function vs(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (hs(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), us(n, e);
          } else {
            if (hs(n, i)) return;
            os.set(i), t.uniformMatrix3fv(this.addr, !1, os), us(n, i);
          }
        }
        function xs(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (hs(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), us(n, e);
          } else {
            if (hs(n, i)) return;
            as.set(i), t.uniformMatrix4fv(this.addr, !1, as), us(n, i);
          }
        }
        function ys(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function Ms(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (hs(n, e)) return;
            t.uniform2iv(this.addr, e), us(n, e);
          }
        }
        function Ss(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3i(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
          else {
            if (hs(n, e)) return;
            t.uniform3iv(this.addr, e), us(n, e);
          }
        }
        function bs(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (hs(n, e)) return;
            t.uniform4iv(this.addr, e), us(n, e);
          }
        }
        function Es(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function Ts(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (hs(n, e)) return;
            t.uniform2uiv(this.addr, e), us(n, e);
          }
        }
        function As(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3ui(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
          else {
            if (hs(n, e)) return;
            t.uniform3uiv(this.addr, e), us(n, e);
          }
        }
        function ws(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (hs(n, e)) return;
            t.uniform4uiv(this.addr, e), us(n, e);
          }
        }
        function Rs(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r));
          const s = this.type === t.SAMPLER_2D_SHADOW ? ts : $r;
          n.setTexture2D(e || s, r);
        }
        function Cs(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture3D(e || ns, r);
        }
        function Ls(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTextureCube(e || is, r);
        }
        function Ps(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture2DArray(e || es, r);
        }
        function Is(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function Us(t, e) {
          const n = cs(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function Ns(t, e) {
          const n = cs(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function Ds(t, e) {
          const n = cs(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function Os(t, e) {
          const n = cs(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function Bs(t, e) {
          const n = cs(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function Fs(t, e) {
          const n = cs(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function zs(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function Hs(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function Gs(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function ks(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function Vs(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function Ws(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function Xs(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function js(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function qs(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = ds(n, r);
          hs(i, s) || (t.uniform1iv(this.addr, s), us(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || $r, s[t]);
        }
        function Ys(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = ds(n, r);
          hs(i, s) || (t.uniform1iv(this.addr, s), us(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || ns, s[t]);
        }
        function Ks(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = ds(n, r);
          hs(i, s) || (t.uniform1iv(this.addr, s), us(i, s));
          for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || is, s[t]);
        }
        function Zs(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = ds(n, r);
          hs(i, s) || (t.uniform1iv(this.addr, s), us(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || es, s[t]);
        }
        class Js {
          constructor(t, e, n) {
            (this.id = t),
              (this.addr = n),
              (this.cache = []),
              (this.type = e.type),
              (this.setValue = (function (t) {
                switch (t) {
                  case 5126:
                    return ps;
                  case 35664:
                    return fs;
                  case 35665:
                    return ms;
                  case 35666:
                    return gs;
                  case 35674:
                    return _s;
                  case 35675:
                    return vs;
                  case 35676:
                    return xs;
                  case 5124:
                  case 35670:
                    return ys;
                  case 35667:
                  case 35671:
                    return Ms;
                  case 35668:
                  case 35672:
                    return Ss;
                  case 35669:
                  case 35673:
                    return bs;
                  case 5125:
                    return Es;
                  case 36294:
                    return Ts;
                  case 36295:
                    return As;
                  case 36296:
                    return ws;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return Rs;
                  case 35679:
                  case 36299:
                  case 36307:
                    return Cs;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return Ls;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Ps;
                }
              })(e.type));
          }
        }
        class Qs {
          constructor(t, e, n) {
            (this.id = t),
              (this.addr = n),
              (this.cache = []),
              (this.type = e.type),
              (this.size = e.size),
              (this.setValue = (function (t) {
                switch (t) {
                  case 5126:
                    return Is;
                  case 35664:
                    return Us;
                  case 35665:
                    return Ns;
                  case 35666:
                    return Ds;
                  case 35674:
                    return Os;
                  case 35675:
                    return Bs;
                  case 35676:
                    return Fs;
                  case 5124:
                  case 35670:
                    return zs;
                  case 35667:
                  case 35671:
                    return Hs;
                  case 35668:
                  case 35672:
                    return Gs;
                  case 35669:
                  case 35673:
                    return ks;
                  case 5125:
                    return Vs;
                  case 36294:
                    return Ws;
                  case 36295:
                    return Xs;
                  case 36296:
                    return js;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return qs;
                  case 35679:
                  case 36299:
                  case 36307:
                    return Ys;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return Ks;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Zs;
                }
              })(e.type));
          }
        }
        class $s {
          constructor(t) {
            (this.id = t), (this.seq = []), (this.map = {});
          }
          setValue(t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
              const s = i[r];
              s.setValue(t, e[s.id], n);
            }
          }
        }
        const ta = /(\w+)(\])?(\[|\.)?/g;
        function ea(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function na(t, e, n) {
          const i = t.name,
            r = i.length;
          for (ta.lastIndex = 0; ; ) {
            const s = ta.exec(i),
              a = ta.lastIndex;
            let o = s[1];
            const l = "]" === s[2],
              c = s[3];
            if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
              ea(n, void 0 === c ? new Js(o, t, e) : new Qs(o, t, e));
              break;
            }
            {
              let t = n.map[o];
              void 0 === t && ((t = new $s(o)), ea(n, t)), (n = t);
            }
          }
        }
        class ia {
          constructor(t, e) {
            (this.seq = []), (this.map = {});
            const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
              const n = t.getActiveUniform(e, i);
              na(n, t.getUniformLocation(e, n.name), this);
            }
          }
          setValue(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i);
          }
          setOptional(t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i);
          }
          static upload(t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
              const s = e[r],
                a = n[s.id];
              !1 !== a.needsUpdate && s.setValue(t, a.value, i);
            }
          }
          static seqWithValue(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
              const r = t[i];
              r.id in e && n.push(r);
            }
            return n;
          }
        }
        function ra(t, e, n) {
          const i = t.createShader(e);
          return t.shaderSource(i, n), t.compileShader(i), i;
        }
        const sa = 37297;
        let aa = 0;
        function oa(t, e, n) {
          const i = t.getShaderParameter(e, t.COMPILE_STATUS),
            r = t.getShaderInfoLog(e).trim();
          if (i && "" === r) return "";
          const s = /ERROR: 0:(\d+)/.exec(r);
          if (s) {
            const i = parseInt(s[1]);
            return (
              n.toUpperCase() +
              "\n\n" +
              r +
              "\n\n" +
              (function (t, e) {
                const n = t.split("\n"),
                  i = [],
                  r = Math.max(e - 6, 0),
                  s = Math.min(e + 6, n.length);
                for (let t = r; t < s; t++) {
                  const r = t + 1;
                  i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
                }
                return i.join("\n");
              })(t.getShaderSource(e), i)
            );
          }
          return r;
        }
        function la(t, e) {
          const n = (function (t) {
            const e = Ae.getPrimaries(Ae.workingColorSpace),
              n = Ae.getPrimaries(t);
            let i;
            switch (
              (e === n
                ? (i = "")
                : e === Xt && n === Wt
                ? (i = "LinearDisplayP3ToLinearSRGB")
                : e === Wt && n === Xt && (i = "LinearSRGBToLinearDisplayP3"),
              t)
            ) {
              case zt:
              case Gt:
                return [i, "LinearTransferOETF"];
              case Ft:
              case Ht:
                return [i, "sRGBTransferOETF"];
              default:
                return (
                  console.warn("THREE.WebGLProgram: Unsupported color space:", t),
                  [i, "LinearTransferOETF"]
                );
            }
          })(e);
          return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
        }
        function ca(t, e) {
          let n;
          switch (e) {
            case p:
              n = "Linear";
              break;
            case f:
              n = "Reinhard";
              break;
            case m:
              n = "OptimizedCineon";
              break;
            case g:
              n = "ACESFilmic";
              break;
            case v:
              n = "AgX";
              break;
            case _:
              n = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), (n = "Linear");
          }
          return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
        }
        function ha(t) {
          return "" !== t;
        }
        function ua(t, e) {
          const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
            .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function da(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
        }
        const pa = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function fa(t) {
          return t.replace(pa, ga);
        }
        const ma = new Map([
          ["encodings_fragment", "colorspace_fragment"],
          ["encodings_pars_fragment", "colorspace_pars_fragment"],
          ["output_fragment", "opaque_fragment"],
        ]);
        function ga(t, e) {
          let n = vr[e];
          if (void 0 === n) {
            const t = ma.get(e);
            if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
            (n = vr[t]),
              console.warn(
                'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
                e,
                t
              );
          }
          return fa(n);
        }
        const _a =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function va(t) {
          return t.replace(_a, xa);
        }
        function xa(t, e, n, i) {
          let r = "";
          for (let t = parseInt(e); t < parseInt(n); t++)
            r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
          return r;
        }
        function ya(t) {
          let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
          return (
            "highp" === t.precision
              ? (e += "\n#define HIGH_PRECISION")
              : "mediump" === t.precision
              ? (e += "\n#define MEDIUM_PRECISION")
              : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
          );
        }
        function Ma(t, e, n, a) {
          const o = t.getContext(),
            l = n.defines;
          let p = n.vertexShader,
            f = n.fragmentShader;
          const m = (function (t) {
              let e = "SHADOWMAP_TYPE_BASIC";
              return (
                t.shadowMapType === i
                  ? (e = "SHADOWMAP_TYPE_PCF")
                  : t.shadowMapType === r
                  ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                  : t.shadowMapType === s && (e = "SHADOWMAP_TYPE_VSM"),
                e
              );
            })(n),
            g = (function (t) {
              let e = "ENVMAP_TYPE_CUBE";
              if (t.envMap)
                switch (t.envMapMode) {
                  case S:
                  case b:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                  case A:
                    e = "ENVMAP_TYPE_CUBE_UV";
                }
              return e;
            })(n),
            _ = (function (t) {
              let e = "ENVMAP_MODE_REFLECTION";
              return t.envMap && t.envMapMode === b && (e = "ENVMAP_MODE_REFRACTION"), e;
            })(n),
            v = (function (t) {
              let e = "ENVMAP_BLENDING_NONE";
              if (t.envMap)
                switch (t.combine) {
                  case c:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                  case h:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                  case u:
                    e = "ENVMAP_BLENDING_ADD";
                }
              return e;
            })(n),
            x = (function (t) {
              const e = t.envMapCubeUVHeight;
              if (null === e) return null;
              const n = Math.log2(e) - 2,
                i = 1 / e;
              return {
                texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                texelHeight: i,
                maxMip: n,
              };
            })(n),
            y = n.isWebGL2
              ? ""
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUVHeight ||
                    t.bumpMap ||
                    t.normalMapTangentSpace ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    "physical" === t.shaderID
                      ? "#extension GL_OES_standard_derivatives : enable"
                      : "",
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? "#extension GL_EXT_frag_depth : enable"
                      : "",
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? "#extension GL_EXT_draw_buffers : require"
                      : "",
                    (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                    t.rendererExtensionShaderTextureLod
                      ? "#extension GL_EXT_shader_texture_lod : enable"
                      : "",
                  ]
                    .filter(ha)
                    .join("\n");
                })(n),
            M = (function (t) {
              return [
                t.extensionClipCullDistance
                  ? "#extension GL_ANGLE_clip_cull_distance : require"
                  : "",
              ]
                .filter(ha)
                .join("\n");
            })(n),
            E = (function (t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i);
              }
              return e.join("\n");
            })(l),
            T = o.createProgram();
          let w,
            R,
            C = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
          n.isRawShaderMaterial
            ? ((w = [
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                E,
              ]
                .filter(ha)
                .join("\n")),
              w.length > 0 && (w += "\n"),
              (R = [
                y,
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                E,
              ]
                .filter(ha)
                .join("\n")),
              R.length > 0 && (R += "\n"))
            : ((w = [
                ya(n),
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                E,
                n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
                n.batching ? "#define USE_BATCHING" : "",
                n.instancing ? "#define USE_INSTANCING" : "",
                n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + _ : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
                n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
                n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.anisotropy ? "#define USE_ANISOTROPY" : "",
                n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaHash ? "#define USE_ALPHAHASH" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                n.mapUv ? "#define MAP_UV " + n.mapUv : "",
                n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
                n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
                n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
                n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
                n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
                n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
                n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
                n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
                n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
                n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
                n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
                n.clearcoatNormalMapUv
                  ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
                  : "",
                n.clearcoatRoughnessMapUv
                  ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
                  : "",
                n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
                n.iridescenceThicknessMapUv
                  ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
                  : "",
                n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
                n.sheenRoughnessMapUv
                  ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
                  : "",
                n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
                n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
                n.specularIntensityMapUv
                  ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
                  : "",
                n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
                n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
                n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUv1s ? "#define USE_UV1" : "",
                n.vertexUv2s ? "#define USE_UV2" : "",
                n.vertexUv3s ? "#define USE_UV3" : "",
                n.pointsUvs ? "#define USE_POINTS_UV" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.skinning ? "#define USE_SKINNING" : "",
                n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "",
                n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
                n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                  : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                  : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + m : "",
                n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
                n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                "#ifdef USE_INSTANCING",
                "\tattribute mat4 instanceMatrix;",
                "#endif",
                "#ifdef USE_INSTANCING_COLOR",
                "\tattribute vec3 instanceColor;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_UV1",
                "\tattribute vec2 uv1;",
                "#endif",
                "#ifdef USE_UV2",
                "\tattribute vec2 uv2;",
                "#endif",
                "#ifdef USE_UV3",
                "\tattribute vec2 uv3;",
                "#endif",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#if defined( USE_COLOR_ALPHA )",
                "\tattribute vec4 color;",
                "#elif defined( USE_COLOR )",
                "\tattribute vec3 color;",
                "#endif",
                "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(ha)
                .join("\n")),
              (R = [
                y,
                ya(n),
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                E,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + g : "",
                n.envMap ? "#define " + _ : "",
                n.envMap ? "#define " + v : "",
                x ? "#define CUBEUV_TEXEL_WIDTH " + x.texelWidth : "",
                x ? "#define CUBEUV_TEXEL_HEIGHT " + x.texelHeight : "",
                x ? "#define CUBEUV_MAX_MIP " + x.maxMip + ".0" : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
                n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.anisotropy ? "#define USE_ANISOTROPY" : "",
                n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                n.clearcoat ? "#define USE_CLEARCOAT" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.iridescence ? "#define USE_IRIDESCENCE" : "",
                n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaTest ? "#define USE_ALPHATEST" : "",
                n.alphaHash ? "#define USE_ALPHAHASH" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
                n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUv1s ? "#define USE_UV1" : "",
                n.vertexUv2s ? "#define USE_UV2" : "",
                n.vertexUv3s ? "#define USE_UV3" : "",
                n.pointsUvs ? "#define USE_POINTS_UV" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + m : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
                n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                n.toneMapping !== d ? "#define TONE_MAPPING" : "",
                n.toneMapping !== d ? vr.tonemapping_pars_fragment : "",
                n.toneMapping !== d ? ca("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                n.opaque ? "#define OPAQUE" : "",
                vr.colorspace_pars_fragment,
                la("linearToOutputTexel", n.outputColorSpace),
                n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
                "\n",
              ]
                .filter(ha)
                .join("\n"))),
            (p = fa(p)),
            (p = ua(p, n)),
            (p = da(p, n)),
            (f = fa(f)),
            (f = ua(f, n)),
            (f = da(f, n)),
            (p = va(p)),
            (f = va(f)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((C = "#version 300 es\n"),
              (w =
                [
                  M,
                  "precision mediump sampler2DArray;",
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                w),
              (R =
                [
                  "precision mediump sampler2DArray;",
                  "#define varying in",
                  n.glslVersion === Yt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
                  n.glslVersion === Yt ? "" : "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                R));
          const L = C + w + p,
            P = C + R + f,
            I = ra(o, o.VERTEX_SHADER, L),
            U = ra(o, o.FRAGMENT_SHADER, P);
          function N(e) {
            if (t.debug.checkShaderErrors) {
              const n = o.getProgramInfoLog(T).trim(),
                i = o.getShaderInfoLog(I).trim(),
                r = o.getShaderInfoLog(U).trim();
              let s = !0,
                a = !0;
              if (!1 === o.getProgramParameter(T, o.LINK_STATUS))
                if (((s = !1), "function" == typeof t.debug.onShaderError))
                  t.debug.onShaderError(o, T, I, U);
                else {
                  const t = oa(o, I, "vertex"),
                    e = oa(o, U, "fragment");
                  console.error(
                    "THREE.WebGLProgram: Shader Error " +
                      o.getError() +
                      " - VALIDATE_STATUS " +
                      o.getProgramParameter(T, o.VALIDATE_STATUS) +
                      "\n\nProgram Info Log: " +
                      n +
                      "\n" +
                      t +
                      "\n" +
                      e
                  );
                }
              else
                "" !== n
                  ? console.warn("THREE.WebGLProgram: Program Info Log:", n)
                  : ("" !== i && "" !== r) || (a = !1);
              a &&
                (e.diagnostics = {
                  runnable: s,
                  programLog: n,
                  vertexShader: { log: i, prefix: w },
                  fragmentShader: { log: r, prefix: R },
                });
            }
            o.deleteShader(I),
              o.deleteShader(U),
              (D = new ia(o, T)),
              (O = (function (t, e) {
                const n = {},
                  i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                for (let r = 0; r < i; r++) {
                  const i = t.getActiveAttrib(e, r),
                    s = i.name;
                  let a = 1;
                  i.type === t.FLOAT_MAT2 && (a = 2),
                    i.type === t.FLOAT_MAT3 && (a = 3),
                    i.type === t.FLOAT_MAT4 && (a = 4),
                    (n[s] = { type: i.type, location: t.getAttribLocation(e, s), locationSize: a });
                }
                return n;
              })(o, T));
          }
          let D, O;
          o.attachShader(T, I),
            o.attachShader(T, U),
            void 0 !== n.index0AttributeName
              ? o.bindAttribLocation(T, 0, n.index0AttributeName)
              : !0 === n.morphTargets && o.bindAttribLocation(T, 0, "position"),
            o.linkProgram(T),
            (this.getUniforms = function () {
              return void 0 === D && N(this), D;
            }),
            (this.getAttributes = function () {
              return void 0 === O && N(this), O;
            });
          let B = !1 === n.rendererExtensionParallelShaderCompile;
          return (
            (this.isReady = function () {
              return !1 === B && (B = o.getProgramParameter(T, sa)), B;
            }),
            (this.destroy = function () {
              a.releaseStatesOfProgram(this), o.deleteProgram(T), (this.program = void 0);
            }),
            (this.type = n.shaderType),
            (this.name = n.shaderName),
            (this.id = aa++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = T),
            (this.vertexShader = I),
            (this.fragmentShader = U),
            this
          );
        }
        let Sa = 0;
        class ba {
          constructor() {
            (this.shaderCache = new Map()), (this.materialCache = new Map());
          }
          update(t) {
            const e = t.vertexShader,
              n = t.fragmentShader,
              i = this._getShaderStage(e),
              r = this._getShaderStage(n),
              s = this._getShaderCacheForMaterial(t);
            return (
              !1 === s.has(i) && (s.add(i), i.usedTimes++),
              !1 === s.has(r) && (s.add(r), r.usedTimes++),
              this
            );
          }
          remove(t) {
            const e = this.materialCache.get(t);
            for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
            return this.materialCache.delete(t), this;
          }
          getVertexShaderID(t) {
            return this._getShaderStage(t.vertexShader).id;
          }
          getFragmentShaderID(t) {
            return this._getShaderStage(t.fragmentShader).id;
          }
          dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
          }
          _getShaderCacheForMaterial(t) {
            const e = this.materialCache;
            let n = e.get(t);
            return void 0 === n && ((n = new Set()), e.set(t, n)), n;
          }
          _getShaderStage(t) {
            const e = this.shaderCache;
            let n = e.get(t);
            return void 0 === n && ((n = new Ea(t)), e.set(t, n)), n;
          }
        }
        class Ea {
          constructor(t) {
            (this.id = Sa++), (this.code = t), (this.usedTimes = 0);
          }
        }
        function Ta(t, e, n, i, r, s, a) {
          const o = new Ln(),
            l = new ba(),
            c = [],
            h = r.isWebGL2,
            u = r.logarithmicDepthBuffer,
            p = r.vertexTextures;
          let f = r.precision;
          const m = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          };
          function g(t) {
            return 0 === t ? "uv" : `uv${t}`;
          }
          return {
            getParameters: function (s, o, c, _, v) {
              const x = _.fog,
                y = v.geometry,
                M = s.isMeshStandardMaterial ? _.environment : null,
                S = (s.isMeshStandardMaterial ? n : e).get(s.envMap || M),
                b = S && S.mapping === A ? S.image.height : null,
                E = m[s.type];
              null !== s.precision &&
                ((f = r.getMaxPrecision(s.precision)),
                f !== s.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    s.precision,
                    "not supported, using",
                    f,
                    "instead."
                  ));
              const T =
                  y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                w = void 0 !== T ? T.length : 0;
              let R,
                C,
                L,
                P,
                I = 0;
              if (
                (void 0 !== y.morphAttributes.position && (I = 1),
                void 0 !== y.morphAttributes.normal && (I = 2),
                void 0 !== y.morphAttributes.color && (I = 3),
                E)
              ) {
                const t = yr[E];
                (R = t.vertexShader), (C = t.fragmentShader);
              } else
                (R = s.vertexShader),
                  (C = s.fragmentShader),
                  l.update(s),
                  (L = l.getVertexShaderID(s)),
                  (P = l.getFragmentShaderID(s));
              const U = t.getRenderTarget(),
                N = !0 === v.isInstancedMesh,
                D = !0 === v.isBatchedMesh,
                O = !!s.map,
                B = !!s.matcap,
                F = !!S,
                z = !!s.aoMap,
                H = !!s.lightMap,
                G = !!s.bumpMap,
                k = !!s.normalMap,
                V = !!s.displacementMap,
                W = !!s.emissiveMap,
                X = !!s.metalnessMap,
                j = !!s.roughnessMap,
                q = s.anisotropy > 0,
                Y = s.clearcoat > 0,
                K = s.iridescence > 0,
                Z = s.sheen > 0,
                J = s.transmission > 0,
                Q = q && !!s.anisotropyMap,
                $ = Y && !!s.clearcoatMap,
                tt = Y && !!s.clearcoatNormalMap,
                et = Y && !!s.clearcoatRoughnessMap,
                nt = K && !!s.iridescenceMap,
                it = K && !!s.iridescenceThicknessMap,
                rt = Z && !!s.sheenColorMap,
                st = Z && !!s.sheenRoughnessMap,
                at = !!s.specularMap,
                ot = !!s.specularColorMap,
                lt = !!s.specularIntensityMap,
                ct = J && !!s.transmissionMap,
                ht = J && !!s.thicknessMap,
                ut = !!s.gradientMap,
                dt = !!s.alphaMap,
                pt = s.alphaTest > 0,
                ft = !!s.alphaHash,
                mt = !!s.extensions,
                gt = !!y.attributes.uv1,
                _t = !!y.attributes.uv2,
                vt = !!y.attributes.uv3;
              let xt = d;
              return (
                s.toneMapped && ((null !== U && !0 !== U.isXRRenderTarget) || (xt = t.toneMapping)),
                {
                  isWebGL2: h,
                  shaderID: E,
                  shaderType: s.type,
                  shaderName: s.name,
                  vertexShader: R,
                  fragmentShader: C,
                  defines: s.defines,
                  customVertexShaderID: L,
                  customFragmentShaderID: P,
                  isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                  glslVersion: s.glslVersion,
                  precision: f,
                  batching: D,
                  instancing: N,
                  instancingColor: N && null !== v.instanceColor,
                  supportsVertexTextures: p,
                  outputColorSpace:
                    null === U
                      ? t.outputColorSpace
                      : !0 === U.isXRRenderTarget
                      ? U.texture.colorSpace
                      : zt,
                  map: O,
                  matcap: B,
                  envMap: F,
                  envMapMode: F && S.mapping,
                  envMapCubeUVHeight: b,
                  aoMap: z,
                  lightMap: H,
                  bumpMap: G,
                  normalMap: k,
                  displacementMap: p && V,
                  emissiveMap: W,
                  normalMapObjectSpace: k && 1 === s.normalMapType,
                  normalMapTangentSpace: k && 0 === s.normalMapType,
                  metalnessMap: X,
                  roughnessMap: j,
                  anisotropy: q,
                  anisotropyMap: Q,
                  clearcoat: Y,
                  clearcoatMap: $,
                  clearcoatNormalMap: tt,
                  clearcoatRoughnessMap: et,
                  iridescence: K,
                  iridescenceMap: nt,
                  iridescenceThicknessMap: it,
                  sheen: Z,
                  sheenColorMap: rt,
                  sheenRoughnessMap: st,
                  specularMap: at,
                  specularColorMap: ot,
                  specularIntensityMap: lt,
                  transmission: J,
                  transmissionMap: ct,
                  thicknessMap: ht,
                  gradientMap: ut,
                  opaque: !1 === s.transparent && 1 === s.blending,
                  alphaMap: dt,
                  alphaTest: pt,
                  alphaHash: ft,
                  combine: s.combine,
                  mapUv: O && g(s.map.channel),
                  aoMapUv: z && g(s.aoMap.channel),
                  lightMapUv: H && g(s.lightMap.channel),
                  bumpMapUv: G && g(s.bumpMap.channel),
                  normalMapUv: k && g(s.normalMap.channel),
                  displacementMapUv: V && g(s.displacementMap.channel),
                  emissiveMapUv: W && g(s.emissiveMap.channel),
                  metalnessMapUv: X && g(s.metalnessMap.channel),
                  roughnessMapUv: j && g(s.roughnessMap.channel),
                  anisotropyMapUv: Q && g(s.anisotropyMap.channel),
                  clearcoatMapUv: $ && g(s.clearcoatMap.channel),
                  clearcoatNormalMapUv: tt && g(s.clearcoatNormalMap.channel),
                  clearcoatRoughnessMapUv: et && g(s.clearcoatRoughnessMap.channel),
                  iridescenceMapUv: nt && g(s.iridescenceMap.channel),
                  iridescenceThicknessMapUv: it && g(s.iridescenceThicknessMap.channel),
                  sheenColorMapUv: rt && g(s.sheenColorMap.channel),
                  sheenRoughnessMapUv: st && g(s.sheenRoughnessMap.channel),
                  specularMapUv: at && g(s.specularMap.channel),
                  specularColorMapUv: ot && g(s.specularColorMap.channel),
                  specularIntensityMapUv: lt && g(s.specularIntensityMap.channel),
                  transmissionMapUv: ct && g(s.transmissionMap.channel),
                  thicknessMapUv: ht && g(s.thicknessMap.channel),
                  alphaMapUv: dt && g(s.alphaMap.channel),
                  vertexTangents: !!y.attributes.tangent && (k || q),
                  vertexColors: s.vertexColors,
                  vertexAlphas:
                    !0 === s.vertexColors &&
                    !!y.attributes.color &&
                    4 === y.attributes.color.itemSize,
                  vertexUv1s: gt,
                  vertexUv2s: _t,
                  vertexUv3s: vt,
                  pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (O || dt),
                  fog: !!x,
                  useFog: !0 === s.fog,
                  fogExp2: x && x.isFogExp2,
                  flatShading: !0 === s.flatShading,
                  sizeAttenuation: !0 === s.sizeAttenuation,
                  logarithmicDepthBuffer: u,
                  skinning: !0 === v.isSkinnedMesh,
                  morphTargets: void 0 !== y.morphAttributes.position,
                  morphNormals: void 0 !== y.morphAttributes.normal,
                  morphColors: void 0 !== y.morphAttributes.color,
                  morphTargetsCount: w,
                  morphTextureStride: I,
                  numDirLights: o.directional.length,
                  numPointLights: o.point.length,
                  numSpotLights: o.spot.length,
                  numSpotLightMaps: o.spotLightMap.length,
                  numRectAreaLights: o.rectArea.length,
                  numHemiLights: o.hemi.length,
                  numDirLightShadows: o.directionalShadowMap.length,
                  numPointLightShadows: o.pointShadowMap.length,
                  numSpotLightShadows: o.spotShadowMap.length,
                  numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                  numLightProbes: o.numLightProbes,
                  numClippingPlanes: a.numPlanes,
                  numClipIntersection: a.numIntersection,
                  dithering: s.dithering,
                  shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                  shadowMapType: t.shadowMap.type,
                  toneMapping: xt,
                  useLegacyLights: t._useLegacyLights,
                  decodeVideoTexture:
                    O && !0 === s.map.isVideoTexture && Ae.getTransfer(s.map.colorSpace) === Vt,
                  premultipliedAlpha: s.premultipliedAlpha,
                  doubleSided: 2 === s.side,
                  flipSided: 1 === s.side,
                  useDepthPacking: s.depthPacking >= 0,
                  depthPacking: s.depthPacking || 0,
                  index0AttributeName: s.index0AttributeName,
                  extensionDerivatives: mt && !0 === s.extensions.derivatives,
                  extensionFragDepth: mt && !0 === s.extensions.fragDepth,
                  extensionDrawBuffers: mt && !0 === s.extensions.drawBuffers,
                  extensionShaderTextureLOD: mt && !0 === s.extensions.shaderTextureLOD,
                  extensionClipCullDistance:
                    mt && s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                  rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
                  rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
                  rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
                  rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                  customProgramCacheKey: s.customProgramCacheKey(),
                }
              );
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              return (
                !1 === e.isRawShaderMaterial &&
                  ((function (t, e) {
                    t.push(e.precision),
                      t.push(e.outputColorSpace),
                      t.push(e.envMapMode),
                      t.push(e.envMapCubeUVHeight),
                      t.push(e.mapUv),
                      t.push(e.alphaMapUv),
                      t.push(e.lightMapUv),
                      t.push(e.aoMapUv),
                      t.push(e.bumpMapUv),
                      t.push(e.normalMapUv),
                      t.push(e.displacementMapUv),
                      t.push(e.emissiveMapUv),
                      t.push(e.metalnessMapUv),
                      t.push(e.roughnessMapUv),
                      t.push(e.anisotropyMapUv),
                      t.push(e.clearcoatMapUv),
                      t.push(e.clearcoatNormalMapUv),
                      t.push(e.clearcoatRoughnessMapUv),
                      t.push(e.iridescenceMapUv),
                      t.push(e.iridescenceThicknessMapUv),
                      t.push(e.sheenColorMapUv),
                      t.push(e.sheenRoughnessMapUv),
                      t.push(e.specularMapUv),
                      t.push(e.specularColorMapUv),
                      t.push(e.specularIntensityMapUv),
                      t.push(e.transmissionMapUv),
                      t.push(e.thicknessMapUv),
                      t.push(e.combine),
                      t.push(e.fogExp2),
                      t.push(e.sizeAttenuation),
                      t.push(e.morphTargetsCount),
                      t.push(e.morphAttributeCount),
                      t.push(e.numDirLights),
                      t.push(e.numPointLights),
                      t.push(e.numSpotLights),
                      t.push(e.numSpotLightMaps),
                      t.push(e.numHemiLights),
                      t.push(e.numRectAreaLights),
                      t.push(e.numDirLightShadows),
                      t.push(e.numPointLightShadows),
                      t.push(e.numSpotLightShadows),
                      t.push(e.numSpotLightShadowsWithMaps),
                      t.push(e.numLightProbes),
                      t.push(e.shadowMapType),
                      t.push(e.toneMapping),
                      t.push(e.numClippingPlanes),
                      t.push(e.numClipIntersection),
                      t.push(e.depthPacking);
                  })(n, e),
                  (function (t, e) {
                    o.disableAll(),
                      e.isWebGL2 && o.enable(0),
                      e.supportsVertexTextures && o.enable(1),
                      e.instancing && o.enable(2),
                      e.instancingColor && o.enable(3),
                      e.matcap && o.enable(4),
                      e.envMap && o.enable(5),
                      e.normalMapObjectSpace && o.enable(6),
                      e.normalMapTangentSpace && o.enable(7),
                      e.clearcoat && o.enable(8),
                      e.iridescence && o.enable(9),
                      e.alphaTest && o.enable(10),
                      e.vertexColors && o.enable(11),
                      e.vertexAlphas && o.enable(12),
                      e.vertexUv1s && o.enable(13),
                      e.vertexUv2s && o.enable(14),
                      e.vertexUv3s && o.enable(15),
                      e.vertexTangents && o.enable(16),
                      e.anisotropy && o.enable(17),
                      e.alphaHash && o.enable(18),
                      e.batching && o.enable(19),
                      t.push(o.mask),
                      o.disableAll(),
                      e.fog && o.enable(0),
                      e.useFog && o.enable(1),
                      e.flatShading && o.enable(2),
                      e.logarithmicDepthBuffer && o.enable(3),
                      e.skinning && o.enable(4),
                      e.morphTargets && o.enable(5),
                      e.morphNormals && o.enable(6),
                      e.morphColors && o.enable(7),
                      e.premultipliedAlpha && o.enable(8),
                      e.shadowMapEnabled && o.enable(9),
                      e.useLegacyLights && o.enable(10),
                      e.doubleSided && o.enable(11),
                      e.flipSided && o.enable(12),
                      e.useDepthPacking && o.enable(13),
                      e.dithering && o.enable(14),
                      e.transmission && o.enable(15),
                      e.sheen && o.enable(16),
                      e.opaque && o.enable(17),
                      e.pointsUvs && o.enable(18),
                      e.decodeVideoTexture && o.enable(19),
                      t.push(o.mask);
                  })(n, e),
                  n.push(t.outputColorSpace)),
                n.push(e.customProgramCacheKey),
                n.join()
              );
            },
            getUniforms: function (t) {
              const e = m[t.type];
              let n;
              if (e) {
                const t = yr[e];
                n = tr.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let i;
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                if (e.cacheKey === n) {
                  (i = e), ++i.usedTimes;
                  break;
                }
              }
              return void 0 === i && ((i = new Ma(t, n, e, s)), c.push(i)), i;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = c.indexOf(t);
                (c[e] = c[c.length - 1]), c.pop(), t.destroy();
              }
            },
            releaseShaderCache: function (t) {
              l.remove(t);
            },
            programs: c,
            dispose: function () {
              l.dispose();
            },
          };
        }
        function Aa() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, i) {
              t.get(e)[n] = i;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function wa(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id;
        }
        function Ra(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id;
        }
        function Ca() {
          const t = [];
          let e = 0;
          const n = [],
            i = [],
            r = [];
          function s(n, i, r, s, a, o) {
            let l = t[e];
            return (
              void 0 === l
                ? ((l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: o,
                  }),
                  (t[e] = l))
                : ((l.id = n.id),
                  (l.object = n),
                  (l.geometry = i),
                  (l.material = r),
                  (l.groupOrder = s),
                  (l.renderOrder = n.renderOrder),
                  (l.z = a),
                  (l.group = o)),
              e++,
              l
            );
          }
          return {
            opaque: n,
            transmissive: i,
            transparent: r,
            init: function () {
              (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
            },
            push: function (t, e, a, o, l, c) {
              const h = s(t, e, a, o, l, c);
              a.transmission > 0 ? i.push(h) : !0 === a.transparent ? r.push(h) : n.push(h);
            },
            unshift: function (t, e, a, o, l, c) {
              const h = s(t, e, a, o, l, c);
              a.transmission > 0
                ? i.unshift(h)
                : !0 === a.transparent
                ? r.unshift(h)
                : n.unshift(h);
            },
            finish: function () {
              for (let n = e, i = t.length; n < i; n++) {
                const e = t[n];
                if (null === e.id) break;
                (e.id = null),
                  (e.object = null),
                  (e.geometry = null),
                  (e.material = null),
                  (e.group = null);
              }
            },
            sort: function (t, e) {
              n.length > 1 && n.sort(t || wa),
                i.length > 1 && i.sort(e || Ra),
                r.length > 1 && r.sort(e || Ra);
            },
          };
        }
        function La() {
          let t = new WeakMap();
          return {
            get: function (e, n) {
              const i = t.get(e);
              let r;
              return (
                void 0 === i
                  ? ((r = new Ca()), t.set(e, [r]))
                  : n >= i.length
                  ? ((r = new Ca()), i.push(r))
                  : (r = i[n]),
                r
              );
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function Pa() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                  n = { direction: new ke(), color: new oi() };
                  break;
                case "SpotLight":
                  n = {
                    position: new ke(),
                    direction: new ke(),
                    color: new oi(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case "PointLight":
                  n = { position: new ke(), color: new oi(), distance: 0, decay: 0 };
                  break;
                case "HemisphereLight":
                  n = { direction: new ke(), skyColor: new oi(), groundColor: new oi() };
                  break;
                case "RectAreaLight":
                  n = {
                    color: new oi(),
                    position: new ke(),
                    halfWidth: new ke(),
                    halfHeight: new ke(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let Ia = 0;
        function Ua(t, e) {
          return (
            (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
          );
        }
        function Na(t, e) {
          const n = new Pa(),
            i = (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new de(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new de(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (t[e.id] = n), n;
                },
              };
            })(),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotLightMap: [],
              spotShadow: [],
              spotShadowMap: [],
              spotLightMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
              numSpotLightShadowsWithMaps: 0,
              numLightProbes: 0,
            };
          for (let t = 0; t < 9; t++) r.probe.push(new ke());
          const s = new ke(),
            a = new xn(),
            o = new xn();
          return {
            setup: function (s, a) {
              let o = 0,
                l = 0,
                c = 0;
              for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
              let h = 0,
                u = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0,
                g = 0,
                _ = 0,
                v = 0,
                x = 0,
                y = 0;
              s.sort(Ua);
              const M = !0 === a ? Math.PI : 1;
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  a = e.color,
                  S = e.intensity,
                  b = e.distance,
                  E = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight) (o += a.r * S * M), (l += a.g * S * M), (c += a.b * S * M);
                else if (e.isLightProbe) {
                  for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], S);
                  y++;
                } else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if ((t.color.copy(e.color).multiplyScalar(e.intensity * M), e.castShadow)) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.directionalShadow[h] = n),
                      (r.directionalShadowMap[h] = E),
                      (r.directionalShadowMatrix[h] = e.shadow.matrix),
                      m++;
                  }
                  (r.directional[h] = t), h++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(a).multiplyScalar(S * M),
                    (t.distance = b),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    (r.spot[d] = t);
                  const s = e.shadow;
                  if (
                    (e.map &&
                      ((r.spotLightMap[v] = e.map), v++, s.updateMatrices(e), e.castShadow && x++),
                    (r.spotLightMatrix[d] = s.matrix),
                    e.castShadow)
                  ) {
                    const t = i.get(e);
                    (t.shadowBias = s.bias),
                      (t.shadowNormalBias = s.normalBias),
                      (t.shadowRadius = s.radius),
                      (t.shadowMapSize = s.mapSize),
                      (r.spotShadow[d] = t),
                      (r.spotShadowMap[d] = E),
                      _++;
                  }
                  d++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(a).multiplyScalar(S),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (r.rectArea[p] = t),
                    p++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity * M),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (r.pointShadow[u] = n),
                      (r.pointShadowMap[u] = E),
                      (r.pointShadowMatrix[u] = e.shadow.matrix),
                      g++;
                  }
                  (r.point[u] = t), u++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(S * M),
                    t.groundColor.copy(e.groundColor).multiplyScalar(S * M),
                    (r.hemi[f] = t),
                    f++;
                }
              }
              p > 0 &&
                (e.isWebGL2
                  ? !0 === t.has("OES_texture_float_linear")
                    ? ((r.rectAreaLTC1 = xr.LTC_FLOAT_1), (r.rectAreaLTC2 = xr.LTC_FLOAT_2))
                    : ((r.rectAreaLTC1 = xr.LTC_HALF_1), (r.rectAreaLTC2 = xr.LTC_HALF_2))
                  : !0 === t.has("OES_texture_float_linear")
                  ? ((r.rectAreaLTC1 = xr.LTC_FLOAT_1), (r.rectAreaLTC2 = xr.LTC_FLOAT_2))
                  : !0 === t.has("OES_texture_half_float_linear")
                  ? ((r.rectAreaLTC1 = xr.LTC_HALF_1), (r.rectAreaLTC2 = xr.LTC_HALF_2))
                  : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                    )),
                (r.ambient[0] = o),
                (r.ambient[1] = l),
                (r.ambient[2] = c);
              const S = r.hash;
              (S.directionalLength === h &&
                S.pointLength === u &&
                S.spotLength === d &&
                S.rectAreaLength === p &&
                S.hemiLength === f &&
                S.numDirectionalShadows === m &&
                S.numPointShadows === g &&
                S.numSpotShadows === _ &&
                S.numSpotMaps === v &&
                S.numLightProbes === y) ||
                ((r.directional.length = h),
                (r.spot.length = d),
                (r.rectArea.length = p),
                (r.point.length = u),
                (r.hemi.length = f),
                (r.directionalShadow.length = m),
                (r.directionalShadowMap.length = m),
                (r.pointShadow.length = g),
                (r.pointShadowMap.length = g),
                (r.spotShadow.length = _),
                (r.spotShadowMap.length = _),
                (r.directionalShadowMatrix.length = m),
                (r.pointShadowMatrix.length = g),
                (r.spotLightMatrix.length = _ + v - x),
                (r.spotLightMap.length = v),
                (r.numSpotLightShadowsWithMaps = x),
                (r.numLightProbes = y),
                (S.directionalLength = h),
                (S.pointLength = u),
                (S.spotLength = d),
                (S.rectAreaLength = p),
                (S.hemiLength = f),
                (S.numDirectionalShadows = m),
                (S.numPointShadows = g),
                (S.numSpotShadows = _),
                (S.numSpotMaps = v),
                (S.numLightProbes = y),
                (r.version = Ia++));
            },
            setupView: function (t, e) {
              let n = 0,
                i = 0,
                l = 0,
                c = 0,
                h = 0;
              const u = e.matrixWorldInverse;
              for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e];
                if (d.isDirectionalLight) {
                  const t = r.directional[n];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    n++;
                } else if (d.isSpotLight) {
                  const t = r.spot[l];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    l++;
                } else if (d.isRectAreaLight) {
                  const t = r.rectArea[c];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    o.identity(),
                    a.copy(d.matrixWorld),
                    a.premultiply(u),
                    o.extractRotation(a),
                    t.halfWidth.set(0.5 * d.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * d.height, 0),
                    t.halfWidth.applyMatrix4(o),
                    t.halfHeight.applyMatrix4(o),
                    c++;
                } else if (d.isPointLight) {
                  const t = r.point[i];
                  t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++;
                } else if (d.isHemisphereLight) {
                  const t = r.hemi[h];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    t.direction.transformDirection(u),
                    h++;
                }
              }
            },
            state: r,
          };
        }
        function Da(t, e) {
          const n = new Na(t, e),
            i = [],
            r = [];
          return {
            init: function () {
              (i.length = 0), (r.length = 0);
            },
            state: { lightsArray: i, shadowsArray: r, lights: n },
            setupLights: function (t) {
              n.setup(i, t);
            },
            setupLightsView: function (t) {
              n.setupView(i, t);
            },
            pushLight: function (t) {
              i.push(t);
            },
            pushShadow: function (t) {
              r.push(t);
            },
          };
        }
        function Oa(t, e) {
          let n = new WeakMap();
          return {
            get: function (i, r = 0) {
              const s = n.get(i);
              let a;
              return (
                void 0 === s
                  ? ((a = new Da(t, e)), n.set(i, [a]))
                  : r >= s.length
                  ? ((a = new Da(t, e)), s.push(a))
                  : (a = s[r]),
                a
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class Ba extends hi {
          constructor(t) {
            super(),
              (this.isMeshDepthMaterial = !0),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        class Fa extends hi {
          constructor(t) {
            super(),
              (this.isMeshDistanceMaterial = !0),
              (this.type = "MeshDistanceMaterial"),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        function za(t, e, n) {
          let r = new fr();
          const a = new de(),
            o = new de(),
            l = new Oe(),
            c = new Ba({ depthPacking: 3201 }),
            h = new Fa(),
            u = {},
            d = n.maxTextureSize,
            p = { 0: 1, 1: 0, 2: 2 },
            f = new er({
              defines: { VSM_SAMPLES: 8 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new de() },
                radius: { value: 4 },
              },
              vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
              fragmentShader:
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            }),
            m = f.clone();
          m.defines.HORIZONTAL_PASS = 1;
          const g = new Li();
          g.setAttribute(
            "position",
            new xi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          const _ = new Yi(g, f),
            v = this;
          (this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = i);
          let x = this.type;
          function y(n, i) {
            const r = e.update(_);
            f.defines.VSM_SAMPLES !== n.blurSamples &&
              ((f.defines.VSM_SAMPLES = n.blurSamples),
              (m.defines.VSM_SAMPLES = n.blurSamples),
              (f.needsUpdate = !0),
              (m.needsUpdate = !0)),
              null === n.mapPass && (n.mapPass = new Fe(a.x, a.y)),
              (f.uniforms.shadow_pass.value = n.map.texture),
              (f.uniforms.resolution.value = n.mapSize),
              (f.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(i, null, r, f, _, null),
              (m.uniforms.shadow_pass.value = n.mapPass.texture),
              (m.uniforms.resolution.value = n.mapSize),
              (m.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(i, null, r, m, _, null);
          }
          function M(e, n, i, r) {
            let a = null;
            const o = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
            if (void 0 !== o) a = o;
            else if (
              ((a = !0 === i.isPointLight ? h : c),
              (t.localClippingEnabled &&
                !0 === n.clipShadows &&
                Array.isArray(n.clippingPlanes) &&
                0 !== n.clippingPlanes.length) ||
                (n.displacementMap && 0 !== n.displacementScale) ||
                (n.alphaMap && n.alphaTest > 0) ||
                (n.map && n.alphaTest > 0))
            ) {
              const t = a.uuid,
                e = n.uuid;
              let i = u[t];
              void 0 === i && ((i = {}), (u[t] = i));
              let r = i[e];
              void 0 === r && ((r = a.clone()), (i[e] = r), n.addEventListener("dispose", b)),
                (a = r);
            }
            return (
              (a.visible = n.visible),
              (a.wireframe = n.wireframe),
              (a.side =
                r === s
                  ? null !== n.shadowSide
                    ? n.shadowSide
                    : n.side
                  : null !== n.shadowSide
                  ? n.shadowSide
                  : p[n.side]),
              (a.alphaMap = n.alphaMap),
              (a.alphaTest = n.alphaTest),
              (a.map = n.map),
              (a.clipShadows = n.clipShadows),
              (a.clippingPlanes = n.clippingPlanes),
              (a.clipIntersection = n.clipIntersection),
              (a.displacementMap = n.displacementMap),
              (a.displacementScale = n.displacementScale),
              (a.displacementBias = n.displacementBias),
              (a.wireframeLinewidth = n.wireframeLinewidth),
              (a.linewidth = n.linewidth),
              !0 === i.isPointLight &&
                !0 === a.isMeshDistanceMaterial &&
                (t.properties.get(a).light = i),
              a
            );
          }
          function S(n, i, a, o, l) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(i.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && l === s)) &&
              (!n.frustumCulled || r.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
              const r = e.update(n),
                s = n.material;
              if (Array.isArray(s)) {
                const e = r.groups;
                for (let c = 0, h = e.length; c < h; c++) {
                  const h = e[c],
                    u = s[h.materialIndex];
                  if (u && u.visible) {
                    const e = M(n, u, o, l);
                    n.onBeforeShadow(t, n, i, a, r, e, h),
                      t.renderBufferDirect(a, null, r, e, n, h),
                      n.onAfterShadow(t, n, i, a, r, e, h);
                  }
                }
              } else if (s.visible) {
                const e = M(n, s, o, l);
                n.onBeforeShadow(t, n, i, a, r, e, null),
                  t.renderBufferDirect(a, null, r, e, n, null),
                  n.onAfterShadow(t, n, i, a, r, e, null);
              }
            }
            const c = n.children;
            for (let t = 0, e = c.length; t < e; t++) S(c[t], i, a, o, l);
          }
          function b(t) {
            t.target.removeEventListener("dispose", b);
            for (const e in u) {
              const n = u[e],
                i = t.target.uuid;
              i in n && (n[i].dispose(), delete n[i]);
            }
          }
          this.render = function (e, n, i) {
            if (!1 === v.enabled) return;
            if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
            if (0 === e.length) return;
            const c = t.getRenderTarget(),
              h = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              p = t.state;
            p.setBlending(0),
              p.buffers.color.setClear(1, 1, 1, 1),
              p.buffers.depth.setTest(!0),
              p.setScissorTest(!1);
            const f = x !== s && this.type === s,
              m = x === s && this.type !== s;
            for (let c = 0, h = e.length; c < h; c++) {
              const h = e[c],
                u = h.shadow;
              if (void 0 === u) {
                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                continue;
              }
              if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
              a.copy(u.mapSize);
              const g = u.getFrameExtents();
              if (
                (a.multiply(g),
                o.copy(u.mapSize),
                (a.x > d || a.y > d) &&
                  (a.x > d && ((o.x = Math.floor(d / g.x)), (a.x = o.x * g.x), (u.mapSize.x = o.x)),
                  a.y > d && ((o.y = Math.floor(d / g.y)), (a.y = o.y * g.y), (u.mapSize.y = o.y))),
                null === u.map || !0 === f || !0 === m)
              ) {
                const t = this.type !== s ? { minFilter: L, magFilter: L } : {};
                null !== u.map && u.map.dispose(),
                  (u.map = new Fe(a.x, a.y, t)),
                  (u.map.texture.name = h.name + ".shadowMap"),
                  u.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(u.map), t.clear();
              const _ = u.getViewportCount();
              for (let t = 0; t < _; t++) {
                const e = u.getViewport(t);
                l.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
                  p.viewport(l),
                  u.updateMatrices(h, t),
                  (r = u.getFrustum()),
                  S(n, i, u.camera, h, this.type);
              }
              !0 !== u.isPointLightShadow && this.type === s && y(u, i), (u.needsUpdate = !1);
            }
            (x = this.type), (v.needsUpdate = !1), t.setRenderTarget(c, h, u);
          };
        }
        function Ha(t, e, n) {
          const i = n.isWebGL2,
            r = new (function () {
              let e = !1;
              const n = new Oe();
              let i = null;
              const r = new Oe(0, 0, 0, 0);
              return {
                setMask: function (n) {
                  i === n || e || (t.colorMask(n, n, n, n), (i = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, i, s, a, o) {
                  !0 === o && ((e *= a), (i *= a), (s *= a)),
                    n.set(e, i, s, a),
                    !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
                },
                reset: function () {
                  (e = !1), (i = null), r.set(-1, 0, 0, 0);
                },
              };
            })(),
            s = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null;
              return {
                setTest: function (e) {
                  e ? X(t.DEPTH_TEST) : j(t.DEPTH_TEST);
                },
                setMask: function (i) {
                  n === i || e || (t.depthMask(i), (n = i));
                },
                setFunc: function (e) {
                  if (i !== e) {
                    switch (e) {
                      case 0:
                        t.depthFunc(t.NEVER);
                        break;
                      case 1:
                        t.depthFunc(t.ALWAYS);
                        break;
                      case 2:
                        t.depthFunc(t.LESS);
                        break;
                      case 3:
                      default:
                        t.depthFunc(t.LEQUAL);
                        break;
                      case 4:
                        t.depthFunc(t.EQUAL);
                        break;
                      case 5:
                        t.depthFunc(t.GEQUAL);
                        break;
                      case 6:
                        t.depthFunc(t.GREATER);
                        break;
                      case 7:
                        t.depthFunc(t.NOTEQUAL);
                    }
                    i = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  r !== e && (t.clearDepth(e), (r = e));
                },
                reset: function () {
                  (e = !1), (n = null), (i = null), (r = null);
                },
              };
            })(),
            c = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null,
                s = null,
                a = null,
                o = null,
                l = null,
                c = null;
              return {
                setTest: function (n) {
                  e || (n ? X(t.STENCIL_TEST) : j(t.STENCIL_TEST));
                },
                setMask: function (i) {
                  n === i || e || (t.stencilMask(i), (n = i));
                },
                setFunc: function (e, n, a) {
                  (i === e && r === n && s === a) ||
                    (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
                },
                setOp: function (e, n, i) {
                  (a === e && o === n && l === i) ||
                    (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (i = null),
                    (r = null),
                    (s = null),
                    (a = null),
                    (o = null),
                    (l = null),
                    (c = null);
                },
              };
            })(),
            h = new WeakMap(),
            u = new WeakMap();
          let d = {},
            p = {},
            f = new WeakMap(),
            m = [],
            g = null,
            _ = !1,
            v = null,
            x = null,
            y = null,
            M = null,
            S = null,
            b = null,
            E = null,
            T = new oi(0, 0, 0),
            A = 0,
            w = !1,
            R = null,
            C = null,
            L = null,
            P = null,
            I = null;
          const U = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
          let N = !1,
            D = 0;
          const O = t.getParameter(t.VERSION);
          -1 !== O.indexOf("WebGL")
            ? ((D = parseFloat(/^WebGL (\d)/.exec(O)[1])), (N = D >= 1))
            : -1 !== O.indexOf("OpenGL ES") &&
              ((D = parseFloat(/^OpenGL ES (\d)/.exec(O)[1])), (N = D >= 2));
          let B = null,
            F = {};
          const z = t.getParameter(t.SCISSOR_BOX),
            H = t.getParameter(t.VIEWPORT),
            G = new Oe().fromArray(z),
            k = new Oe().fromArray(H);
          function V(e, n, r, s) {
            const a = new Uint8Array(4),
              o = t.createTexture();
            t.bindTexture(e, o),
              t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
              t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (let o = 0; o < r; o++)
              !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
                ? t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a)
                : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, a);
            return o;
          }
          const W = {};
          function X(e) {
            !0 !== d[e] && (t.enable(e), (d[e] = !0));
          }
          function j(e) {
            !1 !== d[e] && (t.disable(e), (d[e] = !1));
          }
          (W[t.TEXTURE_2D] = V(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
            (W[t.TEXTURE_CUBE_MAP] = V(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
            i &&
              ((W[t.TEXTURE_2D_ARRAY] = V(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1)),
              (W[t.TEXTURE_3D] = V(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            c.setClear(0),
            X(t.DEPTH_TEST),
            s.setFunc(3),
            Z(!1),
            J(1),
            X(t.CULL_FACE),
            K(0);
          const q = { [a]: t.FUNC_ADD, 101: t.FUNC_SUBTRACT, 102: t.FUNC_REVERSE_SUBTRACT };
          if (i) (q[103] = t.MIN), (q[104] = t.MAX);
          else {
            const t = e.get("EXT_blend_minmax");
            null !== t && ((q[103] = t.MIN_EXT), (q[104] = t.MAX_EXT));
          }
          const Y = {
            200: t.ZERO,
            201: t.ONE,
            202: t.SRC_COLOR,
            [o]: t.SRC_ALPHA,
            210: t.SRC_ALPHA_SATURATE,
            208: t.DST_COLOR,
            206: t.DST_ALPHA,
            203: t.ONE_MINUS_SRC_COLOR,
            [l]: t.ONE_MINUS_SRC_ALPHA,
            209: t.ONE_MINUS_DST_COLOR,
            207: t.ONE_MINUS_DST_ALPHA,
            211: t.CONSTANT_COLOR,
            212: t.ONE_MINUS_CONSTANT_COLOR,
            213: t.CONSTANT_ALPHA,
            214: t.ONE_MINUS_CONSTANT_ALPHA,
          };
          function K(e, n, i, r, s, o, l, c, h, u) {
            if (0 !== e) {
              if ((!1 === _ && (X(t.BLEND), (_ = !0)), 5 === e))
                (s = s || n),
                  (o = o || i),
                  (l = l || r),
                  (n === x && s === S) || (t.blendEquationSeparate(q[n], q[s]), (x = n), (S = s)),
                  (i === y && r === M && o === b && l === E) ||
                    (t.blendFuncSeparate(Y[i], Y[r], Y[o], Y[l]),
                    (y = i),
                    (M = r),
                    (b = o),
                    (E = l)),
                  (!1 !== c.equals(T) && h === A) ||
                    (t.blendColor(c.r, c.g, c.b, h), T.copy(c), (A = h)),
                  (v = e),
                  (w = !1);
              else if (e !== v || u !== w) {
                if (((x === a && S === a) || (t.blendEquation(t.FUNC_ADD), (x = a), (S = a)), u))
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      );
                      break;
                    case 2:
                      t.blendFunc(t.ONE, t.ONE);
                      break;
                    case 3:
                      t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                      break;
                    case 4:
                      t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                else
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(
                        t.SRC_ALPHA,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      );
                      break;
                    case 2:
                      t.blendFunc(t.SRC_ALPHA, t.ONE);
                      break;
                    case 3:
                      t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                      break;
                    case 4:
                      t.blendFunc(t.ZERO, t.SRC_COLOR);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                (y = null),
                  (M = null),
                  (b = null),
                  (E = null),
                  T.set(0, 0, 0),
                  (A = 0),
                  (v = e),
                  (w = u);
              }
            } else !0 === _ && (j(t.BLEND), (_ = !1));
          }
          function Z(e) {
            R !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (R = e));
          }
          function J(e) {
            0 !== e
              ? (X(t.CULL_FACE),
                e !== C &&
                  (1 === e
                    ? t.cullFace(t.BACK)
                    : 2 === e
                    ? t.cullFace(t.FRONT)
                    : t.cullFace(t.FRONT_AND_BACK)))
              : j(t.CULL_FACE),
              (C = e);
          }
          function Q(e, n, i) {
            e
              ? (X(t.POLYGON_OFFSET_FILL),
                (P === n && I === i) || (t.polygonOffset(n, i), (P = n), (I = i)))
              : j(t.POLYGON_OFFSET_FILL);
          }
          return {
            buffers: { color: r, depth: s, stencil: c },
            enable: X,
            disable: j,
            bindFramebuffer: function (e, n) {
              return (
                p[e] !== n &&
                (t.bindFramebuffer(e, n),
                (p[e] = n),
                i &&
                  (e === t.DRAW_FRAMEBUFFER && (p[t.FRAMEBUFFER] = n),
                  e === t.FRAMEBUFFER && (p[t.DRAW_FRAMEBUFFER] = n)),
                !0)
              );
            },
            drawBuffers: function (i, r) {
              let s = m,
                a = !1;
              if (i)
                if (
                  ((s = f.get(r)),
                  void 0 === s && ((s = []), f.set(r, s)),
                  i.isWebGLMultipleRenderTargets)
                ) {
                  const e = i.texture;
                  if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                    for (let n = 0, i = e.length; n < i; n++) s[n] = t.COLOR_ATTACHMENT0 + n;
                    (s.length = e.length), (a = !0);
                  }
                } else s[0] !== t.COLOR_ATTACHMENT0 && ((s[0] = t.COLOR_ATTACHMENT0), (a = !0));
              else s[0] !== t.BACK && ((s[0] = t.BACK), (a = !0));
              a &&
                (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
            },
            useProgram: function (e) {
              return g !== e && (t.useProgram(e), (g = e), !0);
            },
            setBlending: K,
            setMaterial: function (e, n) {
              2 === e.side ? j(t.CULL_FACE) : X(t.CULL_FACE);
              let i = 1 === e.side;
              n && (i = !i),
                Z(i),
                1 === e.blending && !1 === e.transparent
                  ? K(0)
                  : K(
                      e.blending,
                      e.blendEquation,
                      e.blendSrc,
                      e.blendDst,
                      e.blendEquationAlpha,
                      e.blendSrcAlpha,
                      e.blendDstAlpha,
                      e.blendColor,
                      e.blendAlpha,
                      e.premultipliedAlpha
                    ),
                s.setFunc(e.depthFunc),
                s.setTest(e.depthTest),
                s.setMask(e.depthWrite),
                r.setMask(e.colorWrite);
              const a = e.stencilWrite;
              c.setTest(a),
                a &&
                  (c.setMask(e.stencilWriteMask),
                  c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                  c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                Q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                !0 === e.alphaToCoverage
                  ? X(t.SAMPLE_ALPHA_TO_COVERAGE)
                  : j(t.SAMPLE_ALPHA_TO_COVERAGE);
            },
            setFlipSided: Z,
            setCullFace: J,
            setLineWidth: function (e) {
              e !== L && (N && t.lineWidth(e), (L = e));
            },
            setPolygonOffset: Q,
            setScissorTest: function (e) {
              e ? X(t.SCISSOR_TEST) : j(t.SCISSOR_TEST);
            },
            activeTexture: function (e) {
              void 0 === e && (e = t.TEXTURE0 + U - 1), B !== e && (t.activeTexture(e), (B = e));
            },
            bindTexture: function (e, n, i) {
              void 0 === i && (i = null === B ? t.TEXTURE0 + U - 1 : B);
              let r = F[i];
              void 0 === r && ((r = { type: void 0, texture: void 0 }), (F[i] = r)),
                (r.type === e && r.texture === n) ||
                  (B !== i && (t.activeTexture(i), (B = i)),
                  t.bindTexture(e, n || W[e]),
                  (r.type = e),
                  (r.texture = n));
            },
            unbindTexture: function () {
              const e = F[B];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexImage3D: function () {
              try {
                t.compressedTexImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            updateUBOMapping: function (e, n) {
              let i = u.get(n);
              void 0 === i && ((i = new WeakMap()), u.set(n, i));
              let r = i.get(e);
              void 0 === r && ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
            },
            uniformBlockBinding: function (e, n) {
              const i = u.get(n).get(e);
              h.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), h.set(n, i));
            },
            texStorage2D: function () {
              try {
                t.texStorage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texStorage3D: function () {
              try {
                t.texStorage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texSubImage2D: function () {
              try {
                t.texSubImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texSubImage3D: function () {
              try {
                t.texSubImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexSubImage2D: function () {
              try {
                t.compressedTexSubImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexSubImage3D: function () {
              try {
                t.compressedTexSubImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            scissor: function (e) {
              !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e));
            },
            viewport: function (e) {
              !1 === k.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), k.copy(e));
            },
            reset: function () {
              t.disable(t.BLEND),
                t.disable(t.CULL_FACE),
                t.disable(t.DEPTH_TEST),
                t.disable(t.POLYGON_OFFSET_FILL),
                t.disable(t.SCISSOR_TEST),
                t.disable(t.STENCIL_TEST),
                t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.ONE, t.ZERO),
                t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                t.blendColor(0, 0, 0, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(t.LESS),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(t.ALWAYS, 0, 4294967295),
                t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                t.clearStencil(0),
                t.cullFace(t.BACK),
                t.frontFace(t.CCW),
                t.polygonOffset(0, 0),
                t.activeTexture(t.TEXTURE0),
                t.bindFramebuffer(t.FRAMEBUFFER, null),
                !0 === i &&
                  (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                  t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (d = {}),
                (B = null),
                (F = {}),
                (p = {}),
                (f = new WeakMap()),
                (m = []),
                (g = null),
                (_ = !1),
                (v = null),
                (x = null),
                (y = null),
                (M = null),
                (S = null),
                (b = null),
                (E = null),
                (T = new oi(0, 0, 0)),
                (A = 0),
                (w = !1),
                (R = null),
                (C = null),
                (L = null),
                (P = null),
                (I = null),
                G.set(0, 0, t.canvas.width, t.canvas.height),
                k.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                s.reset(),
                c.reset();
            },
          };
        }
        function Ga(t, e, n, i, r, s, a) {
          const o = r.isWebGL2,
            l = e.has("WEBGL_multisampled_render_to_texture")
              ? e.get("WEBGL_multisampled_render_to_texture")
              : null,
            c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
            h = new WeakMap();
          let u;
          const d = new WeakMap();
          let p = !1;
          try {
            p =
              "undefined" != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d");
          } catch (t) {}
          function f(t, e) {
            return p ? new OffscreenCanvas(t, e) : ve("canvas");
          }
          function m(t, e, n, i) {
            let r = 1;
            if (
              ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
              r < 1 || !0 === e)
            ) {
              if (
                ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const i = e ? le : Math.floor,
                  s = i(r * t.width),
                  a = i(r * t.height);
                void 0 === u && (u = f(s, a));
                const o = n ? f(s, a) : u;
                return (
                  (o.width = s),
                  (o.height = a),
                  o.getContext("2d").drawImage(t, 0, 0, s, a),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                      t.width +
                      "x" +
                      t.height +
                      ") to (" +
                      s +
                      "x" +
                      a +
                      ")."
                  ),
                  o
                );
              }
              return (
                "data" in t &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      t.width +
                      "x" +
                      t.height +
                      ")."
                  ),
                t
              );
            }
            return t;
          }
          function g(t) {
            return oe(t.width) && oe(t.height);
          }
          function _(t, e) {
            return t.generateMipmaps && e && t.minFilter !== L && t.minFilter !== U;
          }
          function v(e) {
            t.generateMipmap(e);
          }
          function x(n, i, r, s, a = !1) {
            if (!1 === o) return i;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'"
              );
            }
            let l = i;
            if (
              (i === t.RED &&
                (r === t.FLOAT && (l = t.R32F),
                r === t.HALF_FLOAT && (l = t.R16F),
                r === t.UNSIGNED_BYTE && (l = t.R8)),
              i === t.RED_INTEGER &&
                (r === t.UNSIGNED_BYTE && (l = t.R8UI),
                r === t.UNSIGNED_SHORT && (l = t.R16UI),
                r === t.UNSIGNED_INT && (l = t.R32UI),
                r === t.BYTE && (l = t.R8I),
                r === t.SHORT && (l = t.R16I),
                r === t.INT && (l = t.R32I)),
              i === t.RG &&
                (r === t.FLOAT && (l = t.RG32F),
                r === t.HALF_FLOAT && (l = t.RG16F),
                r === t.UNSIGNED_BYTE && (l = t.RG8)),
              i === t.RGBA)
            ) {
              const e = a ? kt : Ae.getTransfer(s);
              r === t.FLOAT && (l = t.RGBA32F),
                r === t.HALF_FLOAT && (l = t.RGBA16F),
                r === t.UNSIGNED_BYTE && (l = e === Vt ? t.SRGB8_ALPHA8 : t.RGBA8),
                r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
                r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1);
            }
            return (
              (l !== t.R16F &&
                l !== t.R32F &&
                l !== t.RG16F &&
                l !== t.RG32F &&
                l !== t.RGBA16F &&
                l !== t.RGBA32F) ||
                e.get("EXT_color_buffer_float"),
              l
            );
          }
          function y(t, e, n) {
            return !0 === _(t, n) ||
              (t.isFramebufferTexture && t.minFilter !== L && t.minFilter !== U)
              ? Math.log2(Math.max(e.width, e.height)) + 1
              : void 0 !== t.mipmaps && t.mipmaps.length > 0
              ? t.mipmaps.length
              : t.isCompressedTexture && Array.isArray(t.image)
              ? e.mipmaps.length
              : 1;
          }
          function M(e) {
            return e === L || e === P || e === I ? t.NEAREST : t.LINEAR;
          }
          function S(t) {
            const e = t.target;
            e.removeEventListener("dispose", S),
              (function (t) {
                const e = i.get(t);
                if (void 0 === e.__webglInit) return;
                const n = t.source,
                  r = d.get(n);
                if (r) {
                  const i = r[e.__cacheKey];
                  i.usedTimes--,
                    0 === i.usedTimes && E(t),
                    0 === Object.keys(r).length && d.delete(n);
                }
                i.remove(t);
              })(e),
              e.isVideoTexture && h.delete(e);
          }
          function b(e) {
            const n = e.target;
            n.removeEventListener("dispose", b),
              (function (e) {
                const n = e.texture,
                  r = i.get(e),
                  s = i.get(n);
                if (
                  (void 0 !== s.__webglTexture &&
                    (t.deleteTexture(s.__webglTexture), a.memory.textures--),
                  e.depthTexture && e.depthTexture.dispose(),
                  e.isWebGLCubeRenderTarget)
                )
                  for (let e = 0; e < 6; e++) {
                    if (Array.isArray(r.__webglFramebuffer[e]))
                      for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                        t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                    else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                    r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                  }
                else {
                  if (Array.isArray(r.__webglFramebuffer))
                    for (let e = 0; e < r.__webglFramebuffer.length; e++)
                      t.deleteFramebuffer(r.__webglFramebuffer[e]);
                  else t.deleteFramebuffer(r.__webglFramebuffer);
                  if (
                    (r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer)
                  )
                    for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                      r.__webglColorRenderbuffer[e] &&
                        t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                  r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                }
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = i.get(n[e]);
                    r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--),
                      i.remove(n[e]);
                  }
                i.remove(n), i.remove(e);
              })(n);
          }
          function E(e) {
            const n = i.get(e);
            t.deleteTexture(n.__webglTexture);
            const r = e.source;
            delete d.get(r)[n.__cacheKey], a.memory.textures--;
          }
          let T = 0;
          function A(e, r) {
            const s = i.get(e);
            if (
              (e.isVideoTexture &&
                (function (t) {
                  const e = a.render.frame;
                  h.get(t) !== e && (h.set(t, e), t.update());
                })(e),
              !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version)
            ) {
              const t = e.image;
              if (null === t)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but no image data found."
                );
              else {
                if (!1 !== t.complete) return void Z(s, e, r);
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              }
            }
            n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
          }
          const F = { [w]: t.REPEAT, [R]: t.CLAMP_TO_EDGE, [C]: t.MIRRORED_REPEAT },
            k = {
              [L]: t.NEAREST,
              [P]: t.NEAREST_MIPMAP_NEAREST,
              [I]: t.NEAREST_MIPMAP_LINEAR,
              [U]: t.LINEAR,
              [N]: t.LINEAR_MIPMAP_NEAREST,
              [D]: t.LINEAR_MIPMAP_LINEAR,
            },
            V = {
              512: t.NEVER,
              519: t.ALWAYS,
              513: t.LESS,
              515: t.LEQUAL,
              514: t.EQUAL,
              518: t.GEQUAL,
              516: t.GREATER,
              517: t.NOTEQUAL,
            };
          function Y(n, s, a) {
            if (
              (a
                ? (t.texParameteri(n, t.TEXTURE_WRAP_S, F[s.wrapS]),
                  t.texParameteri(n, t.TEXTURE_WRAP_T, F[s.wrapT]),
                  (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                    t.texParameteri(n, t.TEXTURE_WRAP_R, F[s.wrapR]),
                  t.texParameteri(n, t.TEXTURE_MAG_FILTER, k[s.magFilter]),
                  t.texParameteri(n, t.TEXTURE_MIN_FILTER, k[s.minFilter]))
                : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                  t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                  (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                    t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
                  (s.wrapS === R && s.wrapT === R) ||
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                    ),
                  t.texParameteri(n, t.TEXTURE_MAG_FILTER, M(s.magFilter)),
                  t.texParameteri(n, t.TEXTURE_MIN_FILTER, M(s.minFilter)),
                  s.minFilter !== L &&
                    s.minFilter !== U &&
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                    )),
              s.compareFunction &&
                (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
                t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, V[s.compareFunction])),
              !0 === e.has("EXT_texture_filter_anisotropic"))
            ) {
              const a = e.get("EXT_texture_filter_anisotropic");
              if (s.magFilter === L) return;
              if (s.minFilter !== I && s.minFilter !== D) return;
              if (s.type === H && !1 === e.has("OES_texture_float_linear")) return;
              if (!1 === o && s.type === G && !1 === e.has("OES_texture_half_float_linear")) return;
              (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  a.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(s.anisotropy, r.getMaxAnisotropy())
                ),
                (i.get(s).__currentAnisotropy = s.anisotropy));
            }
          }
          function K(e, n) {
            let i = !1;
            void 0 === e.__webglInit && ((e.__webglInit = !0), n.addEventListener("dispose", S));
            const r = n.source;
            let s = d.get(r);
            void 0 === s && ((s = {}), d.set(r, s));
            const o = (function (t) {
              const e = [];
              return (
                e.push(t.wrapS),
                e.push(t.wrapT),
                e.push(t.wrapR || 0),
                e.push(t.magFilter),
                e.push(t.minFilter),
                e.push(t.anisotropy),
                e.push(t.internalFormat),
                e.push(t.format),
                e.push(t.type),
                e.push(t.generateMipmaps),
                e.push(t.premultiplyAlpha),
                e.push(t.flipY),
                e.push(t.unpackAlignment),
                e.push(t.colorSpace),
                e.join()
              );
            })(n);
            if (o !== e.__cacheKey) {
              void 0 === s[o] &&
                ((s[o] = { texture: t.createTexture(), usedTimes: 0 }),
                a.memory.textures++,
                (i = !0)),
                s[o].usedTimes++;
              const r = s[e.__cacheKey];
              void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && E(n)),
                (e.__cacheKey = o),
                (e.__webglTexture = s[o].texture);
            }
            return i;
          }
          function Z(e, a, l) {
            let c = t.TEXTURE_2D;
            (a.isDataArrayTexture || a.isCompressedArrayTexture) && (c = t.TEXTURE_2D_ARRAY),
              a.isData3DTexture && (c = t.TEXTURE_3D);
            const h = K(e, a),
              u = a.source;
            n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + l);
            const d = i.get(u);
            if (u.version !== d.__version || !0 === h) {
              n.activeTexture(t.TEXTURE0 + l);
              const e = Ae.getPrimaries(Ae.workingColorSpace),
                i = a.colorSpace === Bt ? null : Ae.getPrimaries(a.colorSpace),
                p = a.colorSpace === Bt || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
              t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
                t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
                t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
              const f =
                (function (t) {
                  return (
                    !o &&
                    (t.wrapS !== R || t.wrapT !== R || (t.minFilter !== L && t.minFilter !== U))
                  );
                })(a) && !1 === g(a.image);
              let M = m(a.image, f, !1, r.maxTextureSize);
              M = nt(a, M);
              const S = g(M) || o,
                b = s.convert(a.format, a.colorSpace);
              let E,
                T = s.convert(a.type),
                A = x(a.internalFormat, b, T, a.colorSpace, a.isVideoTexture);
              Y(c, a, S);
              const w = a.mipmaps,
                C = o && !0 !== a.isVideoTexture && A !== st,
                P = void 0 === d.__version || !0 === h,
                I = y(a, M, S);
              if (a.isDepthTexture)
                (A = t.DEPTH_COMPONENT),
                  o
                    ? (A =
                        a.type === H
                          ? t.DEPTH_COMPONENT32F
                          : a.type === z
                          ? t.DEPTH_COMPONENT24
                          : a.type === W
                          ? t.DEPTH24_STENCIL8
                          : t.DEPTH_COMPONENT16)
                    : a.type === H &&
                      console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                  a.format === j &&
                    A === t.DEPTH_COMPONENT &&
                    a.type !== B &&
                    a.type !== z &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                    ),
                    (a.type = z),
                    (T = s.convert(a.type))),
                  a.format === q &&
                    A === t.DEPTH_COMPONENT &&
                    ((A = t.DEPTH_STENCIL),
                    a.type !== W &&
                      (console.warn(
                        "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                      ),
                      (a.type = W),
                      (T = s.convert(a.type)))),
                  P &&
                    (C
                      ? n.texStorage2D(t.TEXTURE_2D, 1, A, M.width, M.height)
                      : n.texImage2D(t.TEXTURE_2D, 0, A, M.width, M.height, 0, b, T, null));
              else if (a.isDataTexture)
                if (w.length > 0 && S) {
                  C && P && n.texStorage2D(t.TEXTURE_2D, I, A, w[0].width, w[0].height);
                  for (let e = 0, i = w.length; e < i; e++)
                    (E = w[e]),
                      C
                        ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, E.width, E.height, b, T, E.data)
                        : n.texImage2D(t.TEXTURE_2D, e, A, E.width, E.height, 0, b, T, E.data);
                  a.generateMipmaps = !1;
                } else
                  C
                    ? (P && n.texStorage2D(t.TEXTURE_2D, I, A, M.width, M.height),
                      n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, M.width, M.height, b, T, M.data))
                    : n.texImage2D(t.TEXTURE_2D, 0, A, M.width, M.height, 0, b, T, M.data);
              else if (a.isCompressedTexture)
                if (a.isCompressedArrayTexture) {
                  C &&
                    P &&
                    n.texStorage3D(t.TEXTURE_2D_ARRAY, I, A, w[0].width, w[0].height, M.depth);
                  for (let e = 0, i = w.length; e < i; e++)
                    (E = w[e]),
                      a.format !== X
                        ? null !== b
                          ? C
                            ? n.compressedTexSubImage3D(
                                t.TEXTURE_2D_ARRAY,
                                e,
                                0,
                                0,
                                0,
                                E.width,
                                E.height,
                                M.depth,
                                b,
                                E.data,
                                0,
                                0
                              )
                            : n.compressedTexImage3D(
                                t.TEXTURE_2D_ARRAY,
                                e,
                                A,
                                E.width,
                                E.height,
                                M.depth,
                                0,
                                E.data,
                                0,
                                0
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : C
                        ? n.texSubImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            0,
                            0,
                            0,
                            E.width,
                            E.height,
                            M.depth,
                            b,
                            T,
                            E.data
                          )
                        : n.texImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            A,
                            E.width,
                            E.height,
                            M.depth,
                            0,
                            b,
                            T,
                            E.data
                          );
                } else {
                  C && P && n.texStorage2D(t.TEXTURE_2D, I, A, w[0].width, w[0].height);
                  for (let e = 0, i = w.length; e < i; e++)
                    (E = w[e]),
                      a.format !== X
                        ? null !== b
                          ? C
                            ? n.compressedTexSubImage2D(
                                t.TEXTURE_2D,
                                e,
                                0,
                                0,
                                E.width,
                                E.height,
                                b,
                                E.data
                              )
                            : n.compressedTexImage2D(
                                t.TEXTURE_2D,
                                e,
                                A,
                                E.width,
                                E.height,
                                0,
                                E.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : C
                        ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, E.width, E.height, b, T, E.data)
                        : n.texImage2D(t.TEXTURE_2D, e, A, E.width, E.height, 0, b, T, E.data);
                }
              else if (a.isDataArrayTexture)
                C
                  ? (P && n.texStorage3D(t.TEXTURE_2D_ARRAY, I, A, M.width, M.height, M.depth),
                    n.texSubImage3D(
                      t.TEXTURE_2D_ARRAY,
                      0,
                      0,
                      0,
                      0,
                      M.width,
                      M.height,
                      M.depth,
                      b,
                      T,
                      M.data
                    ))
                  : n.texImage3D(
                      t.TEXTURE_2D_ARRAY,
                      0,
                      A,
                      M.width,
                      M.height,
                      M.depth,
                      0,
                      b,
                      T,
                      M.data
                    );
              else if (a.isData3DTexture)
                C
                  ? (P && n.texStorage3D(t.TEXTURE_3D, I, A, M.width, M.height, M.depth),
                    n.texSubImage3D(
                      t.TEXTURE_3D,
                      0,
                      0,
                      0,
                      0,
                      M.width,
                      M.height,
                      M.depth,
                      b,
                      T,
                      M.data
                    ))
                  : n.texImage3D(t.TEXTURE_3D, 0, A, M.width, M.height, M.depth, 0, b, T, M.data);
              else if (a.isFramebufferTexture) {
                if (P)
                  if (C) n.texStorage2D(t.TEXTURE_2D, I, A, M.width, M.height);
                  else {
                    let e = M.width,
                      i = M.height;
                    for (let r = 0; r < I; r++)
                      n.texImage2D(t.TEXTURE_2D, r, A, e, i, 0, b, T, null), (e >>= 1), (i >>= 1);
                  }
              } else if (w.length > 0 && S) {
                C && P && n.texStorage2D(t.TEXTURE_2D, I, A, w[0].width, w[0].height);
                for (let e = 0, i = w.length; e < i; e++)
                  (E = w[e]),
                    C
                      ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, b, T, E)
                      : n.texImage2D(t.TEXTURE_2D, e, A, b, T, E);
                a.generateMipmaps = !1;
              } else
                C
                  ? (P && n.texStorage2D(t.TEXTURE_2D, I, A, M.width, M.height),
                    n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, b, T, M))
                  : n.texImage2D(t.TEXTURE_2D, 0, A, b, T, M);
              _(a, S) && v(c), (d.__version = u.version), a.onUpdate && a.onUpdate(a);
            }
            e.__version = a.version;
          }
          function J(e, r, a, o, c, h) {
            const u = s.convert(a.format, a.colorSpace),
              d = s.convert(a.type),
              p = x(a.internalFormat, u, d, a.colorSpace);
            if (!i.get(r).__hasExternalTextures) {
              const e = Math.max(1, r.width >> h),
                i = Math.max(1, r.height >> h);
              c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY
                ? n.texImage3D(c, h, p, e, i, r.depth, 0, u, d, null)
                : n.texImage2D(c, h, p, e, i, 0, u, d, null);
            }
            n.bindFramebuffer(t.FRAMEBUFFER, e),
              et(r)
                ? l.framebufferTexture2DMultisampleEXT(
                    t.FRAMEBUFFER,
                    o,
                    c,
                    i.get(a).__webglTexture,
                    0,
                    tt(r)
                  )
                : (c === t.TEXTURE_2D ||
                    (c >= t.TEXTURE_CUBE_MAP_POSITIVE_X && c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                  t.framebufferTexture2D(t.FRAMEBUFFER, o, c, i.get(a).__webglTexture, h),
              n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
          function Q(e, n, i) {
            if ((t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer)) {
              let r = !0 === o ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
              if (i || et(n)) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === H
                    ? (r = t.DEPTH_COMPONENT32F)
                    : e.type === z && (r = t.DEPTH_COMPONENT24));
                const i = tt(n);
                et(n)
                  ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height)
                  : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height);
              } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
              t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e);
            } else if (n.depthBuffer && n.stencilBuffer) {
              const r = tt(n);
              i && !1 === et(n)
                ? t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    r,
                    t.DEPTH24_STENCIL8,
                    n.width,
                    n.height
                  )
                : et(n)
                ? l.renderbufferStorageMultisampleEXT(
                    t.RENDERBUFFER,
                    r,
                    t.DEPTH24_STENCIL8,
                    n.width,
                    n.height
                  )
                : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.RENDERBUFFER,
                  e
                );
            } else {
              const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
              for (let r = 0; r < e.length; r++) {
                const a = e[r],
                  o = s.convert(a.format, a.colorSpace),
                  c = s.convert(a.type),
                  h = x(a.internalFormat, o, c, a.colorSpace),
                  u = tt(n);
                i && !1 === et(n)
                  ? t.renderbufferStorageMultisample(t.RENDERBUFFER, u, h, n.width, n.height)
                  : et(n)
                  ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, u, h, n.width, n.height)
                  : t.renderbufferStorage(t.RENDERBUFFER, h, n.width, n.height);
              }
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null);
          }
          function $(e) {
            const r = i.get(e),
              s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
              if (s) throw new Error("target.depthTexture not supported in Cube render targets");
              !(function (e, r) {
                if (r && r.isWebGLCubeRenderTarget)
                  throw new Error("Depth Texture with cube render targets is not supported");
                if (
                  (n.bindFramebuffer(t.FRAMEBUFFER, e),
                  !r.depthTexture || !r.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (i.get(r.depthTexture).__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                  A(r.depthTexture, 0);
                const s = i.get(r.depthTexture).__webglTexture,
                  a = tt(r);
                if (r.depthTexture.format === j)
                  et(r)
                    ? l.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        t.DEPTH_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0,
                        a
                      )
                    : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                else {
                  if (r.depthTexture.format !== q) throw new Error("Unknown depthTexture format");
                  et(r)
                    ? l.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0,
                        a
                      )
                    : t.framebufferTexture2D(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                }
              })(r.__webglFramebuffer, e);
            } else if (s) {
              r.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++)
                n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
                  (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                  Q(r.__webglDepthbuffer[i], e, !1);
            } else
              n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
                (r.__webglDepthbuffer = t.createRenderbuffer()),
                Q(r.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
          function tt(t) {
            return Math.min(r.maxSamples, t.samples);
          }
          function et(t) {
            const n = i.get(t);
            return (
              o &&
              t.samples > 0 &&
              !0 === e.has("WEBGL_multisampled_render_to_texture") &&
              !1 !== n.__useRenderToTexture
            );
          }
          function nt(t, n) {
            const i = t.colorSpace,
              r = t.format,
              s = t.type;
            return (
              !0 === t.isCompressedTexture ||
                !0 === t.isVideoTexture ||
                t.format === Kt ||
                (i !== zt &&
                  i !== Bt &&
                  (Ae.getTransfer(i) === Vt
                    ? !1 === o
                      ? !0 === e.has("EXT_sRGB") && r === X
                        ? ((t.format = Kt), (t.minFilter = U), (t.generateMipmaps = !1))
                        : (n = Le.sRGBToLinear(n))
                      : (r === X && s === O) ||
                        console.warn(
                          "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                        )
                    : console.error("THREE.WebGLTextures: Unsupported texture color space:", i))),
              n
            );
          }
          (this.allocateTextureUnit = function () {
            const t = T;
            return (
              t >= r.maxTextures &&
                console.warn(
                  "THREE.WebGLTextures: Trying to use " +
                    t +
                    " texture units while this GPU supports only " +
                    r.maxTextures
                ),
              (T += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              T = 0;
            }),
            (this.setTexture2D = A),
            (this.setTexture2DArray = function (e, r) {
              const s = i.get(e);
              e.version > 0 && s.__version !== e.version
                ? Z(s, e, r)
                : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r);
            }),
            (this.setTexture3D = function (e, r) {
              const s = i.get(e);
              e.version > 0 && s.__version !== e.version
                ? Z(s, e, r)
                : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
            }),
            (this.setTextureCube = function (e, a) {
              const l = i.get(e);
              e.version > 0 && l.__version !== e.version
                ? (function (e, a, l) {
                    if (6 !== a.image.length) return;
                    const c = K(e, a),
                      h = a.source;
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + l);
                    const u = i.get(h);
                    if (h.version !== u.__version || !0 === c) {
                      n.activeTexture(t.TEXTURE0 + l);
                      const e = Ae.getPrimaries(Ae.workingColorSpace),
                        i = a.colorSpace === Bt ? null : Ae.getPrimaries(a.colorSpace),
                        d = a.colorSpace === Bt || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
                        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                        t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
                        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                      const p = a.isCompressedTexture || a.image[0].isCompressedTexture,
                        f = a.image[0] && a.image[0].isDataTexture,
                        M = [];
                      for (let t = 0; t < 6; t++)
                        (M[t] =
                          p || f
                            ? f
                              ? a.image[t].image
                              : a.image[t]
                            : m(a.image[t], !1, !0, r.maxCubemapSize)),
                          (M[t] = nt(a, M[t]));
                      const S = M[0],
                        b = g(S) || o,
                        E = s.convert(a.format, a.colorSpace),
                        T = s.convert(a.type),
                        A = x(a.internalFormat, E, T, a.colorSpace),
                        w = o && !0 !== a.isVideoTexture,
                        R = void 0 === u.__version || !0 === c;
                      let C,
                        L = y(a, S, b);
                      if ((Y(t.TEXTURE_CUBE_MAP, a, b), p)) {
                        w && R && n.texStorage2D(t.TEXTURE_CUBE_MAP, L, A, S.width, S.height);
                        for (let e = 0; e < 6; e++) {
                          C = M[e].mipmaps;
                          for (let i = 0; i < C.length; i++) {
                            const r = C[i];
                            a.format !== X
                              ? null !== E
                                ? w
                                  ? n.compressedTexSubImage2D(
                                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                      i,
                                      0,
                                      0,
                                      r.width,
                                      r.height,
                                      E,
                                      r.data
                                    )
                                  : n.compressedTexImage2D(
                                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                      i,
                                      A,
                                      r.width,
                                      r.height,
                                      0,
                                      r.data
                                    )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                  )
                              : w
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  0,
                                  0,
                                  r.width,
                                  r.height,
                                  E,
                                  T,
                                  r.data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  A,
                                  r.width,
                                  r.height,
                                  0,
                                  E,
                                  T,
                                  r.data
                                );
                          }
                        }
                      } else {
                        (C = a.mipmaps),
                          w &&
                            R &&
                            (C.length > 0 && L++,
                            n.texStorage2D(t.TEXTURE_CUBE_MAP, L, A, M[0].width, M[0].height));
                        for (let e = 0; e < 6; e++)
                          if (f) {
                            w
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  0,
                                  0,
                                  M[e].width,
                                  M[e].height,
                                  E,
                                  T,
                                  M[e].data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  A,
                                  M[e].width,
                                  M[e].height,
                                  0,
                                  E,
                                  T,
                                  M[e].data
                                );
                            for (let i = 0; i < C.length; i++) {
                              const r = C[i].image[e].image;
                              w
                                ? n.texSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    0,
                                    0,
                                    r.width,
                                    r.height,
                                    E,
                                    T,
                                    r.data
                                  )
                                : n.texImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    A,
                                    r.width,
                                    r.height,
                                    0,
                                    E,
                                    T,
                                    r.data
                                  );
                            }
                          } else {
                            w
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  0,
                                  0,
                                  E,
                                  T,
                                  M[e]
                                )
                              : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, A, E, T, M[e]);
                            for (let i = 0; i < C.length; i++) {
                              const r = C[i];
                              w
                                ? n.texSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    0,
                                    0,
                                    E,
                                    T,
                                    r.image[e]
                                  )
                                : n.texImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    A,
                                    E,
                                    T,
                                    r.image[e]
                                  );
                            }
                          }
                      }
                      _(a, b) && v(t.TEXTURE_CUBE_MAP),
                        (u.__version = h.version),
                        a.onUpdate && a.onUpdate(a);
                    }
                    e.__version = a.version;
                  })(l, e, a)
                : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + a);
            }),
            (this.rebindTextures = function (e, n, r) {
              const s = i.get(e);
              void 0 !== n &&
                J(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0),
                void 0 !== r && $(e);
            }),
            (this.setupRenderTarget = function (e) {
              const l = e.texture,
                c = i.get(e),
                h = i.get(l);
              e.addEventListener("dispose", b),
                !0 !== e.isWebGLMultipleRenderTargets &&
                  (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()),
                  (h.__version = l.version),
                  a.memory.textures++);
              const u = !0 === e.isWebGLCubeRenderTarget,
                d = !0 === e.isWebGLMultipleRenderTargets,
                p = g(e) || o;
              if (u) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  if (o && l.mipmaps && l.mipmaps.length > 0) {
                    c.__webglFramebuffer[e] = [];
                    for (let n = 0; n < l.mipmaps.length; n++)
                      c.__webglFramebuffer[e][n] = t.createFramebuffer();
                  } else c.__webglFramebuffer[e] = t.createFramebuffer();
              } else {
                if (o && l.mipmaps && l.mipmaps.length > 0) {
                  c.__webglFramebuffer = [];
                  for (let e = 0; e < l.mipmaps.length; e++)
                    c.__webglFramebuffer[e] = t.createFramebuffer();
                } else c.__webglFramebuffer = t.createFramebuffer();
                if (d)
                  if (r.drawBuffers) {
                    const n = e.texture;
                    for (let e = 0, r = n.length; e < r; e++) {
                      const r = i.get(n[e]);
                      void 0 === r.__webglTexture &&
                        ((r.__webglTexture = t.createTexture()), a.memory.textures++);
                    }
                  } else
                    console.warn(
                      "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                    );
                if (o && e.samples > 0 && !1 === et(e)) {
                  const i = d ? l : [l];
                  (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (c.__webglColorRenderbuffer = []),
                    n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                  for (let n = 0; n < i.length; n++) {
                    const r = i[n];
                    (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                      t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                    const a = s.convert(r.format, r.colorSpace),
                      o = s.convert(r.type),
                      l = x(r.internalFormat, a, o, r.colorSpace, !0 === e.isXRRenderTarget),
                      h = tt(e);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, h, l, e.width, e.height),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + n,
                        t.RENDERBUFFER,
                        c.__webglColorRenderbuffer[n]
                      );
                  }
                  t.bindRenderbuffer(t.RENDERBUFFER, null),
                    e.depthBuffer &&
                      ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      Q(c.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(t.FRAMEBUFFER, null);
                }
              }
              if (u) {
                n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), Y(t.TEXTURE_CUBE_MAP, l, p);
                for (let n = 0; n < 6; n++)
                  if (o && l.mipmaps && l.mipmaps.length > 0)
                    for (let i = 0; i < l.mipmaps.length; i++)
                      J(
                        c.__webglFramebuffer[n][i],
                        e,
                        l,
                        t.COLOR_ATTACHMENT0,
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        i
                      );
                  else
                    J(
                      c.__webglFramebuffer[n],
                      e,
                      l,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                      0
                    );
                _(l, p) && v(t.TEXTURE_CUBE_MAP), n.unbindTexture();
              } else if (d) {
                const r = e.texture;
                for (let s = 0, a = r.length; s < a; s++) {
                  const a = r[s],
                    o = i.get(a);
                  n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
                    Y(t.TEXTURE_2D, a, p),
                    J(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D, 0),
                    _(a, p) && v(t.TEXTURE_2D);
                }
                n.unbindTexture();
              } else {
                let i = t.TEXTURE_2D;
                if (
                  ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
                    (o
                      ? (i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY)
                      : console.error(
                          "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                        )),
                  n.bindTexture(i, h.__webglTexture),
                  Y(i, l, p),
                  o && l.mipmaps && l.mipmaps.length > 0)
                )
                  for (let n = 0; n < l.mipmaps.length; n++)
                    J(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
                else J(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
                _(l, p) && v(i), n.unbindTexture();
              }
              e.depthBuffer && $(e);
            }),
            (this.updateRenderTargetMipmap = function (e) {
              const r = g(e) || o,
                s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
              for (let a = 0, o = s.length; a < o; a++) {
                const o = s[a];
                if (_(o, r)) {
                  const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    s = i.get(o).__webglTexture;
                  n.bindTexture(r, s), v(r), n.unbindTexture();
                }
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (o && e.samples > 0 && !1 === et(e)) {
                const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
                  s = e.width,
                  a = e.height;
                let o = t.COLOR_BUFFER_BIT;
                const l = [],
                  h = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                  u = i.get(e),
                  d = !0 === e.isWebGLMultipleRenderTargets;
                if (d)
                  for (let e = 0; e < r.length; e++)
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.RENDERBUFFER,
                        null
                      ),
                      n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                      t.framebufferTexture2D(
                        t.DRAW_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.TEXTURE_2D,
                        null,
                        0
                      );
                n.bindFramebuffer(t.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                  n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                for (let n = 0; n < r.length; n++) {
                  l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(h);
                  const p = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                  if (
                    (!1 === p &&
                      (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT),
                      e.stencilBuffer && (o |= t.STENCIL_BUFFER_BIT)),
                    d &&
                      t.framebufferRenderbuffer(
                        t.READ_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0,
                        t.RENDERBUFFER,
                        u.__webglColorRenderbuffer[n]
                      ),
                    !0 === p &&
                      (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [h]),
                      t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [h])),
                    d)
                  ) {
                    const e = i.get(r[n]).__webglTexture;
                    t.framebufferTexture2D(
                      t.DRAW_FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_2D,
                      e,
                      0
                    );
                  }
                  t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST),
                    c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
                }
                if (
                  (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                  n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                  d)
                )
                  for (let e = 0; e < r.length; e++) {
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.RENDERBUFFER,
                        u.__webglColorRenderbuffer[e]
                      );
                    const s = i.get(r[e]).__webglTexture;
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                      t.framebufferTexture2D(
                        t.DRAW_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                  }
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer);
              }
            }),
            (this.setupDepthRenderbuffer = $),
            (this.setupFrameBufferTexture = J),
            (this.useMultisampledRTT = et);
        }
        function ka(t, e, n) {
          const i = n.isWebGL2;
          return {
            convert: function (n, r = "") {
              let s;
              const a = Ae.getTransfer(r);
              if (n === O) return t.UNSIGNED_BYTE;
              if (n === k) return t.UNSIGNED_SHORT_4_4_4_4;
              if (n === V) return t.UNSIGNED_SHORT_5_5_5_1;
              if (1010 === n) return t.BYTE;
              if (1011 === n) return t.SHORT;
              if (n === B) return t.UNSIGNED_SHORT;
              if (n === F) return t.INT;
              if (n === z) return t.UNSIGNED_INT;
              if (n === H) return t.FLOAT;
              if (n === G)
                return i
                  ? t.HALF_FLOAT
                  : ((s = e.get("OES_texture_half_float")), null !== s ? s.HALF_FLOAT_OES : null);
              if (1021 === n) return t.ALPHA;
              if (n === X) return t.RGBA;
              if (1024 === n) return t.LUMINANCE;
              if (1025 === n) return t.LUMINANCE_ALPHA;
              if (n === j) return t.DEPTH_COMPONENT;
              if (n === q) return t.DEPTH_STENCIL;
              if (n === Kt) return (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null;
              if (1028 === n) return t.RED;
              if (n === Y) return t.RED_INTEGER;
              if (1030 === n) return t.RG;
              if (n === K) return t.RG_INTEGER;
              if (n === Z) return t.RGBA_INTEGER;
              if (n === J || n === Q || n === $ || n === tt)
                if (a === Vt) {
                  if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === s)) return null;
                  if (n === J) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                  if (n === Q) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                  if (n === $) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                  if (n === tt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else {
                  if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s)) return null;
                  if (n === J) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (n === Q) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (n === $) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (n === tt) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
              if (n === et || n === nt || n === it || n === rt) {
                if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s)) return null;
                if (n === et) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === nt) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === it) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === rt) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (n === st)
                return (
                  (s = e.get("WEBGL_compressed_texture_etc1")),
                  null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
                );
              if (n === at || n === ot) {
                if (((s = e.get("WEBGL_compressed_texture_etc")), null === s)) return null;
                if (n === at) return a === Vt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === ot)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                    : s.COMPRESSED_RGBA8_ETC2_EAC;
              }
              if (
                n === lt ||
                n === ct ||
                n === ht ||
                n === ut ||
                n === dt ||
                n === pt ||
                n === ft ||
                n === mt ||
                n === gt ||
                n === _t ||
                n === vt ||
                n === xt ||
                n === yt ||
                n === Mt
              ) {
                if (((s = e.get("WEBGL_compressed_texture_astc")), null === s)) return null;
                if (n === lt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                    : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === ct)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                    : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === ht)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === ut)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === dt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === pt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === ft)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === mt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === gt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === _t)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === vt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === xt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === yt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                    : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Mt)
                  return a === Vt
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                    : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
              }
              if (n === St || n === bt || n === Et) {
                if (((s = e.get("EXT_texture_compression_bptc")), null === s)) return null;
                if (n === St)
                  return a === Vt
                    ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                    : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === bt) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Et) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
              }
              if (36283 === n || n === Tt || n === At || n === wt) {
                if (((s = e.get("EXT_texture_compression_rgtc")), null === s)) return null;
                if (n === St) return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === Tt) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === At) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === wt) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
              }
              return n === W
                ? i
                  ? t.UNSIGNED_INT_24_8
                  : ((s = e.get("WEBGL_depth_texture")),
                    null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0 !== t[n]
                ? t[n]
                : null;
            },
          };
        }
        class Va extends ir {
          constructor(t = []) {
            super(), (this.isArrayCamera = !0), (this.cameras = t);
          }
        }
        class Wa extends Wn {
          constructor() {
            super(), (this.isGroup = !0), (this.type = "Group");
          }
        }
        const Xa = { type: "move" };
        class ja {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new Wa()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new Wa()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new ke()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new ke())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new Wa()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new ke()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new ke())),
              this._grip
            );
          }
          dispatchEvent(t) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(t),
              null !== this._grip && this._grip.dispatchEvent(t),
              null !== this._hand && this._hand.dispatchEvent(t),
              this
            );
          }
          connect(t) {
            if (t && t.hand) {
              const e = this._hand;
              if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
            }
            return this.dispatchEvent({ type: "connected", data: t }), this;
          }
          disconnect(t) {
            return (
              this.dispatchEvent({ type: "disconnected", data: t }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(t, e, n) {
            let i = null,
              r = null,
              s = null;
            const a = this._targetRay,
              o = this._grip,
              l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState) {
              if (l && t.hand) {
                s = !0;
                for (const i of t.hand.values()) {
                  const t = e.getJointPose(i, n),
                    r = this._getHandJoint(l, i);
                  null !== t &&
                    (r.matrix.fromArray(t.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    (r.matrixWorldNeedsUpdate = !0),
                    (r.jointRadius = t.radius)),
                    (r.visible = null !== t);
                }
                const i = l.joints["index-finger-tip"],
                  r = l.joints["thumb-tip"],
                  a = i.position.distanceTo(r.position),
                  o = 0.02,
                  c = 0.005;
                l.inputState.pinching && a > o + c
                  ? ((l.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: t.handedness,
                      target: this,
                    }))
                  : !l.inputState.pinching &&
                    a <= o - c &&
                    ((l.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: t.handedness,
                      target: this,
                    }));
              } else
                null !== o &&
                  t.gripSpace &&
                  ((r = e.getPose(t.gripSpace, n)),
                  null !== r &&
                    (o.matrix.fromArray(r.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    (o.matrixWorldNeedsUpdate = !0),
                    r.linearVelocity
                      ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(r.linearVelocity))
                      : (o.hasLinearVelocity = !1),
                    r.angularVelocity
                      ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(r.angularVelocity))
                      : (o.hasAngularVelocity = !1)));
              null !== a &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null === i && null !== r && (i = r),
                null !== i &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  (a.matrixWorldNeedsUpdate = !0),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(Xa)));
            }
            return (
              null !== a && (a.visible = null !== i),
              null !== o && (o.visible = null !== r),
              null !== l && (l.visible = null !== s),
              this
            );
          }
          _getHandJoint(t, e) {
            if (void 0 === t.joints[e.jointName]) {
              const n = new Wa();
              (n.matrixAutoUpdate = !1), (n.visible = !1), (t.joints[e.jointName] = n), t.add(n);
            }
            return t.joints[e.jointName];
          }
        }
        class qa extends Qt {
          constructor(t, e) {
            super();
            const n = this;
            let i = null,
              r = 1,
              s = null,
              a = "local-floor",
              o = 1,
              l = null,
              c = null,
              h = null,
              u = null,
              d = null,
              p = null;
            const f = e.getContextAttributes();
            let m = null,
              g = null;
            const _ = [],
              v = [],
              x = new de();
            let y = null;
            const M = new ir();
            M.layers.enable(1), (M.viewport = new Oe());
            const S = new ir();
            S.layers.enable(2), (S.viewport = new Oe());
            const b = [M, S],
              E = new Va();
            E.layers.enable(1), E.layers.enable(2);
            let T = null,
              A = null;
            function w(t) {
              const e = v.indexOf(t.inputSource);
              if (-1 === e) return;
              const n = _[e];
              void 0 !== n &&
                (n.update(t.inputSource, t.frame, l || s),
                n.dispatchEvent({ type: t.type, data: t.inputSource }));
            }
            function R() {
              i.removeEventListener("select", w),
                i.removeEventListener("selectstart", w),
                i.removeEventListener("selectend", w),
                i.removeEventListener("squeeze", w),
                i.removeEventListener("squeezestart", w),
                i.removeEventListener("squeezeend", w),
                i.removeEventListener("end", R),
                i.removeEventListener("inputsourceschange", C);
              for (let t = 0; t < _.length; t++) {
                const e = v[t];
                null !== e && ((v[t] = null), _[t].disconnect(e));
              }
              (T = null),
                (A = null),
                t.setRenderTarget(m),
                (d = null),
                (u = null),
                (h = null),
                (i = null),
                (g = null),
                N.stop(),
                (n.isPresenting = !1),
                t.setPixelRatio(y),
                t.setSize(x.width, x.height, !1),
                n.dispatchEvent({ type: "sessionend" });
            }
            function C(t) {
              for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                  i = v.indexOf(n);
                i >= 0 && ((v[i] = null), _[i].disconnect(n));
              }
              for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e];
                let i = v.indexOf(n);
                if (-1 === i) {
                  for (let t = 0; t < _.length; t++) {
                    if (t >= v.length) {
                      v.push(n), (i = t);
                      break;
                    }
                    if (null === v[t]) {
                      (v[t] = n), (i = t);
                      break;
                    }
                  }
                  if (-1 === i) break;
                }
                const r = _[i];
                r && r.connect(n);
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (t) {
                let e = _[t];
                return void 0 === e && ((e = new ja()), (_[t] = e)), e.getTargetRaySpace();
              }),
              (this.getControllerGrip = function (t) {
                let e = _[t];
                return void 0 === e && ((e = new ja()), (_[t] = e)), e.getGripSpace();
              }),
              (this.getHand = function (t) {
                let e = _[t];
                return void 0 === e && ((e = new ja()), (_[t] = e)), e.getHandSpace();
              }),
              (this.setFramebufferScaleFactor = function (t) {
                (r = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (this.setReferenceSpaceType = function (t) {
                (a = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (this.getReferenceSpace = function () {
                return l || s;
              }),
              (this.setReferenceSpace = function (t) {
                l = t;
              }),
              (this.getBaseLayer = function () {
                return null !== u ? u : d;
              }),
              (this.getBinding = function () {
                return h;
              }),
              (this.getFrame = function () {
                return p;
              }),
              (this.getSession = function () {
                return i;
              }),
              (this.setSession = async function (c) {
                if (((i = c), null !== i)) {
                  if (
                    ((m = t.getRenderTarget()),
                    i.addEventListener("select", w),
                    i.addEventListener("selectstart", w),
                    i.addEventListener("selectend", w),
                    i.addEventListener("squeeze", w),
                    i.addEventListener("squeezestart", w),
                    i.addEventListener("squeezeend", w),
                    i.addEventListener("end", R),
                    i.addEventListener("inputsourceschange", C),
                    !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                    (y = t.getPixelRatio()),
                    t.getSize(x),
                    void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2)
                  ) {
                    const n = {
                      antialias: void 0 !== i.renderState.layers || f.antialias,
                      alpha: !0,
                      depth: f.depth,
                      stencil: f.stencil,
                      framebufferScaleFactor: r,
                    };
                    (d = new XRWebGLLayer(i, e, n)),
                      i.updateRenderState({ baseLayer: d }),
                      t.setPixelRatio(1),
                      t.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                      (g = new Fe(d.framebufferWidth, d.framebufferHeight, {
                        format: X,
                        type: O,
                        colorSpace: t.outputColorSpace,
                        stencilBuffer: f.stencil,
                      }));
                  } else {
                    let n = null,
                      s = null,
                      a = null;
                    f.depth &&
                      ((a = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                      (n = f.stencil ? q : j),
                      (s = f.stencil ? W : z));
                    const o = { colorFormat: e.RGBA8, depthFormat: a, scaleFactor: r };
                    (h = new XRWebGLBinding(i, e)),
                      (u = h.createProjectionLayer(o)),
                      i.updateRenderState({ layers: [u] }),
                      t.setPixelRatio(1),
                      t.setSize(u.textureWidth, u.textureHeight, !1),
                      (g = new Fe(u.textureWidth, u.textureHeight, {
                        format: X,
                        type: O,
                        depthTexture: new Qr(
                          u.textureWidth,
                          u.textureHeight,
                          s,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          n
                        ),
                        stencilBuffer: f.stencil,
                        colorSpace: t.outputColorSpace,
                        samples: f.antialias ? 4 : 0,
                      })),
                      (t.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues);
                  }
                  (g.isXRRenderTarget = !0),
                    this.setFoveation(o),
                    (l = null),
                    (s = await i.requestReferenceSpace(a)),
                    N.setContext(i),
                    N.start(),
                    (n.isPresenting = !0),
                    n.dispatchEvent({ type: "sessionstart" });
                }
              }),
              (this.getEnvironmentBlendMode = function () {
                if (null !== i) return i.environmentBlendMode;
              });
            const L = new ke(),
              P = new ke();
            function I(t, e) {
              null === e
                ? t.matrixWorld.copy(t.matrix)
                : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
            }
            (this.updateCamera = function (t) {
              if (null === i) return;
              (E.near = S.near = M.near = t.near),
                (E.far = S.far = M.far = t.far),
                (T === E.near && A === E.far) ||
                  (i.updateRenderState({ depthNear: E.near, depthFar: E.far }),
                  (T = E.near),
                  (A = E.far));
              const e = t.parent,
                n = E.cameras;
              I(E, e);
              for (let t = 0; t < n.length; t++) I(n[t], e);
              2 === n.length
                ? (function (t, e, n) {
                    L.setFromMatrixPosition(e.matrixWorld), P.setFromMatrixPosition(n.matrixWorld);
                    const i = L.distanceTo(P),
                      r = e.projectionMatrix.elements,
                      s = n.projectionMatrix.elements,
                      a = r[14] / (r[10] - 1),
                      o = r[14] / (r[10] + 1),
                      l = (r[9] + 1) / r[5],
                      c = (r[9] - 1) / r[5],
                      h = (r[8] - 1) / r[0],
                      u = (s[8] + 1) / s[0],
                      d = a * h,
                      p = a * u,
                      f = i / (-h + u),
                      m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                      t.translateX(m),
                      t.translateZ(f),
                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                      t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = a + f,
                      _ = o + f,
                      v = d - m,
                      x = p + (i - m),
                      y = ((l * o) / _) * g,
                      M = ((c * o) / _) * g;
                    t.projectionMatrix.makePerspective(v, x, y, M, g, _),
                      t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
                  })(E, M, S)
                : E.projectionMatrix.copy(M.projectionMatrix),
                (function (t, e, n) {
                  null === n
                    ? t.matrix.copy(e.matrixWorld)
                    : (t.matrix.copy(n.matrixWorld),
                      t.matrix.invert(),
                      t.matrix.multiply(e.matrixWorld)),
                    t.matrix.decompose(t.position, t.quaternion, t.scale),
                    t.updateMatrixWorld(!0),
                    t.projectionMatrix.copy(e.projectionMatrix),
                    t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                    t.isPerspectiveCamera &&
                      ((t.fov = 2 * ne * Math.atan(1 / t.projectionMatrix.elements[5])),
                      (t.zoom = 1));
                })(t, E, e);
            }),
              (this.getCamera = function () {
                return E;
              }),
              (this.getFoveation = function () {
                if (null !== u || null !== d) return o;
              }),
              (this.setFoveation = function (t) {
                (o = t),
                  null !== u && (u.fixedFoveation = t),
                  null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
              });
            let U = null;
            const N = new mr();
            N.setAnimationLoop(function (e, i) {
              if (((c = i.getViewerPose(l || s)), (p = i), null !== c)) {
                const e = c.views;
                null !== d &&
                  (t.setRenderTargetFramebuffer(g, d.framebuffer), t.setRenderTarget(g));
                let n = !1;
                e.length !== E.cameras.length && ((E.cameras.length = 0), (n = !0));
                for (let i = 0; i < e.length; i++) {
                  const r = e[i];
                  let s = null;
                  if (null !== d) s = d.getViewport(r);
                  else {
                    const e = h.getViewSubImage(u, r);
                    (s = e.viewport),
                      0 === i &&
                        (t.setRenderTargetTextures(
                          g,
                          e.colorTexture,
                          u.ignoreDepthValues ? void 0 : e.depthStencilTexture
                        ),
                        t.setRenderTarget(g));
                  }
                  let a = b[i];
                  void 0 === a &&
                    ((a = new ir()), a.layers.enable(i), (a.viewport = new Oe()), (b[i] = a)),
                    a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.quaternion, a.scale),
                    a.projectionMatrix.fromArray(r.projectionMatrix),
                    a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                    a.viewport.set(s.x, s.y, s.width, s.height),
                    0 === i &&
                      (E.matrix.copy(a.matrix),
                      E.matrix.decompose(E.position, E.quaternion, E.scale)),
                    !0 === n && E.cameras.push(a);
                }
              }
              for (let t = 0; t < _.length; t++) {
                const e = v[t],
                  n = _[t];
                null !== e && void 0 !== n && n.update(e, i, l || s);
              }
              U && U(e, i),
                i.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: i }),
                (p = null);
            }),
              (this.setAnimationLoop = function (t) {
                U = t;
              }),
              (this.dispose = function () {});
          }
        }
        function Ya(t, e) {
          function n(t, e) {
            !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
          }
          function i(i, r) {
            (i.opacity.value = r.opacity),
              r.color && i.diffuse.value.copy(r.color),
              r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
              r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
              r.alphaMap && ((i.alphaMap.value = r.alphaMap), n(r.alphaMap, i.alphaMapTransform)),
              r.bumpMap &&
                ((i.bumpMap.value = r.bumpMap),
                n(r.bumpMap, i.bumpMapTransform),
                (i.bumpScale.value = r.bumpScale),
                1 === r.side && (i.bumpScale.value *= -1)),
              r.normalMap &&
                ((i.normalMap.value = r.normalMap),
                n(r.normalMap, i.normalMapTransform),
                i.normalScale.value.copy(r.normalScale),
                1 === r.side && i.normalScale.value.negate()),
              r.displacementMap &&
                ((i.displacementMap.value = r.displacementMap),
                n(r.displacementMap, i.displacementMapTransform),
                (i.displacementScale.value = r.displacementScale),
                (i.displacementBias.value = r.displacementBias)),
              r.emissiveMap &&
                ((i.emissiveMap.value = r.emissiveMap), n(r.emissiveMap, i.emissiveMapTransform)),
              r.specularMap &&
                ((i.specularMap.value = r.specularMap), n(r.specularMap, i.specularMapTransform)),
              r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
            const s = e.get(r).envMap;
            if (
              (s &&
                ((i.envMap.value = s),
                (i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
                (i.reflectivity.value = r.reflectivity),
                (i.ior.value = r.ior),
                (i.refractionRatio.value = r.refractionRatio)),
              r.lightMap)
            ) {
              i.lightMap.value = r.lightMap;
              const e = !0 === t._useLegacyLights ? Math.PI : 1;
              (i.lightMapIntensity.value = r.lightMapIntensity * e),
                n(r.lightMap, i.lightMapTransform);
            }
            r.aoMap &&
              ((i.aoMap.value = r.aoMap),
              (i.aoMapIntensity.value = r.aoMapIntensity),
              n(r.aoMap, i.aoMapTransform));
          }
          return {
            refreshFogUniforms: function (e, n) {
              n.color.getRGB(e.fogColor.value, $i(t)),
                n.isFog
                  ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
                  : n.isFogExp2 && (e.fogDensity.value = n.density);
            },
            refreshMaterialUniforms: function (t, r, s, a, o) {
              r.isMeshBasicMaterial || r.isMeshLambertMaterial
                ? i(t, r)
                : r.isMeshToonMaterial
                ? (i(t, r),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                  })(t, r))
                : r.isMeshPhongMaterial
                ? (i(t, r),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4));
                  })(t, r))
                : r.isMeshStandardMaterial
                ? (i(t, r),
                  (function (t, i) {
                    (t.metalness.value = i.metalness),
                      i.metalnessMap &&
                        ((t.metalnessMap.value = i.metalnessMap),
                        n(i.metalnessMap, t.metalnessMapTransform)),
                      (t.roughness.value = i.roughness),
                      i.roughnessMap &&
                        ((t.roughnessMap.value = i.roughnessMap),
                        n(i.roughnessMap, t.roughnessMapTransform));
                    e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity);
                  })(t, r),
                  r.isMeshPhysicalMaterial &&
                    (function (t, e, i) {
                      (t.ior.value = e.ior),
                        e.sheen > 0 &&
                          (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                          (t.sheenRoughness.value = e.sheenRoughness),
                          e.sheenColorMap &&
                            ((t.sheenColorMap.value = e.sheenColorMap),
                            n(e.sheenColorMap, t.sheenColorMapTransform)),
                          e.sheenRoughnessMap &&
                            ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                            n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
                        e.clearcoat > 0 &&
                          ((t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.clearcoatMap &&
                            ((t.clearcoatMap.value = e.clearcoatMap),
                            n(e.clearcoatMap, t.clearcoatMapTransform)),
                          e.clearcoatRoughnessMap &&
                            ((t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                            n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)),
                          e.clearcoatNormalMap &&
                            ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                            n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                            t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                            1 === e.side && t.clearcoatNormalScale.value.negate())),
                        e.iridescence > 0 &&
                          ((t.iridescence.value = e.iridescence),
                          (t.iridescenceIOR.value = e.iridescenceIOR),
                          (t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0]),
                          (t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1]),
                          e.iridescenceMap &&
                            ((t.iridescenceMap.value = e.iridescenceMap),
                            n(e.iridescenceMap, t.iridescenceMapTransform)),
                          e.iridescenceThicknessMap &&
                            ((t.iridescenceThicknessMap.value = e.iridescenceThicknessMap),
                            n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))),
                        e.transmission > 0 &&
                          ((t.transmission.value = e.transmission),
                          (t.transmissionSamplerMap.value = i.texture),
                          t.transmissionSamplerSize.value.set(i.width, i.height),
                          e.transmissionMap &&
                            ((t.transmissionMap.value = e.transmissionMap),
                            n(e.transmissionMap, t.transmissionMapTransform)),
                          (t.thickness.value = e.thickness),
                          e.thicknessMap &&
                            ((t.thicknessMap.value = e.thicknessMap),
                            n(e.thicknessMap, t.thicknessMapTransform)),
                          (t.attenuationDistance.value = e.attenuationDistance),
                          t.attenuationColor.value.copy(e.attenuationColor)),
                        e.anisotropy > 0 &&
                          (t.anisotropyVector.value.set(
                            e.anisotropy * Math.cos(e.anisotropyRotation),
                            e.anisotropy * Math.sin(e.anisotropyRotation)
                          ),
                          e.anisotropyMap &&
                            ((t.anisotropyMap.value = e.anisotropyMap),
                            n(e.anisotropyMap, t.anisotropyMapTransform))),
                        (t.specularIntensity.value = e.specularIntensity),
                        t.specularColor.value.copy(e.specularColor),
                        e.specularColorMap &&
                          ((t.specularColorMap.value = e.specularColorMap),
                          n(e.specularColorMap, t.specularColorMapTransform)),
                        e.specularIntensityMap &&
                          ((t.specularIntensityMap.value = e.specularIntensityMap),
                          n(e.specularIntensityMap, t.specularIntensityMapTransform));
                    })(t, r, o))
                : r.isMeshMatcapMaterial
                ? (i(t, r),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                  })(t, r))
                : r.isMeshDepthMaterial
                ? i(t, r)
                : r.isMeshDistanceMaterial
                ? (i(t, r),
                  (function (t, n) {
                    const i = e.get(n).light;
                    t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                      (t.nearDistance.value = i.shadow.camera.near),
                      (t.farDistance.value = i.shadow.camera.far);
                  })(t, r))
                : r.isMeshNormalMaterial
                ? i(t, r)
                : r.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
                  })(t, r),
                  r.isLineDashedMaterial &&
                    (function (t, e) {
                      (t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale);
                    })(t, r))
                : r.isPointsMaterial
                ? (function (t, e, i, r) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * i),
                      (t.scale.value = 0.5 * r),
                      e.map && ((t.map.value = e.map), n(e.map, t.uvTransform)),
                      e.alphaMap &&
                        ((t.alphaMap.value = e.alphaMap), n(e.alphaMap, t.alphaMapTransform)),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                  })(t, r, s, a)
                : r.isSpriteMaterial
                ? (function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && ((t.map.value = e.map), n(e.map, t.mapTransform)),
                      e.alphaMap &&
                        ((t.alphaMap.value = e.alphaMap), n(e.alphaMap, t.alphaMapTransform)),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                  })(t, r)
                : r.isShadowMaterial
                ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
                : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
            },
          };
        }
        function Ka(t, e, n, i) {
          let r = {},
            s = {},
            a = [];
          const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
          function l(t, e, n, i) {
            const r = t.value,
              s = e + "_" + n;
            if (void 0 === i[s])
              return (i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone()), !0;
            {
              const t = i[s];
              if ("number" == typeof r || "boolean" == typeof r) {
                if (t !== r) return (i[s] = r), !0;
              } else if (!1 === t.equals(r)) return t.copy(r), !0;
            }
            return !1;
          }
          function c(t) {
            const e = { boundary: 0, storage: 0 };
            return (
              "number" == typeof t || "boolean" == typeof t
                ? ((e.boundary = 4), (e.storage = 4))
                : t.isVector2
                ? ((e.boundary = 8), (e.storage = 8))
                : t.isVector3 || t.isColor
                ? ((e.boundary = 16), (e.storage = 12))
                : t.isVector4
                ? ((e.boundary = 16), (e.storage = 16))
                : t.isMatrix3
                ? ((e.boundary = 48), (e.storage = 48))
                : t.isMatrix4
                ? ((e.boundary = 64), (e.storage = 64))
                : t.isTexture
                ? console.warn(
                    "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                  )
                : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t),
              e
            );
          }
          function h(e) {
            const n = e.target;
            n.removeEventListener("dispose", h);
            const i = a.indexOf(n.__bindingPointIndex);
            a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
          }
          return {
            bind: function (t, e) {
              const n = e.program;
              i.uniformBlockBinding(t, n);
            },
            update: function (n, u) {
              let d = r[n.id];
              void 0 === d &&
                ((function (t) {
                  const e = t.uniforms;
                  let n = 0;
                  for (let t = 0, i = e.length; t < i; t++) {
                    const i = Array.isArray(e[t]) ? e[t] : [e[t]];
                    for (let t = 0, e = i.length; t < e; t++) {
                      const e = i[t],
                        r = Array.isArray(e.value) ? e.value : [e.value];
                      for (let t = 0, i = r.length; t < i; t++) {
                        const i = c(r[t]),
                          s = n % 16;
                        0 !== s && 16 - s < i.boundary && (n += 16 - s),
                          (e.__data = new Float32Array(i.storage / Float32Array.BYTES_PER_ELEMENT)),
                          (e.__offset = n),
                          (n += i.storage);
                      }
                    }
                  }
                  const i = n % 16;
                  i > 0 && (n += 16 - i), (t.__size = n), (t.__cache = {});
                })(n),
                (d = (function (e) {
                  const n = (function () {
                    for (let t = 0; t < o; t++) if (-1 === a.indexOf(t)) return a.push(t), t;
                    return (
                      console.error(
                        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                      ),
                      0
                    );
                  })();
                  e.__bindingPointIndex = n;
                  const i = t.createBuffer(),
                    r = e.__size,
                    s = e.usage;
                  return (
                    t.bindBuffer(t.UNIFORM_BUFFER, i),
                    t.bufferData(t.UNIFORM_BUFFER, r, s),
                    t.bindBuffer(t.UNIFORM_BUFFER, null),
                    t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                    i
                  );
                })(n)),
                (r[n.id] = d),
                n.addEventListener("dispose", h));
              const p = u.program;
              i.updateUBOMapping(n, p);
              const f = e.render.frame;
              s[n.id] !== f &&
                ((function (e) {
                  const n = r[e.id],
                    i = e.uniforms,
                    s = e.__cache;
                  t.bindBuffer(t.UNIFORM_BUFFER, n);
                  for (let e = 0, n = i.length; e < n; e++) {
                    const n = Array.isArray(i[e]) ? i[e] : [i[e]];
                    for (let i = 0, r = n.length; i < r; i++) {
                      const r = n[i];
                      if (!0 === l(r, e, i, s)) {
                        const e = r.__offset,
                          n = Array.isArray(r.value) ? r.value : [r.value];
                        let i = 0;
                        for (let s = 0; s < n.length; s++) {
                          const a = n[s],
                            o = c(a);
                          "number" == typeof a || "boolean" == typeof a
                            ? ((r.__data[0] = a),
                              t.bufferSubData(t.UNIFORM_BUFFER, e + i, r.__data))
                            : a.isMatrix3
                            ? ((r.__data[0] = a.elements[0]),
                              (r.__data[1] = a.elements[1]),
                              (r.__data[2] = a.elements[2]),
                              (r.__data[3] = 0),
                              (r.__data[4] = a.elements[3]),
                              (r.__data[5] = a.elements[4]),
                              (r.__data[6] = a.elements[5]),
                              (r.__data[7] = 0),
                              (r.__data[8] = a.elements[6]),
                              (r.__data[9] = a.elements[7]),
                              (r.__data[10] = a.elements[8]),
                              (r.__data[11] = 0))
                            : (a.toArray(r.__data, i),
                              (i += o.storage / Float32Array.BYTES_PER_ELEMENT));
                        }
                        t.bufferSubData(t.UNIFORM_BUFFER, e, r.__data);
                      }
                    }
                  }
                  t.bindBuffer(t.UNIFORM_BUFFER, null);
                })(n),
                (s[n.id] = f));
            },
            dispose: function () {
              for (const e in r) t.deleteBuffer(r[e]);
              (a = []), (r = {}), (s = {});
            },
          };
        }
        class Za {
          constructor(t = {}) {
            const {
              canvas: e = xe(),
              context: i = null,
              depth: r = !0,
              stencil: s = !0,
              alpha: a = !1,
              antialias: o = !1,
              premultipliedAlpha: l = !0,
              preserveDrawingBuffer: c = !1,
              powerPreference: h = "default",
              failIfMajorPerformanceCaveat: u = !1,
            } = t;
            let p;
            (this.isWebGLRenderer = !0), (p = null !== i ? i.getContextAttributes().alpha : a);
            const f = new Uint32Array(4),
              m = new Int32Array(4);
            let g = null,
              _ = null;
            const v = [],
              x = [];
            (this.domElement = e),
              (this.debug = { checkShaderErrors: !0, onShaderError: null }),
              (this.autoClear = !0),
              (this.autoClearColor = !0),
              (this.autoClearDepth = !0),
              (this.autoClearStencil = !0),
              (this.sortObjects = !0),
              (this.clippingPlanes = []),
              (this.localClippingEnabled = !1),
              (this._outputColorSpace = Ft),
              (this._useLegacyLights = !1),
              (this.toneMapping = d),
              (this.toneMappingExposure = 1);
            const y = this;
            let M = !1,
              S = 0,
              b = 0,
              E = null,
              T = -1,
              A = null;
            const w = new Oe(),
              R = new Oe();
            let C = null;
            const L = new oi(0);
            let P = 0,
              I = e.width,
              U = e.height,
              N = 1,
              F = null,
              j = null;
            const q = new Oe(0, 0, I, U),
              J = new Oe(0, 0, I, U);
            let Q = !1;
            const $ = new fr();
            let tt = !1,
              et = !1,
              nt = null;
            const it = new xn(),
              rt = new de(),
              st = new ke(),
              at = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0,
              };
            function ot() {
              return null === E ? N : 1;
            }
            let lt,
              ct,
              ht,
              ut,
              dt,
              pt,
              ft,
              mt,
              gt,
              _t,
              vt,
              xt,
              yt,
              Mt,
              St,
              bt,
              Et,
              Tt,
              At,
              wt,
              Rt,
              Ct,
              Lt,
              Pt,
              It = i;
            function Ut(t, n) {
              for (let i = 0; i < t.length; i++) {
                const r = t[i],
                  s = e.getContext(r, n);
                if (null !== s) return s;
              }
              return null;
            }
            try {
              const t = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: o,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: h,
                failIfMajorPerformanceCaveat: u,
              };
              if (
                ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${n}`),
                e.addEventListener("webglcontextlost", Ot, !1),
                e.addEventListener("webglcontextrestored", Bt, !1),
                e.addEventListener("webglcontextcreationerror", Ht, !1),
                null === It)
              ) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if ((!0 === y.isWebGL1Renderer && e.shift(), (It = Ut(e, t)), null === It))
                  throw Ut(e)
                    ? new Error("Error creating WebGL context with your selected attributes.")
                    : new Error("Error creating WebGL context.");
              }
              "undefined" != typeof WebGLRenderingContext &&
                It instanceof WebGLRenderingContext &&
                console.warn(
                  "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
                ),
                void 0 === It.getShaderPrecisionFormat &&
                  (It.getShaderPrecisionFormat = function () {
                    return { rangeMin: 1, rangeMax: 1, precision: 1 };
                  });
            } catch (t) {
              throw (console.error("THREE.WebGLRenderer: " + t.message), t);
            }
            function Nt() {
              (lt = new Wr(It)),
                (ct = new Tr(It, lt, t)),
                lt.init(ct),
                (Ct = new ka(It, lt, ct)),
                (ht = new Ha(It, lt, ct)),
                (ut = new qr(It)),
                (dt = new Aa()),
                (pt = new Ga(It, lt, ht, dt, ct, Ct, ut)),
                (ft = new wr(y)),
                (mt = new Vr(y)),
                (gt = new gr(It, ct)),
                (Lt = new br(It, lt, gt, ct)),
                (_t = new Xr(It, gt, ut, Lt)),
                (vt = new Jr(It, _t, gt, ut)),
                (At = new Zr(It, ct, pt)),
                (bt = new Ar(dt)),
                (xt = new Ta(y, ft, mt, lt, ct, Lt, bt)),
                (yt = new Ya(y, dt)),
                (Mt = new La()),
                (St = new Oa(lt, ct)),
                (Tt = new Sr(y, ft, mt, ht, vt, p, l)),
                (Et = new za(y, vt, ct)),
                (Pt = new Ka(It, ut, ct, ht)),
                (wt = new Er(It, lt, ut, ct)),
                (Rt = new jr(It, lt, ut, ct)),
                (ut.programs = xt.programs),
                (y.capabilities = ct),
                (y.extensions = lt),
                (y.properties = dt),
                (y.renderLists = Mt),
                (y.shadowMap = Et),
                (y.state = ht),
                (y.info = ut);
            }
            Nt();
            const Dt = new qa(y, It);
            function Ot(t) {
              t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (M = !0);
            }
            function Bt() {
              console.log("THREE.WebGLRenderer: Context Restored."), (M = !1);
              const t = ut.autoReset,
                e = Et.enabled,
                n = Et.autoUpdate,
                i = Et.needsUpdate,
                r = Et.type;
              Nt(),
                (ut.autoReset = t),
                (Et.enabled = e),
                (Et.autoUpdate = n),
                (Et.needsUpdate = i),
                (Et.type = r);
            }
            function Ht(t) {
              console.error(
                "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
                t.statusMessage
              );
            }
            function Gt(t) {
              const e = t.target;
              e.removeEventListener("dispose", Gt),
                (function (t) {
                  (function (t) {
                    const e = dt.get(t).programs;
                    void 0 !== e &&
                      (e.forEach(function (t) {
                        xt.releaseProgram(t);
                      }),
                      t.isShaderMaterial && xt.releaseShaderCache(t));
                  })(t),
                    dt.remove(t);
                })(e);
            }
            function kt(t, e, n) {
              !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
                ? ((t.side = 1),
                  (t.needsUpdate = !0),
                  Jt(t, e, n),
                  (t.side = 0),
                  (t.needsUpdate = !0),
                  Jt(t, e, n),
                  (t.side = 2))
                : Jt(t, e, n);
            }
            (this.xr = Dt),
              (this.getContext = function () {
                return It;
              }),
              (this.getContextAttributes = function () {
                return It.getContextAttributes();
              }),
              (this.forceContextLoss = function () {
                const t = lt.get("WEBGL_lose_context");
                t && t.loseContext();
              }),
              (this.forceContextRestore = function () {
                const t = lt.get("WEBGL_lose_context");
                t && t.restoreContext();
              }),
              (this.getPixelRatio = function () {
                return N;
              }),
              (this.setPixelRatio = function (t) {
                void 0 !== t && ((N = t), this.setSize(I, U, !1));
              }),
              (this.getSize = function (t) {
                return t.set(I, U);
              }),
              (this.setSize = function (t, n, i = !0) {
                Dt.isPresenting
                  ? console.warn(
                      "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                    )
                  : ((I = t),
                    (U = n),
                    (e.width = Math.floor(t * N)),
                    (e.height = Math.floor(n * N)),
                    !0 === i && ((e.style.width = t + "px"), (e.style.height = n + "px")),
                    this.setViewport(0, 0, t, n));
              }),
              (this.getDrawingBufferSize = function (t) {
                return t.set(I * N, U * N).floor();
              }),
              (this.setDrawingBufferSize = function (t, n, i) {
                (I = t),
                  (U = n),
                  (N = i),
                  (e.width = Math.floor(t * i)),
                  (e.height = Math.floor(n * i)),
                  this.setViewport(0, 0, t, n);
              }),
              (this.getCurrentViewport = function (t) {
                return t.copy(w);
              }),
              (this.getViewport = function (t) {
                return t.copy(q);
              }),
              (this.setViewport = function (t, e, n, i) {
                t.isVector4 ? q.set(t.x, t.y, t.z, t.w) : q.set(t, e, n, i),
                  ht.viewport(w.copy(q).multiplyScalar(N).floor());
              }),
              (this.getScissor = function (t) {
                return t.copy(J);
              }),
              (this.setScissor = function (t, e, n, i) {
                t.isVector4 ? J.set(t.x, t.y, t.z, t.w) : J.set(t, e, n, i),
                  ht.scissor(R.copy(J).multiplyScalar(N).floor());
              }),
              (this.getScissorTest = function () {
                return Q;
              }),
              (this.setScissorTest = function (t) {
                ht.setScissorTest((Q = t));
              }),
              (this.setOpaqueSort = function (t) {
                F = t;
              }),
              (this.setTransparentSort = function (t) {
                j = t;
              }),
              (this.getClearColor = function (t) {
                return t.copy(Tt.getClearColor());
              }),
              (this.setClearColor = function () {
                Tt.setClearColor.apply(Tt, arguments);
              }),
              (this.getClearAlpha = function () {
                return Tt.getClearAlpha();
              }),
              (this.setClearAlpha = function () {
                Tt.setClearAlpha.apply(Tt, arguments);
              }),
              (this.clear = function (t = !0, e = !0, n = !0) {
                let i = 0;
                if (t) {
                  let t = !1;
                  if (null !== E) {
                    const e = E.texture.format;
                    t = e === Z || e === K || e === Y;
                  }
                  if (t) {
                    const t = E.texture.type,
                      e = t === O || t === z || t === B || t === W || t === k || t === V,
                      n = Tt.getClearColor(),
                      i = Tt.getClearAlpha(),
                      r = n.r,
                      s = n.g,
                      a = n.b;
                    e
                      ? ((f[0] = r),
                        (f[1] = s),
                        (f[2] = a),
                        (f[3] = i),
                        It.clearBufferuiv(It.COLOR, 0, f))
                      : ((m[0] = r),
                        (m[1] = s),
                        (m[2] = a),
                        (m[3] = i),
                        It.clearBufferiv(It.COLOR, 0, m));
                  } else i |= It.COLOR_BUFFER_BIT;
                }
                e && (i |= It.DEPTH_BUFFER_BIT),
                  n &&
                    ((i |= It.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)),
                  It.clear(i);
              }),
              (this.clearColor = function () {
                this.clear(!0, !1, !1);
              }),
              (this.clearDepth = function () {
                this.clear(!1, !0, !1);
              }),
              (this.clearStencil = function () {
                this.clear(!1, !1, !0);
              }),
              (this.dispose = function () {
                e.removeEventListener("webglcontextlost", Ot, !1),
                  e.removeEventListener("webglcontextrestored", Bt, !1),
                  e.removeEventListener("webglcontextcreationerror", Ht, !1),
                  Mt.dispose(),
                  St.dispose(),
                  dt.dispose(),
                  ft.dispose(),
                  mt.dispose(),
                  vt.dispose(),
                  Lt.dispose(),
                  Pt.dispose(),
                  xt.dispose(),
                  Dt.dispose(),
                  Dt.removeEventListener("sessionstart", Wt),
                  Dt.removeEventListener("sessionend", Xt),
                  nt && (nt.dispose(), (nt = null)),
                  jt.stop();
              }),
              (this.renderBufferDirect = function (t, e, n, i, r, s) {
                null === e && (e = at);
                const a = r.isMesh && r.matrixWorld.determinant() < 0,
                  o = (function (t, e, n, i, r) {
                    !0 !== e.isScene && (e = at), pt.resetTextureUnits();
                    const s = e.fog,
                      a = i.isMeshStandardMaterial ? e.environment : null,
                      o =
                        null === E
                          ? y.outputColorSpace
                          : !0 === E.isXRRenderTarget
                          ? E.texture.colorSpace
                          : zt,
                      l = (i.isMeshStandardMaterial ? mt : ft).get(i.envMap || a),
                      c =
                        !0 === i.vertexColors &&
                        !!n.attributes.color &&
                        4 === n.attributes.color.itemSize,
                      h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                      u = !!n.morphAttributes.position,
                      p = !!n.morphAttributes.normal,
                      f = !!n.morphAttributes.color;
                    let m = d;
                    i.toneMapped &&
                      ((null !== E && !0 !== E.isXRRenderTarget) || (m = y.toneMapping));
                    const g =
                        n.morphAttributes.position ||
                        n.morphAttributes.normal ||
                        n.morphAttributes.color,
                      v = void 0 !== g ? g.length : 0,
                      x = dt.get(i),
                      M = _.state.lights;
                    if (!0 === tt && (!0 === et || t !== A)) {
                      const e = t === A && i.id === T;
                      bt.setState(i, t, e);
                    }
                    let S = !1;
                    i.version === x.__version
                      ? (x.needsLights && x.lightsStateVersion !== M.state.version) ||
                        x.outputColorSpace !== o ||
                        (r.isBatchedMesh && !1 === x.batching)
                        ? (S = !0)
                        : r.isBatchedMesh || !0 !== x.batching
                        ? r.isInstancedMesh && !1 === x.instancing
                          ? (S = !0)
                          : r.isInstancedMesh || !0 !== x.instancing
                          ? r.isSkinnedMesh && !1 === x.skinning
                            ? (S = !0)
                            : r.isSkinnedMesh || !0 !== x.skinning
                            ? (r.isInstancedMesh &&
                                !0 === x.instancingColor &&
                                null === r.instanceColor) ||
                              (r.isInstancedMesh &&
                                !1 === x.instancingColor &&
                                null !== r.instanceColor) ||
                              x.envMap !== l ||
                              (!0 === i.fog && x.fog !== s)
                              ? (S = !0)
                              : void 0 === x.numClippingPlanes ||
                                (x.numClippingPlanes === bt.numPlanes &&
                                  x.numIntersection === bt.numIntersection)
                              ? (x.vertexAlphas !== c ||
                                  x.vertexTangents !== h ||
                                  x.morphTargets !== u ||
                                  x.morphNormals !== p ||
                                  x.morphColors !== f ||
                                  x.toneMapping !== m ||
                                  (!0 === ct.isWebGL2 && x.morphTargetsCount !== v)) &&
                                (S = !0)
                              : (S = !0)
                            : (S = !0)
                          : (S = !0)
                        : (S = !0)
                      : ((S = !0), (x.__version = i.version));
                    let b = x.currentProgram;
                    !0 === S && (b = Jt(i, e, r));
                    let w = !1,
                      R = !1,
                      C = !1;
                    const L = b.getUniforms(),
                      P = x.uniforms;
                    if (
                      (ht.useProgram(b.program) && ((w = !0), (R = !0), (C = !0)),
                      i.id !== T && ((T = i.id), (R = !0)),
                      w || A !== t)
                    ) {
                      L.setValue(It, "projectionMatrix", t.projectionMatrix),
                        L.setValue(It, "viewMatrix", t.matrixWorldInverse);
                      const e = L.map.cameraPosition;
                      void 0 !== e && e.setValue(It, st.setFromMatrixPosition(t.matrixWorld)),
                        ct.logarithmicDepthBuffer &&
                          L.setValue(It, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                        (i.isMeshPhongMaterial ||
                          i.isMeshToonMaterial ||
                          i.isMeshLambertMaterial ||
                          i.isMeshBasicMaterial ||
                          i.isMeshStandardMaterial ||
                          i.isShaderMaterial) &&
                          L.setValue(It, "isOrthographic", !0 === t.isOrthographicCamera),
                        A !== t && ((A = t), (R = !0), (C = !0));
                    }
                    if (r.isSkinnedMesh) {
                      L.setOptional(It, r, "bindMatrix"), L.setOptional(It, r, "bindMatrixInverse");
                      const t = r.skeleton;
                      t &&
                        (ct.floatVertexTextures
                          ? (null === t.boneTexture && t.computeBoneTexture(),
                            L.setValue(It, "boneTexture", t.boneTexture, pt))
                          : console.warn(
                              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                            ));
                    }
                    r.isBatchedMesh &&
                      (L.setOptional(It, r, "batchingTexture"),
                      L.setValue(It, "batchingTexture", r._matricesTexture, pt));
                    const I = n.morphAttributes;
                    var D, O;
                    if (
                      ((void 0 !== I.position ||
                        void 0 !== I.normal ||
                        (void 0 !== I.color && !0 === ct.isWebGL2)) &&
                        At.update(r, n, b),
                      (R || x.receiveShadow !== r.receiveShadow) &&
                        ((x.receiveShadow = r.receiveShadow),
                        L.setValue(It, "receiveShadow", r.receiveShadow)),
                      i.isMeshGouraudMaterial &&
                        null !== i.envMap &&
                        ((P.envMap.value = l),
                        (P.flipEnvMap.value =
                          l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1)),
                      R &&
                        (L.setValue(It, "toneMappingExposure", y.toneMappingExposure),
                        x.needsLights &&
                          ((O = C),
                          ((D = P).ambientLightColor.needsUpdate = O),
                          (D.lightProbe.needsUpdate = O),
                          (D.directionalLights.needsUpdate = O),
                          (D.directionalLightShadows.needsUpdate = O),
                          (D.pointLights.needsUpdate = O),
                          (D.pointLightShadows.needsUpdate = O),
                          (D.spotLights.needsUpdate = O),
                          (D.spotLightShadows.needsUpdate = O),
                          (D.rectAreaLights.needsUpdate = O),
                          (D.hemisphereLights.needsUpdate = O)),
                        s && !0 === i.fog && yt.refreshFogUniforms(P, s),
                        yt.refreshMaterialUniforms(P, i, N, U, nt),
                        ia.upload(It, Qt(x), P, pt)),
                      i.isShaderMaterial &&
                        !0 === i.uniformsNeedUpdate &&
                        (ia.upload(It, Qt(x), P, pt), (i.uniformsNeedUpdate = !1)),
                      i.isSpriteMaterial && L.setValue(It, "center", r.center),
                      L.setValue(It, "modelViewMatrix", r.modelViewMatrix),
                      L.setValue(It, "normalMatrix", r.normalMatrix),
                      L.setValue(It, "modelMatrix", r.matrixWorld),
                      i.isShaderMaterial || i.isRawShaderMaterial)
                    ) {
                      const t = i.uniformsGroups;
                      for (let e = 0, n = t.length; e < n; e++)
                        if (ct.isWebGL2) {
                          const n = t[e];
                          Pt.update(n, b), Pt.bind(n, b);
                        } else
                          console.warn(
                            "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                          );
                    }
                    return b;
                  })(t, e, n, i, r);
                ht.setMaterial(i, a);
                let l = n.index,
                  c = 1;
                if (!0 === i.wireframe) {
                  if (((l = _t.getWireframeAttribute(n)), void 0 === l)) return;
                  c = 2;
                }
                const h = n.drawRange,
                  u = n.attributes.position;
                let p = h.start * c,
                  f = (h.start + h.count) * c;
                null !== s &&
                  ((p = Math.max(p, s.start * c)), (f = Math.min(f, (s.start + s.count) * c))),
                  null !== l
                    ? ((p = Math.max(p, 0)), (f = Math.min(f, l.count)))
                    : null != u && ((p = Math.max(p, 0)), (f = Math.min(f, u.count)));
                const m = f - p;
                if (m < 0 || m === 1 / 0) return;
                let g;
                Lt.setup(r, i, o, n, l);
                let v = wt;
                if ((null !== l && ((g = gt.get(l)), (v = Rt), v.setIndex(g)), r.isMesh))
                  !0 === i.wireframe
                    ? (ht.setLineWidth(i.wireframeLinewidth * ot()), v.setMode(It.LINES))
                    : v.setMode(It.TRIANGLES);
                else if (r.isLine) {
                  let t = i.linewidth;
                  void 0 === t && (t = 1),
                    ht.setLineWidth(t * ot()),
                    r.isLineSegments
                      ? v.setMode(It.LINES)
                      : r.isLineLoop
                      ? v.setMode(It.LINE_LOOP)
                      : v.setMode(It.LINE_STRIP);
                } else r.isPoints ? v.setMode(It.POINTS) : r.isSprite && v.setMode(It.TRIANGLES);
                if (r.isBatchedMesh)
                  v.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                else if (r.isInstancedMesh) v.renderInstances(p, m, r.count);
                else if (n.isInstancedBufferGeometry) {
                  const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                    e = Math.min(n.instanceCount, t);
                  v.renderInstances(p, m, e);
                } else v.render(p, m);
              }),
              (this.compile = function (t, e, n = null) {
                null === n && (n = t),
                  (_ = St.get(n)),
                  _.init(),
                  x.push(_),
                  n.traverseVisible(function (t) {
                    t.isLight &&
                      t.layers.test(e.layers) &&
                      (_.pushLight(t), t.castShadow && _.pushShadow(t));
                  }),
                  t !== n &&
                    t.traverseVisible(function (t) {
                      t.isLight &&
                        t.layers.test(e.layers) &&
                        (_.pushLight(t), t.castShadow && _.pushShadow(t));
                    }),
                  _.setupLights(y._useLegacyLights);
                const i = new Set();
                return (
                  t.traverse(function (t) {
                    const e = t.material;
                    if (e)
                      if (Array.isArray(e))
                        for (let r = 0; r < e.length; r++) {
                          const s = e[r];
                          kt(s, n, t), i.add(s);
                        }
                      else kt(e, n, t), i.add(e);
                  }),
                  x.pop(),
                  (_ = null),
                  i
                );
              }),
              (this.compileAsync = function (t, e, n = null) {
                const i = this.compile(t, e, n);
                return new Promise((e) => {
                  function n() {
                    i.forEach(function (t) {
                      dt.get(t).currentProgram.isReady() && i.delete(t);
                    }),
                      0 !== i.size ? setTimeout(n, 10) : e(t);
                  }
                  null !== lt.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10);
                });
              });
            let Vt = null;
            function Wt() {
              jt.stop();
            }
            function Xt() {
              jt.start();
            }
            const jt = new mr();
            function qt(t, e, n, i) {
              if (!1 === t.visible) return;
              if (t.layers.test(e.layers))
                if (t.isGroup) n = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight) _.pushLight(t), t.castShadow && _.pushShadow(t);
                else if (t.isSprite) {
                  if (!t.frustumCulled || $.intersectsSprite(t)) {
                    i && st.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                    const e = vt.update(t),
                      r = t.material;
                    r.visible && g.push(t, e, r, n, st.z, null);
                  }
                } else if (
                  (t.isMesh || t.isLine || t.isPoints) &&
                  (!t.frustumCulled || $.intersectsObject(t))
                ) {
                  const e = vt.update(t),
                    r = t.material;
                  if (
                    (i &&
                      (void 0 !== t.boundingSphere
                        ? (null === t.boundingSphere && t.computeBoundingSphere(),
                          st.copy(t.boundingSphere.center))
                        : (null === e.boundingSphere && e.computeBoundingSphere(),
                          st.copy(e.boundingSphere.center)),
                      st.applyMatrix4(t.matrixWorld).applyMatrix4(it)),
                    Array.isArray(r))
                  ) {
                    const i = e.groups;
                    for (let s = 0, a = i.length; s < a; s++) {
                      const a = i[s],
                        o = r[a.materialIndex];
                      o && o.visible && g.push(t, e, o, n, st.z, a);
                    }
                  } else r.visible && g.push(t, e, r, n, st.z, null);
                }
              const r = t.children;
              for (let t = 0, s = r.length; t < s; t++) qt(r[t], e, n, i);
            }
            function Yt(t, e, n, i) {
              const r = t.opaque,
                s = t.transmissive,
                a = t.transparent;
              _.setupLightsView(n),
                !0 === tt && bt.setGlobalState(y.clippingPlanes, n),
                s.length > 0 &&
                  (function (t, e, n, i) {
                    if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
                    const r = ct.isWebGL2;
                    null === nt &&
                      (nt = new Fe(1, 1, {
                        generateMipmaps: !0,
                        type: lt.has("EXT_color_buffer_half_float") ? G : O,
                        minFilter: D,
                        samples: r ? 4 : 0,
                      })),
                      y.getDrawingBufferSize(rt),
                      r ? nt.setSize(rt.x, rt.y) : nt.setSize(le(rt.x), le(rt.y));
                    const s = y.getRenderTarget();
                    y.setRenderTarget(nt),
                      y.getClearColor(L),
                      (P = y.getClearAlpha()),
                      P < 1 && y.setClearColor(16777215, 0.5),
                      y.clear();
                    const a = y.toneMapping;
                    (y.toneMapping = d),
                      Kt(t, n, i),
                      pt.updateMultisampleRenderTarget(nt),
                      pt.updateRenderTargetMipmap(nt);
                    let o = !1;
                    for (let t = 0, r = e.length; t < r; t++) {
                      const r = e[t],
                        s = r.object,
                        a = r.geometry,
                        l = r.material,
                        c = r.group;
                      if (2 === l.side && s.layers.test(i.layers)) {
                        const t = l.side;
                        (l.side = 1),
                          (l.needsUpdate = !0),
                          Zt(s, n, i, a, l, c),
                          (l.side = t),
                          (l.needsUpdate = !0),
                          (o = !0);
                      }
                    }
                    !0 === o &&
                      (pt.updateMultisampleRenderTarget(nt), pt.updateRenderTargetMipmap(nt)),
                      y.setRenderTarget(s),
                      y.setClearColor(L, P),
                      (y.toneMapping = a);
                  })(r, s, e, n),
                i && ht.viewport(w.copy(i)),
                r.length > 0 && Kt(r, e, n),
                s.length > 0 && Kt(s, e, n),
                a.length > 0 && Kt(a, e, n),
                ht.buffers.depth.setTest(!0),
                ht.buffers.depth.setMask(!0),
                ht.buffers.color.setMask(!0),
                ht.setPolygonOffset(!1);
            }
            function Kt(t, e, n) {
              const i = !0 === e.isScene ? e.overrideMaterial : null;
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = s.object,
                  o = s.geometry,
                  l = null === i ? s.material : i,
                  c = s.group;
                a.layers.test(n.layers) && Zt(a, e, n, o, l, c);
              }
            }
            function Zt(t, e, n, i, r, s) {
              t.onBeforeRender(y, e, n, i, r, s),
                t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                r.onBeforeRender(y, e, n, i, t, s),
                !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
                  ? ((r.side = 1),
                    (r.needsUpdate = !0),
                    y.renderBufferDirect(n, e, i, r, t, s),
                    (r.side = 0),
                    (r.needsUpdate = !0),
                    y.renderBufferDirect(n, e, i, r, t, s),
                    (r.side = 2))
                  : y.renderBufferDirect(n, e, i, r, t, s),
                t.onAfterRender(y, e, n, i, r, s);
            }
            function Jt(t, e, n) {
              !0 !== e.isScene && (e = at);
              const i = dt.get(t),
                r = _.state.lights,
                s = _.state.shadowsArray,
                a = r.state.version,
                o = xt.getParameters(t, r.state, s, e, n),
                l = xt.getProgramCacheKey(o);
              let c = i.programs;
              (i.environment = t.isMeshStandardMaterial ? e.environment : null),
                (i.fog = e.fog),
                (i.envMap = (t.isMeshStandardMaterial ? mt : ft).get(t.envMap || i.environment)),
                void 0 === c &&
                  (t.addEventListener("dispose", Gt), (c = new Map()), (i.programs = c));
              let h = c.get(l);
              if (void 0 !== h) {
                if (i.currentProgram === h && i.lightsStateVersion === a) return $t(t, o), h;
              } else
                (o.uniforms = xt.getUniforms(t)),
                  t.onBuild(n, o, y),
                  t.onBeforeCompile(o, y),
                  (h = xt.acquireProgram(o, l)),
                  c.set(l, h),
                  (i.uniforms = o.uniforms);
              const u = i.uniforms;
              return (
                ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
                  (u.clippingPlanes = bt.uniform),
                $t(t, o),
                (i.needsLights = (function (t) {
                  return (
                    t.isMeshLambertMaterial ||
                    t.isMeshToonMaterial ||
                    t.isMeshPhongMaterial ||
                    t.isMeshStandardMaterial ||
                    t.isShadowMaterial ||
                    (t.isShaderMaterial && !0 === t.lights)
                  );
                })(t)),
                (i.lightsStateVersion = a),
                i.needsLights &&
                  ((u.ambientLightColor.value = r.state.ambient),
                  (u.lightProbe.value = r.state.probe),
                  (u.directionalLights.value = r.state.directional),
                  (u.directionalLightShadows.value = r.state.directionalShadow),
                  (u.spotLights.value = r.state.spot),
                  (u.spotLightShadows.value = r.state.spotShadow),
                  (u.rectAreaLights.value = r.state.rectArea),
                  (u.ltc_1.value = r.state.rectAreaLTC1),
                  (u.ltc_2.value = r.state.rectAreaLTC2),
                  (u.pointLights.value = r.state.point),
                  (u.pointLightShadows.value = r.state.pointShadow),
                  (u.hemisphereLights.value = r.state.hemi),
                  (u.directionalShadowMap.value = r.state.directionalShadowMap),
                  (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
                  (u.spotShadowMap.value = r.state.spotShadowMap),
                  (u.spotLightMatrix.value = r.state.spotLightMatrix),
                  (u.spotLightMap.value = r.state.spotLightMap),
                  (u.pointShadowMap.value = r.state.pointShadowMap),
                  (u.pointShadowMatrix.value = r.state.pointShadowMatrix)),
                (i.currentProgram = h),
                (i.uniformsList = null),
                h
              );
            }
            function Qt(t) {
              if (null === t.uniformsList) {
                const e = t.currentProgram.getUniforms();
                t.uniformsList = ia.seqWithValue(e.seq, t.uniforms);
              }
              return t.uniformsList;
            }
            function $t(t, e) {
              const n = dt.get(t);
              (n.outputColorSpace = e.outputColorSpace),
                (n.batching = e.batching),
                (n.instancing = e.instancing),
                (n.instancingColor = e.instancingColor),
                (n.skinning = e.skinning),
                (n.morphTargets = e.morphTargets),
                (n.morphNormals = e.morphNormals),
                (n.morphColors = e.morphColors),
                (n.morphTargetsCount = e.morphTargetsCount),
                (n.numClippingPlanes = e.numClippingPlanes),
                (n.numIntersection = e.numClipIntersection),
                (n.vertexAlphas = e.vertexAlphas),
                (n.vertexTangents = e.vertexTangents),
                (n.toneMapping = e.toneMapping);
            }
            jt.setAnimationLoop(function (t) {
              Vt && Vt(t);
            }),
              "undefined" != typeof self && jt.setContext(self),
              (this.setAnimationLoop = function (t) {
                (Vt = t), Dt.setAnimationLoop(t), null === t ? jt.stop() : jt.start();
              }),
              Dt.addEventListener("sessionstart", Wt),
              Dt.addEventListener("sessionend", Xt),
              (this.render = function (t, e) {
                if (void 0 !== e && !0 !== e.isCamera)
                  return void console.error(
                    "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                  );
                if (!0 === M) return;
                !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                  null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                  !0 === Dt.enabled &&
                    !0 === Dt.isPresenting &&
                    (!0 === Dt.cameraAutoUpdate && Dt.updateCamera(e), (e = Dt.getCamera())),
                  !0 === t.isScene && t.onBeforeRender(y, t, e, E),
                  (_ = St.get(t, x.length)),
                  _.init(),
                  x.push(_),
                  it.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                  $.setFromProjectionMatrix(it),
                  (et = this.localClippingEnabled),
                  (tt = bt.init(this.clippingPlanes, et)),
                  (g = Mt.get(t, v.length)),
                  g.init(),
                  v.push(g),
                  qt(t, e, 0, y.sortObjects),
                  g.finish(),
                  !0 === y.sortObjects && g.sort(F, j),
                  this.info.render.frame++,
                  !0 === tt && bt.beginShadows();
                const n = _.state.shadowsArray;
                if (
                  (Et.render(n, t, e),
                  !0 === tt && bt.endShadows(),
                  !0 === this.info.autoReset && this.info.reset(),
                  Tt.render(g, t),
                  _.setupLights(y._useLegacyLights),
                  e.isArrayCamera)
                ) {
                  const n = e.cameras;
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    Yt(g, t, i, i.viewport);
                  }
                } else Yt(g, t, e);
                null !== E && (pt.updateMultisampleRenderTarget(E), pt.updateRenderTargetMipmap(E)),
                  !0 === t.isScene && t.onAfterRender(y, t, e),
                  Lt.resetDefaultState(),
                  (T = -1),
                  (A = null),
                  x.pop(),
                  (_ = x.length > 0 ? x[x.length - 1] : null),
                  v.pop(),
                  (g = v.length > 0 ? v[v.length - 1] : null);
              }),
              (this.getActiveCubeFace = function () {
                return S;
              }),
              (this.getActiveMipmapLevel = function () {
                return b;
              }),
              (this.getRenderTarget = function () {
                return E;
              }),
              (this.setRenderTargetTextures = function (t, e, n) {
                (dt.get(t.texture).__webglTexture = e), (dt.get(t.depthTexture).__webglTexture = n);
                const i = dt.get(t);
                (i.__hasExternalTextures = !0),
                  i.__hasExternalTextures &&
                    ((i.__autoAllocateDepthBuffer = void 0 === n),
                    i.__autoAllocateDepthBuffer ||
                      (!0 === lt.has("WEBGL_multisampled_render_to_texture") &&
                        (console.warn(
                          "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                        ),
                        (i.__useRenderToTexture = !1))));
              }),
              (this.setRenderTargetFramebuffer = function (t, e) {
                const n = dt.get(t);
                (n.__webglFramebuffer = e), (n.__useDefaultFramebuffer = void 0 === e);
              }),
              (this.setRenderTarget = function (t, e = 0, n = 0) {
                (E = t), (S = e), (b = n);
                let i = !0,
                  r = null,
                  s = !1,
                  a = !1;
                if (t) {
                  const o = dt.get(t);
                  void 0 !== o.__useDefaultFramebuffer
                    ? (ht.bindFramebuffer(It.FRAMEBUFFER, null), (i = !1))
                    : void 0 === o.__webglFramebuffer
                    ? pt.setupRenderTarget(t)
                    : o.__hasExternalTextures &&
                      pt.rebindTextures(
                        t,
                        dt.get(t.texture).__webglTexture,
                        dt.get(t.depthTexture).__webglTexture
                      );
                  const l = t.texture;
                  (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) &&
                    (a = !0);
                  const c = dt.get(t).__webglFramebuffer;
                  t.isWebGLCubeRenderTarget
                    ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
                    : (r =
                        ct.isWebGL2 && t.samples > 0 && !1 === pt.useMultisampledRTT(t)
                          ? dt.get(t).__webglMultisampledFramebuffer
                          : Array.isArray(c)
                          ? c[n]
                          : c),
                    w.copy(t.viewport),
                    R.copy(t.scissor),
                    (C = t.scissorTest);
                } else
                  w.copy(q).multiplyScalar(N).floor(), R.copy(J).multiplyScalar(N).floor(), (C = Q);
                if (
                  (ht.bindFramebuffer(It.FRAMEBUFFER, r) &&
                    ct.drawBuffers &&
                    i &&
                    ht.drawBuffers(t, r),
                  ht.viewport(w),
                  ht.scissor(R),
                  ht.setScissorTest(C),
                  s)
                ) {
                  const i = dt.get(t.texture);
                  It.framebufferTexture2D(
                    It.FRAMEBUFFER,
                    It.COLOR_ATTACHMENT0,
                    It.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    i.__webglTexture,
                    n
                  );
                } else if (a) {
                  const i = dt.get(t.texture),
                    r = e || 0;
                  It.framebufferTextureLayer(
                    It.FRAMEBUFFER,
                    It.COLOR_ATTACHMENT0,
                    i.__webglTexture,
                    n || 0,
                    r
                  );
                }
                T = -1;
              }),
              (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
                if (!t || !t.isWebGLRenderTarget)
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                  );
                let o = dt.get(t).__webglFramebuffer;
                if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
                  ht.bindFramebuffer(It.FRAMEBUFFER, o);
                  try {
                    const a = t.texture,
                      o = a.format,
                      l = a.type;
                    if (
                      o !== X &&
                      Ct.convert(o) !== It.getParameter(It.IMPLEMENTATION_COLOR_READ_FORMAT)
                    )
                      return void console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                      );
                    const c =
                      l === G &&
                      (lt.has("EXT_color_buffer_half_float") ||
                        (ct.isWebGL2 && lt.has("EXT_color_buffer_float")));
                    if (
                      !(
                        l === O ||
                        Ct.convert(l) === It.getParameter(It.IMPLEMENTATION_COLOR_READ_TYPE) ||
                        (l === H &&
                          (ct.isWebGL2 ||
                            lt.has("OES_texture_float") ||
                            lt.has("WEBGL_color_buffer_float"))) ||
                        c
                      )
                    )
                      return void console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                      );
                    e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      It.readPixels(e, n, i, r, Ct.convert(o), Ct.convert(l), s);
                  } finally {
                    const t = null !== E ? dt.get(E).__webglFramebuffer : null;
                    ht.bindFramebuffer(It.FRAMEBUFFER, t);
                  }
                }
              }),
              (this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n),
                  r = Math.floor(e.image.width * i),
                  s = Math.floor(e.image.height * i);
                pt.setTexture2D(e, 0),
                  It.copyTexSubImage2D(It.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
                  ht.unbindTexture();
              }),
              (this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width,
                  s = e.image.height,
                  a = Ct.convert(n.format),
                  o = Ct.convert(n.type);
                pt.setTexture2D(n, 0),
                  It.pixelStorei(It.UNPACK_FLIP_Y_WEBGL, n.flipY),
                  It.pixelStorei(It.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                  It.pixelStorei(It.UNPACK_ALIGNMENT, n.unpackAlignment),
                  e.isDataTexture
                    ? It.texSubImage2D(It.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data)
                    : e.isCompressedTexture
                    ? It.compressedTexSubImage2D(
                        It.TEXTURE_2D,
                        i,
                        t.x,
                        t.y,
                        e.mipmaps[0].width,
                        e.mipmaps[0].height,
                        a,
                        e.mipmaps[0].data
                      )
                    : It.texSubImage2D(It.TEXTURE_2D, i, t.x, t.y, a, o, e.image),
                  0 === i && n.generateMipmaps && It.generateMipmap(It.TEXTURE_2D),
                  ht.unbindTexture();
              }),
              (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                if (y.isWebGL1Renderer)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                  );
                const s = t.max.x - t.min.x + 1,
                  a = t.max.y - t.min.y + 1,
                  o = t.max.z - t.min.z + 1,
                  l = Ct.convert(i.format),
                  c = Ct.convert(i.type);
                let h;
                if (i.isData3DTexture) pt.setTexture3D(i, 0), (h = It.TEXTURE_3D);
                else {
                  if (!i.isDataArrayTexture && !i.isCompressedArrayTexture)
                    return void console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                    );
                  pt.setTexture2DArray(i, 0), (h = It.TEXTURE_2D_ARRAY);
                }
                It.pixelStorei(It.UNPACK_FLIP_Y_WEBGL, i.flipY),
                  It.pixelStorei(It.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                  It.pixelStorei(It.UNPACK_ALIGNMENT, i.unpackAlignment);
                const u = It.getParameter(It.UNPACK_ROW_LENGTH),
                  d = It.getParameter(It.UNPACK_IMAGE_HEIGHT),
                  p = It.getParameter(It.UNPACK_SKIP_PIXELS),
                  f = It.getParameter(It.UNPACK_SKIP_ROWS),
                  m = It.getParameter(It.UNPACK_SKIP_IMAGES),
                  g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
                It.pixelStorei(It.UNPACK_ROW_LENGTH, g.width),
                  It.pixelStorei(It.UNPACK_IMAGE_HEIGHT, g.height),
                  It.pixelStorei(It.UNPACK_SKIP_PIXELS, t.min.x),
                  It.pixelStorei(It.UNPACK_SKIP_ROWS, t.min.y),
                  It.pixelStorei(It.UNPACK_SKIP_IMAGES, t.min.z),
                  n.isDataTexture || n.isData3DTexture
                    ? It.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data)
                    : n.isCompressedArrayTexture
                    ? (console.warn(
                        "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                      ),
                      It.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data))
                    : It.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g),
                  It.pixelStorei(It.UNPACK_ROW_LENGTH, u),
                  It.pixelStorei(It.UNPACK_IMAGE_HEIGHT, d),
                  It.pixelStorei(It.UNPACK_SKIP_PIXELS, p),
                  It.pixelStorei(It.UNPACK_SKIP_ROWS, f),
                  It.pixelStorei(It.UNPACK_SKIP_IMAGES, m),
                  0 === r && i.generateMipmaps && It.generateMipmap(h),
                  ht.unbindTexture();
              }),
              (this.initTexture = function (t) {
                t.isCubeTexture
                  ? pt.setTextureCube(t, 0)
                  : t.isData3DTexture
                  ? pt.setTexture3D(t, 0)
                  : t.isDataArrayTexture || t.isCompressedArrayTexture
                  ? pt.setTexture2DArray(t, 0)
                  : pt.setTexture2D(t, 0),
                  ht.unbindTexture();
              }),
              (this.resetState = function () {
                (S = 0), (b = 0), (E = null), ht.reset(), Lt.reset();
              }),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
          get coordinateSystem() {
            return Zt;
          }
          get outputColorSpace() {
            return this._outputColorSpace;
          }
          set outputColorSpace(t) {
            this._outputColorSpace = t;
            const e = this.getContext();
            (e.drawingBufferColorSpace = t === Ht ? "display-p3" : "srgb"),
              (e.unpackColorSpace = Ae.workingColorSpace === Gt ? "display-p3" : "srgb");
          }
          get outputEncoding() {
            return (
              console.warn(
                "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
              ),
              this.outputColorSpace === Ft ? Ot : Dt
            );
          }
          set outputEncoding(t) {
            console.warn(
              "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
            ),
              (this.outputColorSpace = t === Ot ? Ft : zt);
          }
          get useLegacyLights() {
            return (
              console.warn(
                "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
              ),
              this._useLegacyLights
            );
          }
          set useLegacyLights(t) {
            console.warn(
              "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
            ),
              (this._useLegacyLights = t);
          }
        }
        class Ja extends Za {}
        Ja.prototype.isWebGL1Renderer = !0;
        class Qa {
          constructor(t, e = 25e-5) {
            (this.isFogExp2 = !0), (this.name = ""), (this.color = new oi(t)), (this.density = e);
          }
          clone() {
            return new Qa(this.color, this.density);
          }
          toJSON() {
            return {
              type: "FogExp2",
              name: this.name,
              color: this.color.getHex(),
              density: this.density,
            };
          }
        }
        class $a {
          constructor(t, e = 1, n = 1e3) {
            (this.isFog = !0),
              (this.name = ""),
              (this.color = new oi(t)),
              (this.near = e),
              (this.far = n);
          }
          clone() {
            return new $a(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: "Fog",
              name: this.name,
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        }
        class to extends Wn {
          constructor() {
            super(),
              (this.isScene = !0),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.backgroundBlurriness = 0),
              (this.backgroundIntensity = 1),
              (this.overrideMaterial = null),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment && (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              (this.backgroundBlurriness = t.backgroundBlurriness),
              (this.backgroundIntensity = t.backgroundIntensity),
              null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              this.backgroundBlurriness > 0 &&
                (e.object.backgroundBlurriness = this.backgroundBlurriness),
              1 !== this.backgroundIntensity &&
                (e.object.backgroundIntensity = this.backgroundIntensity),
              e
            );
          }
        }
        class eo {
          constructor(t, e) {
            (this.isInterleavedBuffer = !0),
              (this.array = t),
              (this.stride = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.usage = qt),
              (this._updateRange = { offset: 0, count: -1 }),
              (this.updateRanges = []),
              (this.version = 0),
              (this.uuid = ie());
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          get updateRange() {
            return (
              console.warn(
                "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
              ),
              this._updateRange
            );
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          addUpdateRange(t, e) {
            this.updateRanges.push({ start: t, count: e });
          }
          clearUpdateRanges() {
            this.updateRanges.length = 0;
          }
          copy(t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ie()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
              n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n;
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          toJSON(t) {
            return (
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ie()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
                  new Uint32Array(this.array.buffer)
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        }
        const no = new ke();
        class io {
          constructor(t, e, n, i = !1) {
            (this.isInterleavedBufferAttribute = !0),
              (this.name = ""),
              (this.data = t),
              (this.itemSize = e),
              (this.offset = n),
              (this.normalized = i);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(t) {
            this.data.needsUpdate = t;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
              no.fromBufferAttribute(this, e), no.applyMatrix4(t), this.setXYZ(e, no.x, no.y, no.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              no.fromBufferAttribute(this, e),
                no.applyNormalMatrix(t),
                this.setXYZ(e, no.x, no.y, no.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              no.fromBufferAttribute(this, e),
                no.transformDirection(t),
                this.setXYZ(e, no.x, no.y, no.z);
            return this;
          }
          setX(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset] = e),
              this
            );
          }
          setY(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          }
          setZ(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          }
          setW(t, e) {
            return (
              this.normalized && (e = he(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          }
          getX(t) {
            let e = this.data.array[t * this.data.stride + this.offset];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          getY(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 1];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          getZ(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 2];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          getW(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 3];
            return this.normalized && (e = ce(e, this.array)), e;
          }
          setXY(t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized && ((e = he(e, this.array)), (n = he(n, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = he(e, this.array)), (n = he(n, this.array)), (i = he(i, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = he(e, this.array)),
                (n = he(n, this.array)),
                (i = he(i, this.array)),
                (r = he(r, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              (this.data.array[t + 3] = r),
              this
            );
          }
          clone(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
              }
              return new xi(new this.array.constructor(t), this.itemSize, this.normalized);
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new io(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          }
          toJSON(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          }
        }
        class ro extends hi {
          constructor(t) {
            super(),
              (this.isSpriteMaterial = !0),
              (this.type = "SpriteMaterial"),
              (this.color = new oi(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.rotation = 0),
              (this.sizeAttenuation = !0),
              (this.transparent = !0),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.rotation = t.rotation),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.fog = t.fog),
              this
            );
          }
        }
        let so;
        const ao = new ke(),
          oo = new ke(),
          lo = new ke(),
          co = new de(),
          ho = new de(),
          uo = new xn(),
          po = new ke(),
          fo = new ke(),
          mo = new ke(),
          go = new de(),
          _o = new de(),
          vo = new de();
        class xo extends Wn {
          constructor(t = new ro()) {
            if ((super(), (this.isSprite = !0), (this.type = "Sprite"), void 0 === so)) {
              so = new Li();
              const t = new Float32Array([
                  -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
                ]),
                e = new eo(t, 5);
              so.setIndex([0, 1, 2, 0, 2, 3]),
                so.setAttribute("position", new io(e, 3, 0, !1)),
                so.setAttribute("uv", new io(e, 2, 3, !1));
            }
            (this.geometry = so), (this.material = t), (this.center = new de(0.5, 0.5));
          }
          raycast(t, e) {
            null === t.camera &&
              console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
              ),
              oo.setFromMatrixScale(this.matrixWorld),
              uo.copy(t.camera.matrixWorld),
              this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
              lo.setFromMatrixPosition(this.modelViewMatrix),
              t.camera.isPerspectiveCamera &&
                !1 === this.material.sizeAttenuation &&
                oo.multiplyScalar(-lo.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
            const s = this.center;
            yo(po.set(-0.5, -0.5, 0), lo, s, oo, i, r),
              yo(fo.set(0.5, -0.5, 0), lo, s, oo, i, r),
              yo(mo.set(0.5, 0.5, 0), lo, s, oo, i, r),
              go.set(0, 0),
              _o.set(1, 0),
              vo.set(1, 1);
            let a = t.ray.intersectTriangle(po, fo, mo, !1, ao);
            if (
              null === a &&
              (yo(fo.set(-0.5, 0.5, 0), lo, s, oo, i, r),
              _o.set(0, 1),
              (a = t.ray.intersectTriangle(po, mo, fo, !1, ao)),
              null === a)
            )
              return;
            const o = t.ray.origin.distanceTo(ao);
            o < t.near ||
              o > t.far ||
              e.push({
                distance: o,
                point: ao.clone(),
                uv: ni.getInterpolation(ao, po, fo, mo, go, _o, vo, new de()),
                face: null,
                object: this,
              });
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              void 0 !== t.center && this.center.copy(t.center),
              (this.material = t.material),
              this
            );
          }
        }
        function yo(t, e, n, i, r, s) {
          co.subVectors(t, n).addScalar(0.5).multiply(i),
            void 0 !== r
              ? ((ho.x = s * co.x - r * co.y), (ho.y = r * co.x + s * co.y))
              : ho.copy(co),
            t.copy(e),
            (t.x += ho.x),
            (t.y += ho.y),
            t.applyMatrix4(uo);
        }
        const Mo = new ke(),
          So = new ke();
        class bo extends Wn {
          constructor() {
            super(),
              (this._currentLevel = 0),
              (this.type = "LOD"),
              Object.defineProperties(this, {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
              }),
              (this.autoUpdate = !0);
          }
          copy(t) {
            super.copy(t, !1);
            const e = t.levels;
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              this.addLevel(n.object.clone(), n.distance, n.hysteresis);
            }
            return (this.autoUpdate = t.autoUpdate), this;
          }
          addLevel(t, e = 0, n = 0) {
            e = Math.abs(e);
            const i = this.levels;
            let r;
            for (r = 0; r < i.length && !(e < i[r].distance); r++);
            return i.splice(r, 0, { distance: e, hysteresis: n, object: t }), this.add(t), this;
          }
          getCurrentLevel() {
            return this._currentLevel;
          }
          getObjectForDistance(t) {
            const e = this.levels;
            if (e.length > 0) {
              let n, i;
              for (n = 1, i = e.length; n < i; n++) {
                let i = e[n].distance;
                if ((e[n].object.visible && (i -= i * e[n].hysteresis), t < i)) break;
              }
              return e[n - 1].object;
            }
            return null;
          }
          raycast(t, e) {
            if (this.levels.length > 0) {
              Mo.setFromMatrixPosition(this.matrixWorld);
              const n = t.ray.origin.distanceTo(Mo);
              this.getObjectForDistance(n).raycast(t, e);
            }
          }
          update(t) {
            const e = this.levels;
            if (e.length > 1) {
              Mo.setFromMatrixPosition(t.matrixWorld), So.setFromMatrixPosition(this.matrixWorld);
              const n = Mo.distanceTo(So) / t.zoom;
              let i, r;
              for (e[0].object.visible = !0, i = 1, r = e.length; i < r; i++) {
                let t = e[i].distance;
                if ((e[i].object.visible && (t -= t * e[i].hysteresis), !(n >= t))) break;
                (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
              }
              for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
            }
          }
          toJSON(t) {
            const e = super.toJSON(t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1), (e.object.levels = []);
            const n = this.levels;
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              e.object.levels.push({
                object: i.object.uuid,
                distance: i.distance,
                hysteresis: i.hysteresis,
              });
            }
            return e;
          }
        }
        const Eo = new ke(),
          To = new Oe(),
          Ao = new Oe(),
          wo = new ke(),
          Ro = new xn(),
          Co = new ke(),
          Lo = new hn(),
          Po = new xn(),
          Io = new vn();
        class Uo extends Yi {
          constructor(t, e) {
            super(t, e),
              (this.isSkinnedMesh = !0),
              (this.type = "SkinnedMesh"),
              (this.bindMode = x),
              (this.bindMatrix = new xn()),
              (this.bindMatrixInverse = new xn()),
              (this.boundingBox = null),
              (this.boundingSphere = null);
          }
          computeBoundingBox() {
            const t = this.geometry;
            null === this.boundingBox && (this.boundingBox = new Xe()),
              this.boundingBox.makeEmpty();
            const e = t.getAttribute("position");
            for (let t = 0; t < e.count; t++)
              this.getVertexPosition(t, Co), this.boundingBox.expandByPoint(Co);
          }
          computeBoundingSphere() {
            const t = this.geometry;
            null === this.boundingSphere && (this.boundingSphere = new hn()),
              this.boundingSphere.makeEmpty();
            const e = t.getAttribute("position");
            for (let t = 0; t < e.count; t++)
              this.getVertexPosition(t, Co), this.boundingSphere.expandByPoint(Co);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              this
            );
          }
          raycast(t, e) {
            const n = this.material,
              i = this.matrixWorld;
            void 0 !== n &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              Lo.copy(this.boundingSphere),
              Lo.applyMatrix4(i),
              !1 !== t.ray.intersectsSphere(Lo) &&
                (Po.copy(i).invert(),
                Io.copy(t.ray).applyMatrix4(Po),
                (null !== this.boundingBox && !1 === Io.intersectsBox(this.boundingBox)) ||
                  this._computeIntersections(t, e, Io)));
          }
          getVertexPosition(t, e) {
            return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
          }
          bind(t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights() {
            const t = new Oe(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
              t.fromBufferAttribute(e, n);
              const i = 1 / t.manhattanLength();
              i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              this.bindMode === x
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : this.bindMode === y
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
          applyBoneTransform(t, e) {
            const n = this.skeleton,
              i = this.geometry;
            To.fromBufferAttribute(i.attributes.skinIndex, t),
              Ao.fromBufferAttribute(i.attributes.skinWeight, t),
              Eo.copy(e).applyMatrix4(this.bindMatrix),
              e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
              const i = Ao.getComponent(t);
              if (0 !== i) {
                const r = To.getComponent(t);
                Ro.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(wo.copy(Eo).applyMatrix4(Ro), i);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          }
          boneTransform(t, e) {
            return (
              console.warn(
                "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
              ),
              this.applyBoneTransform(t, e)
            );
          }
        }
        class No extends Wn {
          constructor() {
            super(), (this.isBone = !0), (this.type = "Bone");
          }
        }
        class Do extends De {
          constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
            super(null, s, a, o, l, c, i, r, h, u),
              (this.isDataTexture = !0),
              (this.image = { data: t, width: e, height: n }),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        const Oo = new xn(),
          Bo = new xn();
        class Fo {
          constructor(t = [], e = []) {
            (this.uuid = ie()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length))
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new xn());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new xn();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i] ? t[i].matrixWorld : Bo;
              Oo.multiplyMatrices(r, e[i]), Oo.toArray(n, 16 * i);
            }
            null !== i && (i.needsUpdate = !0);
          }
          clone() {
            return new Fo(this.bones, this.boneInverses);
          }
          computeBoneTexture() {
            let t = Math.sqrt(4 * this.bones.length);
            (t = 4 * Math.ceil(t / 4)), (t = Math.max(t, 4));
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new Do(e, t, t, X, H);
            return (n.needsUpdate = !0), (this.boneMatrices = e), (this.boneTexture = n), this;
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
              const i = t.bones[n];
              let r = e[i];
              void 0 === r &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", i), (r = new No())),
                this.bones.push(r),
                this.boneInverses.push(new xn().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i];
              t.bones.push(r.uuid);
              const s = n[i];
              t.boneInverses.push(s.toArray());
            }
            return t;
          }
        }
        class zo extends xi {
          constructor(t, e, n, i = 1) {
            super(t, e, n), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = i);
          }
          copy(t) {
            return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t
            );
          }
        }
        const Ho = new xn(),
          Go = new xn(),
          ko = [],
          Vo = new Xe(),
          Wo = new xn(),
          Xo = new Yi(),
          jo = new hn();
        class qo extends Yi {
          constructor(t, e, n) {
            super(t, e),
              (this.isInstancedMesh = !0),
              (this.instanceMatrix = new zo(new Float32Array(16 * n), 16)),
              (this.instanceColor = null),
              (this.count = n),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            for (let t = 0; t < n; t++) this.setMatrixAt(t, Wo);
          }
          computeBoundingBox() {
            const t = this.geometry,
              e = this.count;
            null === this.boundingBox && (this.boundingBox = new Xe()),
              null === t.boundingBox && t.computeBoundingBox(),
              this.boundingBox.makeEmpty();
            for (let n = 0; n < e; n++)
              this.getMatrixAt(n, Ho),
                Vo.copy(t.boundingBox).applyMatrix4(Ho),
                this.boundingBox.union(Vo);
          }
          computeBoundingSphere() {
            const t = this.geometry,
              e = this.count;
            null === this.boundingSphere && (this.boundingSphere = new hn()),
              null === t.boundingSphere && t.computeBoundingSphere(),
              this.boundingSphere.makeEmpty();
            for (let n = 0; n < e; n++)
              this.getMatrixAt(n, Ho),
                jo.copy(t.boundingSphere).applyMatrix4(Ho),
                this.boundingSphere.union(jo);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              this
            );
          }
          getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          }
          getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          }
          raycast(t, e) {
            const n = this.matrixWorld,
              i = this.count;
            if (
              ((Xo.geometry = this.geometry),
              (Xo.material = this.material),
              void 0 !== Xo.material &&
                (null === this.boundingSphere && this.computeBoundingSphere(),
                jo.copy(this.boundingSphere),
                jo.applyMatrix4(n),
                !1 !== t.ray.intersectsSphere(jo)))
            )
              for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, Ho),
                  Go.multiplyMatrices(n, Ho),
                  (Xo.matrixWorld = Go),
                  Xo.raycast(t, ko);
                for (let t = 0, n = ko.length; t < n; t++) {
                  const n = ko[t];
                  (n.instanceId = r), (n.object = this), e.push(n);
                }
                ko.length = 0;
              }
          }
          setColorAt(t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new zo(new Float32Array(3 * this.instanceMatrix.count), 3)),
              e.toArray(this.instanceColor.array, 3 * t);
          }
          setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        function Yo(t, e) {
          return t.z - e.z;
        }
        function Ko(t, e) {
          return e.z - t.z;
        }
        class Zo {
          constructor() {
            (this.index = 0), (this.pool = []), (this.list = []);
          }
          push(t, e) {
            const n = this.pool,
              i = this.list;
            this.index >= n.length && n.push({ start: -1, count: -1, z: -1 });
            const r = n[this.index];
            i.push(r), this.index++, (r.start = t.start), (r.count = t.count), (r.z = e);
          }
          reset() {
            (this.list.length = 0), (this.index = 0);
          }
        }
        const Jo = "batchId",
          Qo = new xn(),
          $o = new xn(),
          tl = new xn(),
          el = new xn(),
          nl = new fr(),
          il = new Xe(),
          rl = new hn(),
          sl = new ke(),
          al = new Zo(),
          ol = new Yi(),
          ll = [];
        function cl(t, e, n = 0) {
          const i = e.itemSize;
          if (t.isInterleavedBufferAttribute || t.array.constructor !== e.array.constructor) {
            const r = t.count;
            for (let s = 0; s < r; s++)
              for (let r = 0; r < i; r++) e.setComponent(s + n, r, t.getComponent(s, r));
          } else e.array.set(t.array, n * i);
          e.needsUpdate = !0;
        }
        class hl extends Yi {
          get maxGeometryCount() {
            return this._maxGeometryCount;
          }
          constructor(t, e, n = 2 * e, i) {
            super(new Li(), i),
              (this.isBatchedMesh = !0),
              (this.perObjectFrustumCulled = !0),
              (this.sortObjects = !0),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.customSort = null),
              (this._drawRanges = []),
              (this._reservedRanges = []),
              (this._visibility = []),
              (this._active = []),
              (this._bounds = []),
              (this._maxGeometryCount = t),
              (this._maxVertexCount = e),
              (this._maxIndexCount = n),
              (this._geometryInitialized = !1),
              (this._geometryCount = 0),
              (this._multiDrawCounts = new Int32Array(t)),
              (this._multiDrawStarts = new Int32Array(t)),
              (this._multiDrawCount = 0),
              (this._visibilityChanged = !0),
              (this._matricesTexture = null),
              this._initMatricesTexture();
          }
          _initMatricesTexture() {
            let t = Math.sqrt(4 * this._maxGeometryCount);
            (t = 4 * Math.ceil(t / 4)), (t = Math.max(t, 4));
            const e = new Float32Array(t * t * 4),
              n = new Do(e, t, t, X, H);
            this._matricesTexture = n;
          }
          _initializeGeometry(t) {
            const e = this.geometry,
              n = this._maxVertexCount,
              i = this._maxGeometryCount,
              r = this._maxIndexCount;
            if (!1 === this._geometryInitialized) {
              for (const i in t.attributes) {
                const r = t.getAttribute(i),
                  { array: s, itemSize: a, normalized: o } = r,
                  l = new s.constructor(n * a),
                  c = new r.constructor(l, a, o);
                c.setUsage(r.usage), e.setAttribute(i, c);
              }
              if (null !== t.getIndex()) {
                const t = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
                e.setIndex(new xi(t, 1));
              }
              const s = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
              e.setAttribute(Jo, new xi(s, 1)), (this._geometryInitialized = !0);
            }
          }
          _validateGeometry(t) {
            if (t.getAttribute(Jo))
              throw new Error(`BatchedMesh: Geometry cannot use attribute "${Jo}"`);
            const e = this.geometry;
            if (Boolean(t.getIndex()) !== Boolean(e.getIndex()))
              throw new Error('BatchedMesh: All geometries must consistently have "index".');
            for (const n in e.attributes) {
              if (n === Jo) continue;
              if (!t.hasAttribute(n))
                throw new Error(
                  `BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`
                );
              const i = t.getAttribute(n),
                r = e.getAttribute(n);
              if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
                throw new Error(
                  "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
                );
            }
          }
          setCustomSort(t) {
            return (this.customSort = t), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Xe());
            const t = this._geometryCount,
              e = this.boundingBox,
              n = this._active;
            e.makeEmpty();
            for (let i = 0; i < t; i++)
              !1 !== n[i] &&
                (this.getMatrixAt(i, Qo),
                this.getBoundingBoxAt(i, il).applyMatrix4(Qo),
                e.union(il));
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new hn());
            const t = this._geometryCount,
              e = this.boundingSphere,
              n = this._active;
            e.makeEmpty();
            for (let i = 0; i < t; i++)
              !1 !== n[i] &&
                (this.getMatrixAt(i, Qo),
                this.getBoundingSphereAt(i, rl).applyMatrix4(Qo),
                e.union(rl));
          }
          addGeometry(t, e = -1, n = -1) {
            if (
              (this._initializeGeometry(t),
              this._validateGeometry(t),
              this._geometryCount >= this._maxGeometryCount)
            )
              throw new Error("BatchedMesh: Maximum geometry count reached.");
            const i = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
            let r = null;
            const s = this._reservedRanges,
              a = this._drawRanges,
              o = this._bounds;
            0 !== this._geometryCount && (r = s[s.length - 1]),
              (i.vertexCount = -1 === e ? t.getAttribute("position").count : e),
              (i.vertexStart = null === r ? 0 : r.vertexStart + r.vertexCount);
            const l = t.getIndex(),
              c = null !== l;
            if (
              (c &&
                ((i.indexCount = -1 === n ? l.count : n),
                (i.indexStart = null === r ? 0 : r.indexStart + r.indexCount)),
              (-1 !== i.indexStart && i.indexStart + i.indexCount > this._maxIndexCount) ||
                i.vertexStart + i.vertexCount > this._maxVertexCount)
            )
              throw new Error(
                "BatchedMesh: Reserved space request exceeds the maximum buffer size."
              );
            const h = this._visibility,
              u = this._active,
              d = this._matricesTexture,
              p = this._matricesTexture.image.data;
            h.push(!0), u.push(!0);
            const f = this._geometryCount;
            this._geometryCount++,
              tl.toArray(p, 16 * f),
              (d.needsUpdate = !0),
              s.push(i),
              a.push({ start: c ? i.indexStart : i.vertexStart, count: -1 }),
              o.push({
                boxInitialized: !1,
                box: new Xe(),
                sphereInitialized: !1,
                sphere: new hn(),
              });
            const m = this.geometry.getAttribute(Jo);
            for (let t = 0; t < i.vertexCount; t++) m.setX(i.vertexStart + t, f);
            return (m.needsUpdate = !0), this.setGeometryAt(f, t), f;
          }
          setGeometryAt(t, e) {
            if (t >= this._geometryCount)
              throw new Error("BatchedMesh: Maximum geometry count reached.");
            this._validateGeometry(e);
            const n = this.geometry,
              i = null !== n.getIndex(),
              r = n.getIndex(),
              s = e.getIndex(),
              a = this._reservedRanges[t];
            if ((i && s.count > a.indexCount) || e.attributes.position.count > a.vertexCount)
              throw new Error(
                "BatchedMesh: Reserved space not large enough for provided geometry."
              );
            const o = a.vertexStart,
              l = a.vertexCount;
            for (const t in n.attributes) {
              if (t === Jo) continue;
              const i = e.getAttribute(t),
                r = n.getAttribute(t);
              cl(i, r, o);
              const s = i.itemSize;
              for (let t = i.count, e = l; t < e; t++) {
                const e = o + t;
                for (let t = 0; t < s; t++) r.setComponent(e, t, 0);
              }
              r.needsUpdate = !0;
            }
            if (i) {
              const t = a.indexStart;
              for (let e = 0; e < s.count; e++) r.setX(t + e, o + s.getX(e));
              for (let e = s.count, n = a.indexCount; e < n; e++) r.setX(t + e, o);
              r.needsUpdate = !0;
            }
            const c = this._bounds[t];
            null !== e.boundingBox
              ? (c.box.copy(e.boundingBox), (c.boxInitialized = !0))
              : (c.boxInitialized = !1),
              null !== e.boundingSphere
                ? (c.sphere.copy(e.boundingSphere), (c.sphereInitialized = !0))
                : (c.sphereInitialized = !1);
            const h = this._drawRanges[t],
              u = e.getAttribute("position");
            return (h.count = i ? s.count : u.count), (this._visibilityChanged = !0), t;
          }
          deleteGeometry(t) {
            const e = this._active;
            return (
              t >= e.length || !1 === e[t] || ((e[t] = !1), (this._visibilityChanged = !0)), this
            );
          }
          getBoundingBoxAt(t, e) {
            if (!1 === this._active[t]) return this;
            const n = this._bounds[t],
              i = n.box,
              r = this.geometry;
            if (!1 === n.boxInitialized) {
              i.makeEmpty();
              const e = r.index,
                s = r.attributes.position,
                a = this._drawRanges[t];
              for (let t = a.start, n = a.start + a.count; t < n; t++) {
                let n = t;
                e && (n = e.getX(n)), i.expandByPoint(sl.fromBufferAttribute(s, n));
              }
              n.boxInitialized = !0;
            }
            return e.copy(i), e;
          }
          getBoundingSphereAt(t, e) {
            if (!1 === this._active[t]) return this;
            const n = this._bounds[t],
              i = n.sphere,
              r = this.geometry;
            if (!1 === n.sphereInitialized) {
              i.makeEmpty(), this.getBoundingBoxAt(t, il), il.getCenter(i.center);
              const e = r.index,
                s = r.attributes.position,
                a = this._drawRanges[t];
              let o = 0;
              for (let t = a.start, n = a.start + a.count; t < n; t++) {
                let n = t;
                e && (n = e.getX(n)),
                  sl.fromBufferAttribute(s, n),
                  (o = Math.max(o, i.center.distanceToSquared(sl)));
              }
              (i.radius = Math.sqrt(o)), (n.sphereInitialized = !0);
            }
            return e.copy(i), e;
          }
          setMatrixAt(t, e) {
            const n = this._active,
              i = this._matricesTexture,
              r = this._matricesTexture.image.data;
            return (
              t >= this._geometryCount ||
                !1 === n[t] ||
                (e.toArray(r, 16 * t), (i.needsUpdate = !0)),
              this
            );
          }
          getMatrixAt(t, e) {
            const n = this._active,
              i = this._matricesTexture.image.data;
            return t >= this._geometryCount || !1 === n[t] ? null : e.fromArray(i, 16 * t);
          }
          setVisibleAt(t, e) {
            const n = this._visibility,
              i = this._active;
            return (
              t >= this._geometryCount ||
                !1 === i[t] ||
                n[t] === e ||
                ((n[t] = e), (this._visibilityChanged = !0)),
              this
            );
          }
          getVisibleAt(t) {
            const e = this._visibility,
              n = this._active;
            return !(t >= this._geometryCount || !1 === n[t]) && e[t];
          }
          raycast(t, e) {
            const n = this._visibility,
              i = this._active,
              r = this._drawRanges,
              s = this._geometryCount,
              a = this.matrixWorld,
              o = this.geometry;
            (ol.material = this.material),
              (ol.geometry.index = o.index),
              (ol.geometry.attributes = o.attributes),
              null === ol.geometry.boundingBox && (ol.geometry.boundingBox = new Xe()),
              null === ol.geometry.boundingSphere && (ol.geometry.boundingSphere = new hn());
            for (let o = 0; o < s; o++) {
              if (!n[o] || !i[o]) continue;
              const s = r[o];
              ol.geometry.setDrawRange(s.start, s.count),
                this.getMatrixAt(o, ol.matrixWorld).premultiply(a),
                this.getBoundingBoxAt(o, ol.geometry.boundingBox),
                this.getBoundingSphereAt(o, ol.geometry.boundingSphere),
                ol.raycast(t, ll);
              for (let t = 0, n = ll.length; t < n; t++) {
                const n = ll[t];
                (n.object = this), (n.batchId = o), e.push(n);
              }
              ll.length = 0;
            }
            (ol.material = null),
              (ol.geometry.index = null),
              (ol.geometry.attributes = {}),
              ol.geometry.setDrawRange(0, 1 / 0);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.geometry = t.geometry.clone()),
              (this.perObjectFrustumCulled = t.perObjectFrustumCulled),
              (this.sortObjects = t.sortObjects),
              (this.boundingBox = null !== t.boundingBox ? t.boundingBox.clone() : null),
              (this.boundingSphere = null !== t.boundingSphere ? t.boundingSphere.clone() : null),
              (this._drawRanges = t._drawRanges.map((t) => ({ ...t }))),
              (this._reservedRanges = t._reservedRanges.map((t) => ({ ...t }))),
              (this._visibility = t._visibility.slice()),
              (this._active = t._active.slice()),
              (this._bounds = t._bounds.map((t) => ({
                boxInitialized: t.boxInitialized,
                box: t.box.clone(),
                sphereInitialized: t.sphereInitialized,
                sphere: t.sphere.clone(),
              }))),
              (this._maxGeometryCount = t._maxGeometryCount),
              (this._maxVertexCount = t._maxVertexCount),
              (this._maxIndexCount = t._maxIndexCount),
              (this._geometryInitialized = t._geometryInitialized),
              (this._geometryCount = t._geometryCount),
              (this._multiDrawCounts = t._multiDrawCounts.slice()),
              (this._multiDrawStarts = t._multiDrawStarts.slice()),
              (this._matricesTexture = t._matricesTexture.clone()),
              (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
              this
            );
          }
          dispose() {
            return (
              this.geometry.dispose(),
              this._matricesTexture.dispose(),
              (this._matricesTexture = null),
              this
            );
          }
          onBeforeRender(t, e, n, i, r) {
            if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
              return;
            const s = i.getIndex(),
              a = null === s ? 1 : s.array.BYTES_PER_ELEMENT,
              o = this._visibility,
              l = this._multiDrawStarts,
              c = this._multiDrawCounts,
              h = this._drawRanges,
              u = this.perObjectFrustumCulled;
            u &&
              (el
                .multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse)
                .multiply(this.matrixWorld),
              nl.setFromProjectionMatrix(el, t.isWebGPURenderer ? Jt : Zt));
            let d = 0;
            if (this.sortObjects) {
              $o.copy(this.matrixWorld).invert(),
                sl.setFromMatrixPosition(n.matrixWorld).applyMatrix4($o);
              for (let t = 0, e = o.length; t < e; t++)
                if (o[t]) {
                  this.getMatrixAt(t, Qo), this.getBoundingSphereAt(t, rl).applyMatrix4(Qo);
                  let e = !1;
                  if ((u && (e = !nl.intersectsSphere(rl)), !e)) {
                    const e = sl.distanceTo(rl.center);
                    al.push(h[t], e);
                  }
                }
              const t = al.list,
                e = this.customSort;
              null === e ? t.sort(r.transparent ? Ko : Yo) : e.call(this, t, n);
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                (l[d] = n.start * a), (c[d] = n.count), d++;
              }
              al.reset();
            } else
              for (let t = 0, e = o.length; t < e; t++)
                if (o[t]) {
                  let e = !1;
                  if (
                    (u &&
                      (this.getMatrixAt(t, Qo),
                      this.getBoundingSphereAt(t, rl).applyMatrix4(Qo),
                      (e = !nl.intersectsSphere(rl))),
                    !e)
                  ) {
                    const e = h[t];
                    (l[d] = e.start * a), (c[d] = e.count), d++;
                  }
                }
            (this._multiDrawCount = d), (this._visibilityChanged = !1);
          }
          onBeforeShadow(t, e, n, i, r, s) {
            this.onBeforeRender(t, null, i, r, s);
          }
        }
        class ul extends hi {
          constructor(t) {
            super(),
              (this.isLineBasicMaterial = !0),
              (this.type = "LineBasicMaterial"),
              (this.color = new oi(16777215)),
              (this.map = null),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        const dl = new ke(),
          pl = new ke(),
          fl = new xn(),
          ml = new vn(),
          gl = new hn();
        class _l extends Wn {
          constructor(t = new Li(), e = new ul()) {
            super(),
              (this.isLine = !0),
              (this.type = "Line"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
              const e = t.attributes.position,
                n = [0];
              for (let t = 1, i = e.count; t < i; t++)
                dl.fromBufferAttribute(e, t - 1),
                  pl.fromBufferAttribute(e, t),
                  (n[t] = n[t - 1]),
                  (n[t] += dl.distanceTo(pl));
              t.setAttribute("lineDistance", new Si(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Line.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              gl.copy(n.boundingSphere),
              gl.applyMatrix4(i),
              (gl.radius += r),
              !1 === t.ray.intersectsSphere(gl))
            )
              return;
            fl.copy(i).invert(), ml.copy(t.ray).applyMatrix4(fl);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              l = new ke(),
              c = new ke(),
              h = new ke(),
              u = new ke(),
              d = this.isLineSegments ? 2 : 1,
              p = n.index,
              f = n.attributes.position;
            if (null !== p)
              for (
                let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                const i = p.getX(n),
                  r = p.getX(n + 1);
                if (
                  (l.fromBufferAttribute(f, i),
                  c.fromBufferAttribute(f, r),
                  ml.distanceSqToSegment(l, c, u, h) > o)
                )
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const s = t.ray.origin.distanceTo(u);
                s < t.near ||
                  s > t.far ||
                  e.push({
                    distance: s,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            else
              for (
                let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                if (
                  (l.fromBufferAttribute(f, n),
                  c.fromBufferAttribute(f, n + 1),
                  ml.distanceSqToSegment(l, c, u, h) > o)
                )
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const i = t.ray.origin.distanceTo(u);
                i < t.near ||
                  i > t.far ||
                  e.push({
                    distance: i,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
        }
        const vl = new ke(),
          xl = new ke();
        class yl extends _l {
          constructor(t, e) {
            super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
          }
          computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
              const e = t.attributes.position,
                n = [];
              for (let t = 0, i = e.count; t < i; t += 2)
                vl.fromBufferAttribute(e, t),
                  xl.fromBufferAttribute(e, t + 1),
                  (n[t] = 0 === t ? 0 : n[t - 1]),
                  (n[t + 1] = n[t] + vl.distanceTo(xl));
              t.setAttribute("lineDistance", new Si(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
        }
        class Ml extends _l {
          constructor(t, e) {
            super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
          }
        }
        class Sl extends hi {
          constructor(t) {
            super(),
              (this.isPointsMaterial = !0),
              (this.type = "PointsMaterial"),
              (this.color = new oi(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.fog = t.fog),
              this
            );
          }
        }
        const bl = new xn(),
          El = new vn(),
          Tl = new hn(),
          Al = new ke();
        class wl extends Wn {
          constructor(t = new Li(), e = new Sl()) {
            super(),
              (this.isPoints = !0),
              (this.type = "Points"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Points.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Tl.copy(n.boundingSphere),
              Tl.applyMatrix4(i),
              (Tl.radius += r),
              !1 === t.ray.intersectsSphere(Tl))
            )
              return;
            bl.copy(i).invert(), El.copy(t.ray).applyMatrix4(bl);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              l = n.index,
              c = n.attributes.position;
            if (null !== l)
              for (
                let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count);
                n < r;
                n++
              ) {
                const r = l.getX(n);
                Al.fromBufferAttribute(c, r), Rl(Al, r, o, i, t, e, this);
              }
            else
              for (
                let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count);
                n < r;
                n++
              )
                Al.fromBufferAttribute(c, n), Rl(Al, n, o, i, t, e, this);
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
        }
        function Rl(t, e, n, i, r, s, a) {
          const o = El.distanceSqToPoint(t);
          if (o < n) {
            const n = new ke();
            El.closestPointToPoint(t, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            s.push({
              distance: l,
              distanceToRay: Math.sqrt(o),
              point: n,
              index: e,
              face: null,
              object: a,
            });
          }
        }
        class Cl extends De {
          constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
            super(null, s, a, o, l, c, i, r, h, u),
              (this.isCompressedTexture = !0),
              (this.image = { width: e, height: n }),
              (this.mipmaps = t),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        class Ll {
          constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
          }
          getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null;
          }
          getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e);
          }
          getPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e;
          }
          getSpacedPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e;
          }
          getLength() {
            const t = this.getLengths();
            return t[t.length - 1];
          }
          getLengths(t = this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n,
              i = this.getPoint(0),
              r = 0;
            e.push(0);
            for (let s = 1; s <= t; s++)
              (n = this.getPoint(s / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
            return (this.cacheArcLengths = e), e;
          }
          updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
          }
          getUtoTmapping(t, e) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let s;
            s = e || t * n[r - 1];
            let a,
              o = 0,
              l = r - 1;
            for (; o <= l; )
              if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0)) o = i + 1;
              else {
                if (!(a > 0)) {
                  l = i;
                  break;
                }
                l = i - 1;
              }
            if (((i = l), n[i] === s)) return i / (r - 1);
            const c = n[i];
            return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
          }
          getTangent(t, e) {
            const n = 1e-4;
            let i = t - n,
              r = t + n;
            i < 0 && (i = 0), r > 1 && (r = 1);
            const s = this.getPoint(i),
              a = this.getPoint(r),
              o = e || (s.isVector2 ? new de() : new ke());
            return o.copy(a).sub(s).normalize(), o;
          }
          getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e);
          }
          computeFrenetFrames(t, e) {
            const n = new ke(),
              i = [],
              r = [],
              s = [],
              a = new ke(),
              o = new xn();
            for (let e = 0; e <= t; e++) {
              const n = e / t;
              i[e] = this.getTangentAt(n, new ke());
            }
            (r[0] = new ke()), (s[0] = new ke());
            let l = Number.MAX_VALUE;
            const c = Math.abs(i[0].x),
              h = Math.abs(i[0].y),
              u = Math.abs(i[0].z);
            c <= l && ((l = c), n.set(1, 0, 0)),
              h <= l && ((l = h), n.set(0, 1, 0)),
              u <= l && n.set(0, 0, 1),
              a.crossVectors(i[0], n).normalize(),
              r[0].crossVectors(i[0], a),
              s[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
              if (
                ((r[e] = r[e - 1].clone()),
                (s[e] = s[e - 1].clone()),
                a.crossVectors(i[e - 1], i[e]),
                a.length() > Number.EPSILON)
              ) {
                a.normalize();
                const t = Math.acos(re(i[e - 1].dot(i[e]), -1, 1));
                r[e].applyMatrix4(o.makeRotationAxis(a, t));
              }
              s[e].crossVectors(i[e], r[e]);
            }
            if (!0 === e) {
              let e = Math.acos(re(r[0].dot(r[t]), -1, 1));
              (e /= t), i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
              for (let n = 1; n <= t; n++)
                r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n]);
            }
            return { tangents: i, normals: r, binormals: s };
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
          toJSON() {
            const t = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
            return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t;
          }
          fromJSON(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
        }
        class Pl extends Ll {
          constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
            super(),
              (this.isEllipseCurve = !0),
              (this.type = "EllipseCurve"),
              (this.aX = t),
              (this.aY = e),
              (this.xRadius = n),
              (this.yRadius = i),
              (this.aStartAngle = r),
              (this.aEndAngle = s),
              (this.aClockwise = a),
              (this.aRotation = o);
          }
          getPoint(t, e) {
            const n = e || new de(),
              i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0; ) r += i;
            for (; r > i; ) r -= i;
            r < Number.EPSILON && (r = s ? 0 : i),
              !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
            const a = this.aStartAngle + t * r;
            let o = this.aX + this.xRadius * Math.cos(a),
              l = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
              const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = o - this.aX,
                i = l - this.aY;
              (o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
            }
            return n.set(o, l);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.aX = this.aX),
              (t.aY = this.aY),
              (t.xRadius = this.xRadius),
              (t.yRadius = this.yRadius),
              (t.aStartAngle = this.aStartAngle),
              (t.aEndAngle = this.aEndAngle),
              (t.aClockwise = this.aClockwise),
              (t.aRotation = this.aRotation),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
        }
        class Il extends Pl {
          constructor(t, e, n, i, r, s) {
            super(t, e, n, n, i, r, s), (this.isArcCurve = !0), (this.type = "ArcCurve");
          }
        }
        function Ul() {
          let t = 0,
            e = 0,
            n = 0,
            i = 0;
          function r(r, s, a, o) {
            (t = r), (e = a), (n = -3 * r + 3 * s - 2 * a - o), (i = 2 * r - 2 * s + a + o);
          }
          return {
            initCatmullRom: function (t, e, n, i, s) {
              r(e, n, s * (n - t), s * (i - e));
            },
            initNonuniformCatmullRom: function (t, e, n, i, s, a, o) {
              let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
                c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
              (l *= a), (c *= a), r(e, n, l, c);
            },
            calc: function (r) {
              const s = r * r;
              return t + e * r + n * s + i * (s * r);
            },
          };
        }
        const Nl = new ke(),
          Dl = new Ul(),
          Ol = new Ul(),
          Bl = new Ul();
        class Fl extends Ll {
          constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
            super(),
              (this.isCatmullRomCurve3 = !0),
              (this.type = "CatmullRomCurve3"),
              (this.points = t),
              (this.closed = e),
              (this.curveType = n),
              (this.tension = i);
          }
          getPoint(t, e = new ke()) {
            const n = e,
              i = this.points,
              r = i.length,
              s = (r - (this.closed ? 0 : 1)) * t;
            let a,
              o,
              l = Math.floor(s),
              c = s - l;
            this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
              : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
              this.closed || l > 0
                ? (a = i[(l - 1) % r])
                : (Nl.subVectors(i[0], i[1]).add(i[0]), (a = Nl));
            const h = i[l % r],
              u = i[(l + 1) % r];
            if (
              (this.closed || l + 2 < r
                ? (o = i[(l + 2) % r])
                : (Nl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = Nl)),
              "centripetal" === this.curveType || "chordal" === this.curveType)
            ) {
              const t = "chordal" === this.curveType ? 0.5 : 0.25;
              let e = Math.pow(a.distanceToSquared(h), t),
                n = Math.pow(h.distanceToSquared(u), t),
                i = Math.pow(u.distanceToSquared(o), t);
              n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                i < 1e-4 && (i = n),
                Dl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),
                Ol.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),
                Bl.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i);
            } else
              "catmullrom" === this.curveType &&
                (Dl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
                Ol.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
                Bl.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
            return n.set(Dl.calc(c), Ol.calc(c), Bl.calc(c)), n;
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return (
              (t.closed = this.closed),
              (t.curveType = this.curveType),
              (t.tension = this.tension),
              t
            );
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new ke().fromArray(n));
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
        }
        function zl(t, e, n, i, r) {
          const s = 0.5 * (i - e),
            a = 0.5 * (r - n),
            o = t * t;
          return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n;
        }
        function Hl(t, e, n, i) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * e;
            })(t, e) +
            (function (t, e) {
              return 2 * (1 - t) * t * e;
            })(t, n) +
            (function (t, e) {
              return t * t * e;
            })(t, i)
          );
        }
        function Gl(t, e, n, i, r) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * n * e;
            })(t, e) +
            (function (t, e) {
              const n = 1 - t;
              return 3 * n * n * t * e;
            })(t, n) +
            (function (t, e) {
              return 3 * (1 - t) * t * t * e;
            })(t, i) +
            (function (t, e) {
              return t * t * t * e;
            })(t, r)
          );
        }
        class kl extends Ll {
          constructor(t = new de(), e = new de(), n = new de(), i = new de()) {
            super(),
              (this.isCubicBezierCurve = !0),
              (this.type = "CubicBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = i);
          }
          getPoint(t, e = new de()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2,
              a = this.v3;
            return n.set(Gl(t, i.x, r.x, s.x, a.x), Gl(t, i.y, r.y, s.y, a.y)), n;
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        class Vl extends Ll {
          constructor(t = new ke(), e = new ke(), n = new ke(), i = new ke()) {
            super(),
              (this.isCubicBezierCurve3 = !0),
              (this.type = "CubicBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = i);
          }
          getPoint(t, e = new ke()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2,
              a = this.v3;
            return (
              n.set(
                Gl(t, i.x, r.x, s.x, a.x),
                Gl(t, i.y, r.y, s.y, a.y),
                Gl(t, i.z, r.z, s.z, a.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        class Wl extends Ll {
          constructor(t = new de(), e = new de()) {
            super(),
              (this.isLineCurve = !0),
              (this.type = "LineCurve"),
              (this.v1 = t),
              (this.v2 = e);
          }
          getPoint(t, e = new de()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          getTangent(t, e = new de()) {
            return e.subVectors(this.v2, this.v1).normalize();
          }
          getTangentAt(t, e) {
            return this.getTangent(t, e);
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
          }
        }
        class Xl extends Ll {
          constructor(t = new ke(), e = new ke()) {
            super(),
              (this.isLineCurve3 = !0),
              (this.type = "LineCurve3"),
              (this.v1 = t),
              (this.v2 = e);
          }
          getPoint(t, e = new ke()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          getTangent(t, e = new ke()) {
            return e.subVectors(this.v2, this.v1).normalize();
          }
          getTangentAt(t, e) {
            return this.getTangent(t, e);
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
          }
        }
        class jl extends Ll {
          constructor(t = new de(), e = new de(), n = new de()) {
            super(),
              (this.isQuadraticBezierCurve = !0),
              (this.type = "QuadraticBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new de()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2;
            return n.set(Hl(t, i.x, r.x, s.x), Hl(t, i.y, r.y, s.y)), n;
          }
          copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        class ql extends Ll {
          constructor(t = new ke(), e = new ke(), n = new ke()) {
            super(),
              (this.isQuadraticBezierCurve3 = !0),
              (this.type = "QuadraticBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new ke()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2;
            return n.set(Hl(t, i.x, r.x, s.x), Hl(t, i.y, r.y, s.y), Hl(t, i.z, r.z, s.z)), n;
          }
          copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        class Yl extends Ll {
          constructor(t = []) {
            super(), (this.isSplineCurve = !0), (this.type = "SplineCurve"), (this.points = t);
          }
          getPoint(t, e = new de()) {
            const n = e,
              i = this.points,
              r = (i.length - 1) * t,
              s = Math.floor(r),
              a = r - s,
              o = i[0 === s ? s : s - 1],
              l = i[s],
              c = i[s > i.length - 2 ? i.length - 1 : s + 1],
              h = i[s > i.length - 3 ? i.length - 1 : s + 2];
            return n.set(zl(a, o.x, l.x, c.x, h.x), zl(a, o.y, l.y, c.y, h.y)), n;
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new de().fromArray(n));
            }
            return this;
          }
        }
        var Kl = Object.freeze({
          __proto__: null,
          ArcCurve: Il,
          CatmullRomCurve3: Fl,
          CubicBezierCurve: kl,
          CubicBezierCurve3: Vl,
          EllipseCurve: Pl,
          LineCurve: Wl,
          LineCurve3: Xl,
          QuadraticBezierCurve: jl,
          QuadraticBezierCurve3: ql,
          SplineCurve: Yl,
        });
        class Zl extends Ll {
          constructor() {
            super(), (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
          }
          add(t) {
            this.curves.push(t);
          }
          closePath() {
            const t = this.curves[0].getPoint(0),
              e = this.curves[this.curves.length - 1].getPoint(1);
            if (!t.equals(e)) {
              const n = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
              this.curves.push(new Kl[n](e, t));
            }
            return this;
          }
          getPoint(t, e) {
            const n = t * this.getLength(),
              i = this.getCurveLengths();
            let r = 0;
            for (; r < i.length; ) {
              if (i[r] >= n) {
                const t = i[r] - n,
                  s = this.curves[r],
                  a = s.getLength(),
                  o = 0 === a ? 0 : 1 - t / a;
                return s.getPointAt(o, e);
              }
              r++;
            }
            return null;
          }
          getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
          }
          getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
              return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
              (e += this.curves[n].getLength()), t.push(e);
            return (this.cacheLengths = t), t;
          }
          getSpacedPoints(t = 40) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e;
          }
          getPoints(t = 12) {
            const e = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
              const s = r[i],
                a = s.isEllipseCurve
                  ? 2 * t
                  : s.isLineCurve || s.isLineCurve3
                  ? 1
                  : s.isSplineCurve
                  ? t * s.points.length
                  : t,
                o = s.getPoints(a);
              for (let t = 0; t < o.length; t++) {
                const i = o[t];
                (n && n.equals(i)) || (e.push(i), (n = i));
              }
            }
            return (
              this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
            );
          }
          copy(t) {
            super.copy(t), (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(n.clone());
            }
            return (this.autoClose = t.autoClose), this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.autoClose = this.autoClose), (t.curves = []);
            for (let e = 0, n = this.curves.length; e < n; e++) {
              const n = this.curves[e];
              t.curves.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(new Kl[n.type]().fromJSON(n));
            }
            return this;
          }
        }
        class Jl extends Zl {
          constructor(t) {
            super(),
              (this.type = "Path"),
              (this.currentPoint = new de()),
              t && this.setFromPoints(t);
          }
          setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
            return this;
          }
          moveTo(t, e) {
            return this.currentPoint.set(t, e), this;
          }
          lineTo(t, e) {
            const n = new Wl(this.currentPoint.clone(), new de(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this;
          }
          quadraticCurveTo(t, e, n, i) {
            const r = new jl(this.currentPoint.clone(), new de(t, e), new de(n, i));
            return this.curves.push(r), this.currentPoint.set(n, i), this;
          }
          bezierCurveTo(t, e, n, i, r, s) {
            const a = new kl(this.currentPoint.clone(), new de(t, e), new de(n, i), new de(r, s));
            return this.curves.push(a), this.currentPoint.set(r, s), this;
          }
          splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t),
              n = new Yl(e);
            return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
          }
          arc(t, e, n, i, r, s) {
            const a = this.currentPoint.x,
              o = this.currentPoint.y;
            return this.absarc(t + a, e + o, n, i, r, s), this;
          }
          absarc(t, e, n, i, r, s) {
            return this.absellipse(t, e, n, n, i, r, s), this;
          }
          ellipse(t, e, n, i, r, s, a, o) {
            const l = this.currentPoint.x,
              c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, s, a, o), this;
          }
          absellipse(t, e, n, i, r, s, a, o) {
            const l = new Pl(t, e, n, i, r, s, a, o);
            if (this.curves.length > 0) {
              const t = l.getPoint(0);
              t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c), this;
          }
          copy(t) {
            return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.currentPoint = this.currentPoint.toArray()), t;
          }
          fromJSON(t) {
            return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
          }
        }
        class Ql extends Li {
          constructor(
            t = [new de(0, -0.5), new de(0.5, 0), new de(0, 0.5)],
            e = 12,
            n = 0,
            i = 2 * Math.PI
          ) {
            super(),
              (this.type = "LatheGeometry"),
              (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
              (e = Math.floor(e)),
              (i = re(i, 0, 2 * Math.PI));
            const r = [],
              s = [],
              a = [],
              o = [],
              l = [],
              c = 1 / e,
              h = new ke(),
              u = new de(),
              d = new ke(),
              p = new ke(),
              f = new ke();
            let m = 0,
              g = 0;
            for (let e = 0; e <= t.length - 1; e++)
              switch (e) {
                case 0:
                  (m = t[e + 1].x - t[e].x),
                    (g = t[e + 1].y - t[e].y),
                    (d.x = 1 * g),
                    (d.y = -m),
                    (d.z = 0 * g),
                    f.copy(d),
                    d.normalize(),
                    o.push(d.x, d.y, d.z);
                  break;
                case t.length - 1:
                  o.push(f.x, f.y, f.z);
                  break;
                default:
                  (m = t[e + 1].x - t[e].x),
                    (g = t[e + 1].y - t[e].y),
                    (d.x = 1 * g),
                    (d.y = -m),
                    (d.z = 0 * g),
                    p.copy(d),
                    (d.x += f.x),
                    (d.y += f.y),
                    (d.z += f.z),
                    d.normalize(),
                    o.push(d.x, d.y, d.z),
                    f.copy(p);
              }
            for (let r = 0; r <= e; r++) {
              const d = n + r * c * i,
                p = Math.sin(d),
                f = Math.cos(d);
              for (let n = 0; n <= t.length - 1; n++) {
                (h.x = t[n].x * p),
                  (h.y = t[n].y),
                  (h.z = t[n].x * f),
                  s.push(h.x, h.y, h.z),
                  (u.x = r / e),
                  (u.y = n / (t.length - 1)),
                  a.push(u.x, u.y);
                const i = o[3 * n + 0] * p,
                  c = o[3 * n + 1],
                  d = o[3 * n + 0] * f;
                l.push(i, c, d);
              }
            }
            for (let n = 0; n < e; n++)
              for (let e = 0; e < t.length - 1; e++) {
                const i = e + n * t.length,
                  s = i,
                  a = i + t.length,
                  o = i + t.length + 1,
                  l = i + 1;
                r.push(s, a, l), r.push(o, l, a);
              }
            this.setIndex(r),
              this.setAttribute("position", new Si(s, 3)),
              this.setAttribute("uv", new Si(a, 2)),
              this.setAttribute("normal", new Si(l, 3));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new Ql(t.points, t.segments, t.phiStart, t.phiLength);
          }
        }
        class $l extends Ql {
          constructor(t = 1, e = 1, n = 4, i = 8) {
            const r = new Jl();
            r.absarc(0, -e / 2, t, 1.5 * Math.PI, 0),
              r.absarc(0, e / 2, t, 0, 0.5 * Math.PI),
              super(r.getPoints(n), i),
              (this.type = "CapsuleGeometry"),
              (this.parameters = { radius: t, length: e, capSegments: n, radialSegments: i });
          }
          static fromJSON(t) {
            return new $l(t.radius, t.length, t.capSegments, t.radialSegments);
          }
        }
        class tc extends Li {
          constructor(t = 1, e = 32, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = "CircleGeometry"),
              (this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }),
              (e = Math.max(3, e));
            const r = [],
              s = [],
              a = [],
              o = [],
              l = new ke(),
              c = new de();
            s.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
            for (let r = 0, h = 3; r <= e; r++, h += 3) {
              const u = n + (r / e) * i;
              (l.x = t * Math.cos(u)),
                (l.y = t * Math.sin(u)),
                s.push(l.x, l.y, l.z),
                a.push(0, 0, 1),
                (c.x = (s[h] / t + 1) / 2),
                (c.y = (s[h + 1] / t + 1) / 2),
                o.push(c.x, c.y);
            }
            for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
            this.setIndex(r),
              this.setAttribute("position", new Si(s, 3)),
              this.setAttribute("normal", new Si(a, 3)),
              this.setAttribute("uv", new Si(o, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new tc(t.radius, t.segments, t.thetaStart, t.thetaLength);
          }
        }
        class ec extends Li {
          constructor(t = 1, e = 1, n = 1, i = 32, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
            super(),
              (this.type = "CylinderGeometry"),
              (this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: o,
              });
            const l = this;
            (i = Math.floor(i)), (r = Math.floor(r));
            const c = [],
              h = [],
              u = [],
              d = [];
            let p = 0;
            const f = [],
              m = n / 2;
            let g = 0;
            function _(n) {
              const r = p,
                s = new de(),
                f = new ke();
              let _ = 0;
              const v = !0 === n ? t : e,
                x = !0 === n ? 1 : -1;
              for (let t = 1; t <= i; t++)
                h.push(0, m * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++;
              const y = p;
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * o + a,
                  n = Math.cos(e),
                  r = Math.sin(e);
                (f.x = v * r),
                  (f.y = m * x),
                  (f.z = v * n),
                  h.push(f.x, f.y, f.z),
                  u.push(0, x, 0),
                  (s.x = 0.5 * n + 0.5),
                  (s.y = 0.5 * r * x + 0.5),
                  d.push(s.x, s.y),
                  p++;
              }
              for (let t = 0; t < i; t++) {
                const e = r + t,
                  i = y + t;
                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (_ += 3);
              }
              l.addGroup(g, _, !0 === n ? 1 : 2), (g += _);
            }
            !(function () {
              const s = new ke(),
                _ = new ke();
              let v = 0;
              const x = (e - t) / n;
              for (let l = 0; l <= r; l++) {
                const c = [],
                  g = l / r,
                  v = g * (e - t) + t;
                for (let t = 0; t <= i; t++) {
                  const e = t / i,
                    r = e * o + a,
                    l = Math.sin(r),
                    f = Math.cos(r);
                  (_.x = v * l),
                    (_.y = -g * n + m),
                    (_.z = v * f),
                    h.push(_.x, _.y, _.z),
                    s.set(l, x, f).normalize(),
                    u.push(s.x, s.y, s.z),
                    d.push(e, 1 - g),
                    c.push(p++);
                }
                f.push(c);
              }
              for (let t = 0; t < i; t++)
                for (let e = 0; e < r; e++) {
                  const n = f[e][t],
                    i = f[e + 1][t],
                    r = f[e + 1][t + 1],
                    s = f[e][t + 1];
                  c.push(n, i, s), c.push(i, r, s), (v += 6);
                }
              l.addGroup(g, v, 0), (g += v);
            })(),
              !1 === s && (t > 0 && _(!0), e > 0 && _(!1)),
              this.setIndex(c),
              this.setAttribute("position", new Si(h, 3)),
              this.setAttribute("normal", new Si(u, 3)),
              this.setAttribute("uv", new Si(d, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new ec(
              t.radiusTop,
              t.radiusBottom,
              t.height,
              t.radialSegments,
              t.heightSegments,
              t.openEnded,
              t.thetaStart,
              t.thetaLength
            );
          }
        }
        class nc extends ec {
          constructor(t = 1, e = 1, n = 32, i = 1, r = !1, s = 0, a = 2 * Math.PI) {
            super(0, t, e, n, i, r, s, a),
              (this.type = "ConeGeometry"),
              (this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: s,
                thetaLength: a,
              });
          }
          static fromJSON(t) {
            return new nc(
              t.radius,
              t.height,
              t.radialSegments,
              t.heightSegments,
              t.openEnded,
              t.thetaStart,
              t.thetaLength
            );
          }
        }
        class ic extends Li {
          constructor(t = [], e = [], n = 1, i = 0) {
            super(),
              (this.type = "PolyhedronGeometry"),
              (this.parameters = { vertices: t, indices: e, radius: n, detail: i });
            const r = [],
              s = [];
            function a(t, e, n, i) {
              const r = i + 1,
                s = [];
              for (let i = 0; i <= r; i++) {
                s[i] = [];
                const a = t.clone().lerp(n, i / r),
                  o = e.clone().lerp(n, i / r),
                  l = r - i;
                for (let t = 0; t <= l; t++)
                  s[i][t] = 0 === t && i === r ? a : a.clone().lerp(o, t / l);
              }
              for (let t = 0; t < r; t++)
                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                  const n = Math.floor(e / 2);
                  e % 2 == 0
                    ? (o(s[t][n + 1]), o(s[t + 1][n]), o(s[t][n]))
                    : (o(s[t][n + 1]), o(s[t + 1][n + 1]), o(s[t + 1][n]));
                }
            }
            function o(t) {
              r.push(t.x, t.y, t.z);
            }
            function l(e, n) {
              const i = 3 * e;
              (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
            }
            function c(t, e, n, i) {
              i < 0 && 1 === t.x && (s[e] = t.x - 1),
                0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + 0.5);
            }
            function h(t) {
              return Math.atan2(t.z, -t.x);
            }
            !(function (t) {
              const n = new ke(),
                i = new ke(),
                r = new ke();
              for (let s = 0; s < e.length; s += 3)
                l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), a(n, i, r, t);
            })(i),
              (function (t) {
                const e = new ke();
                for (let n = 0; n < r.length; n += 3)
                  (e.x = r[n + 0]),
                    (e.y = r[n + 1]),
                    (e.z = r[n + 2]),
                    e.normalize().multiplyScalar(t),
                    (r[n + 0] = e.x),
                    (r[n + 1] = e.y),
                    (r[n + 2] = e.z);
              })(n),
              (function () {
                const t = new ke();
                for (let n = 0; n < r.length; n += 3) {
                  (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
                  const i = h(t) / 2 / Math.PI + 0.5,
                    a =
                      ((e = t), Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + 0.5);
                  s.push(i, 1 - a);
                }
                var e;
                (function () {
                  const t = new ke(),
                    e = new ke(),
                    n = new ke(),
                    i = new ke(),
                    a = new de(),
                    o = new de(),
                    l = new de();
                  for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                    t.set(r[u + 0], r[u + 1], r[u + 2]),
                      e.set(r[u + 3], r[u + 4], r[u + 5]),
                      n.set(r[u + 6], r[u + 7], r[u + 8]),
                      a.set(s[d + 0], s[d + 1]),
                      o.set(s[d + 2], s[d + 3]),
                      l.set(s[d + 4], s[d + 5]),
                      i.copy(t).add(e).add(n).divideScalar(3);
                    const p = h(i);
                    c(a, d + 0, t, p), c(o, d + 2, e, p), c(l, d + 4, n, p);
                  }
                })(),
                  (function () {
                    for (let t = 0; t < s.length; t += 6) {
                      const e = s[t + 0],
                        n = s[t + 2],
                        i = s[t + 4],
                        r = Math.max(e, n, i),
                        a = Math.min(e, n, i);
                      r > 0.9 &&
                        a < 0.1 &&
                        (e < 0.2 && (s[t + 0] += 1),
                        n < 0.2 && (s[t + 2] += 1),
                        i < 0.2 && (s[t + 4] += 1));
                    }
                  })();
              })(),
              this.setAttribute("position", new Si(r, 3)),
              this.setAttribute("normal", new Si(r.slice(), 3)),
              this.setAttribute("uv", new Si(s, 2)),
              0 === i ? this.computeVertexNormals() : this.normalizeNormals();
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new ic(t.vertices, t.indices, t.radius, t.details);
          }
        }
        class rc extends ic {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2,
              i = 1 / n;
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                0,
                -n,
                0,
                -i,
                n,
                0,
                -i,
                -n,
                0,
                i,
                n,
                0,
                i,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10,
                17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6,
                2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
                4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              t,
              e
            ),
              (this.type = "DodecahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
          static fromJSON(t) {
            return new rc(t.radius, t.detail);
          }
        }
        const sc = new ke(),
          ac = new ke(),
          oc = new ke(),
          lc = new ni();
        class cc extends Li {
          constructor(t = null, e = 1) {
            if (
              (super(),
              (this.type = "EdgesGeometry"),
              (this.parameters = { geometry: t, thresholdAngle: e }),
              null !== t)
            ) {
              const n = 4,
                i = Math.pow(10, n),
                r = Math.cos(ee * e),
                s = t.getIndex(),
                a = t.getAttribute("position"),
                o = s ? s.count : a.count,
                l = [0, 0, 0],
                c = ["a", "b", "c"],
                h = new Array(3),
                u = {},
                d = [];
              for (let t = 0; t < o; t += 3) {
                s
                  ? ((l[0] = s.getX(t)), (l[1] = s.getX(t + 1)), (l[2] = s.getX(t + 2)))
                  : ((l[0] = t), (l[1] = t + 1), (l[2] = t + 2));
                const { a: e, b: n, c: o } = lc;
                if (
                  (e.fromBufferAttribute(a, l[0]),
                  n.fromBufferAttribute(a, l[1]),
                  o.fromBufferAttribute(a, l[2]),
                  lc.getNormal(oc),
                  (h[0] = `${Math.round(e.x * i)},${Math.round(e.y * i)},${Math.round(e.z * i)}`),
                  (h[1] = `${Math.round(n.x * i)},${Math.round(n.y * i)},${Math.round(n.z * i)}`),
                  (h[2] = `${Math.round(o.x * i)},${Math.round(o.y * i)},${Math.round(o.z * i)}`),
                  h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
                )
                  for (let t = 0; t < 3; t++) {
                    const e = (t + 1) % 3,
                      n = h[t],
                      i = h[e],
                      s = lc[c[t]],
                      a = lc[c[e]],
                      o = `${n}_${i}`,
                      p = `${i}_${n}`;
                    p in u && u[p]
                      ? (oc.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)),
                        (u[p] = null))
                      : o in u || (u[o] = { index0: l[t], index1: l[e], normal: oc.clone() });
                  }
              }
              for (const t in u)
                if (u[t]) {
                  const { index0: e, index1: n } = u[t];
                  sc.fromBufferAttribute(a, e),
                    ac.fromBufferAttribute(a, n),
                    d.push(sc.x, sc.y, sc.z),
                    d.push(ac.x, ac.y, ac.z);
                }
              this.setAttribute("position", new Si(d, 3));
            }
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
        }
        class hc extends Jl {
          constructor(t) {
            super(t), (this.uuid = ie()), (this.type = "Shape"), (this.holes = []);
          }
          getPointsHoles(t) {
            const e = [];
            for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
            return e;
          }
          extractPoints(t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
          }
          copy(t) {
            super.copy(t), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.uuid = this.uuid), (t.holes = []);
            for (let e = 0, n = this.holes.length; e < n; e++) {
              const n = this.holes[e];
              t.holes.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(new Jl().fromJSON(n));
            }
            return this;
          }
        }
        function uc(t, e, n, i, r) {
          let s, a;
          if (
            r ===
            (function (t, e, n, i) {
              let r = 0;
              for (let s = e, a = n - i; s < n; s += i)
                (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);
              return r;
            })(t, e, n, i) >
              0
          )
            for (s = e; s < n; s += i) a = Ic(s, t[s], t[s + 1], a);
          else for (s = n - i; s >= e; s -= i) a = Ic(s, t[s], t[s + 1], a);
          return a && Ac(a, a.next) && (Uc(a), (a = a.next)), a;
        }
        function dc(t, e) {
          if (!t) return t;
          e || (e = t);
          let n,
            i = t;
          do {
            if (((n = !1), i.steiner || (!Ac(i, i.next) && 0 !== Tc(i.prev, i, i.next))))
              i = i.next;
            else {
              if ((Uc(i), (i = e = i.prev), i === i.next)) break;
              n = !0;
            }
          } while (n || i !== e);
          return e;
        }
        function pc(t, e, n, i, r, s, a) {
          if (!t) return;
          !a &&
            s &&
            (function (t, e, n, i) {
              let r = t;
              do {
                0 === r.z && (r.z = Mc(r.x, r.y, e, n, i)),
                  (r.prevZ = r.prev),
                  (r.nextZ = r.next),
                  (r = r.next);
              } while (r !== t);
              (r.prevZ.nextZ = null),
                (r.prevZ = null),
                (function (t) {
                  let e,
                    n,
                    i,
                    r,
                    s,
                    a,
                    o,
                    l,
                    c = 1;
                  do {
                    for (n = t, t = null, s = null, a = 0; n; ) {
                      for (a++, i = n, o = 0, e = 0; e < c && (o++, (i = i.nextZ), i); e++);
                      for (l = c; o > 0 || (l > 0 && i); )
                        0 !== o && (0 === l || !i || n.z <= i.z)
                          ? ((r = n), (n = n.nextZ), o--)
                          : ((r = i), (i = i.nextZ), l--),
                          s ? (s.nextZ = r) : (t = r),
                          (r.prevZ = s),
                          (s = r);
                      n = i;
                    }
                    (s.nextZ = null), (c *= 2);
                  } while (a > 1);
                })(r);
            })(t, i, r, s);
          let o,
            l,
            c = t;
          for (; t.prev !== t.next; )
            if (((o = t.prev), (l = t.next), s ? mc(t, i, r, s) : fc(t)))
              e.push((o.i / n) | 0),
                e.push((t.i / n) | 0),
                e.push((l.i / n) | 0),
                Uc(t),
                (t = l.next),
                (c = l.next);
            else if ((t = l) === c) {
              a
                ? 1 === a
                  ? pc((t = gc(dc(t), e, n)), e, n, i, r, s, 2)
                  : 2 === a && _c(t, e, n, i, r, s)
                : pc(dc(t), e, n, i, r, s, 1);
              break;
            }
        }
        function fc(t) {
          const e = t.prev,
            n = t,
            i = t.next;
          if (Tc(e, n, i) >= 0) return !1;
          const r = e.x,
            s = n.x,
            a = i.x,
            o = e.y,
            l = n.y,
            c = i.y,
            h = r < s ? (r < a ? r : a) : s < a ? s : a,
            u = o < l ? (o < c ? o : c) : l < c ? l : c,
            d = r > s ? (r > a ? r : a) : s > a ? s : a,
            p = o > l ? (o > c ? o : c) : l > c ? l : c;
          let f = i.next;
          for (; f !== e; ) {
            if (
              f.x >= h &&
              f.x <= d &&
              f.y >= u &&
              f.y <= p &&
              bc(r, o, s, l, a, c, f.x, f.y) &&
              Tc(f.prev, f, f.next) >= 0
            )
              return !1;
            f = f.next;
          }
          return !0;
        }
        function mc(t, e, n, i) {
          const r = t.prev,
            s = t,
            a = t.next;
          if (Tc(r, s, a) >= 0) return !1;
          const o = r.x,
            l = s.x,
            c = a.x,
            h = r.y,
            u = s.y,
            d = a.y,
            p = o < l ? (o < c ? o : c) : l < c ? l : c,
            f = h < u ? (h < d ? h : d) : u < d ? u : d,
            m = o > l ? (o > c ? o : c) : l > c ? l : c,
            g = h > u ? (h > d ? h : d) : u > d ? u : d,
            _ = Mc(p, f, e, n, i),
            v = Mc(m, g, e, n, i);
          let x = t.prevZ,
            y = t.nextZ;
          for (; x && x.z >= _ && y && y.z <= v; ) {
            if (
              x.x >= p &&
              x.x <= m &&
              x.y >= f &&
              x.y <= g &&
              x !== r &&
              x !== a &&
              bc(o, h, l, u, c, d, x.x, x.y) &&
              Tc(x.prev, x, x.next) >= 0
            )
              return !1;
            if (
              ((x = x.prevZ),
              y.x >= p &&
                y.x <= m &&
                y.y >= f &&
                y.y <= g &&
                y !== r &&
                y !== a &&
                bc(o, h, l, u, c, d, y.x, y.y) &&
                Tc(y.prev, y, y.next) >= 0)
            )
              return !1;
            y = y.nextZ;
          }
          for (; x && x.z >= _; ) {
            if (
              x.x >= p &&
              x.x <= m &&
              x.y >= f &&
              x.y <= g &&
              x !== r &&
              x !== a &&
              bc(o, h, l, u, c, d, x.x, x.y) &&
              Tc(x.prev, x, x.next) >= 0
            )
              return !1;
            x = x.prevZ;
          }
          for (; y && y.z <= v; ) {
            if (
              y.x >= p &&
              y.x <= m &&
              y.y >= f &&
              y.y <= g &&
              y !== r &&
              y !== a &&
              bc(o, h, l, u, c, d, y.x, y.y) &&
              Tc(y.prev, y, y.next) >= 0
            )
              return !1;
            y = y.nextZ;
          }
          return !0;
        }
        function gc(t, e, n) {
          let i = t;
          do {
            const r = i.prev,
              s = i.next.next;
            !Ac(r, s) &&
              wc(r, i, i.next, s) &&
              Lc(r, s) &&
              Lc(s, r) &&
              (e.push((r.i / n) | 0),
              e.push((i.i / n) | 0),
              e.push((s.i / n) | 0),
              Uc(i),
              Uc(i.next),
              (i = t = s)),
              (i = i.next);
          } while (i !== t);
          return dc(i);
        }
        function _c(t, e, n, i, r, s) {
          let a = t;
          do {
            let t = a.next.next;
            for (; t !== a.prev; ) {
              if (a.i !== t.i && Ec(a, t)) {
                let o = Pc(a, t);
                return (
                  (a = dc(a, a.next)),
                  (o = dc(o, o.next)),
                  pc(a, e, n, i, r, s, 0),
                  void pc(o, e, n, i, r, s, 0)
                );
              }
              t = t.next;
            }
            a = a.next;
          } while (a !== t);
        }
        function vc(t, e) {
          return t.x - e.x;
        }
        function xc(t, e) {
          const n = (function (t, e) {
            let n,
              i = e,
              r = -1 / 0;
            const s = t.x,
              a = t.y;
            do {
              if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                const t = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                if (t <= s && t > r && ((r = t), (n = i.x < i.next.x ? i : i.next), t === s))
                  return n;
              }
              i = i.next;
            } while (i !== e);
            if (!n) return null;
            const o = n,
              l = n.x,
              c = n.y;
            let h,
              u = 1 / 0;
            i = n;
            do {
              s >= i.x &&
                i.x >= l &&
                s !== i.x &&
                bc(a < c ? s : r, a, l, c, a < c ? r : s, a, i.x, i.y) &&
                ((h = Math.abs(a - i.y) / (s - i.x)),
                Lc(i, t) &&
                  (h < u || (h === u && (i.x > n.x || (i.x === n.x && yc(n, i))))) &&
                  ((n = i), (u = h))),
                (i = i.next);
            } while (i !== o);
            return n;
          })(t, e);
          if (!n) return e;
          const i = Pc(n, t);
          return dc(i, i.next), dc(n, n.next);
        }
        function yc(t, e) {
          return Tc(t.prev, t, e.prev) < 0 && Tc(e.next, t, t.next) < 0;
        }
        function Mc(t, e, n, i, r) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 & ((t = 16711935 & ((t = ((t - n) * r) | 0) | (t << 8))) | (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 & ((e = 16711935 & ((e = ((e - i) * r) | 0) | (e << 8))) | (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        }
        function Sc(t) {
          let e = t,
            n = t;
          do {
            (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
          } while (e !== t);
          return n;
        }
        function bc(t, e, n, i, r, s, a, o) {
          return (
            (r - a) * (e - o) >= (t - a) * (s - o) &&
            (t - a) * (i - o) >= (n - a) * (e - o) &&
            (n - a) * (s - o) >= (r - a) * (i - o)
          );
        }
        function Ec(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !(function (t, e) {
              let n = t;
              do {
                if (
                  n.i !== t.i &&
                  n.next.i !== t.i &&
                  n.i !== e.i &&
                  n.next.i !== e.i &&
                  wc(n, n.next, t, e)
                )
                  return !0;
                n = n.next;
              } while (n !== t);
              return !1;
            })(t, e) &&
            ((Lc(t, e) &&
              Lc(e, t) &&
              (function (t, e) {
                let n = t,
                  i = !1;
                const r = (t.x + e.x) / 2,
                  s = (t.y + e.y) / 2;
                do {
                  n.y > s != n.next.y > s &&
                    n.next.y !== n.y &&
                    r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                    (i = !i),
                    (n = n.next);
                } while (n !== t);
                return i;
              })(t, e) &&
              (Tc(t.prev, t, e.prev) || Tc(t, e.prev, e))) ||
              (Ac(t, e) && Tc(t.prev, t, t.next) > 0 && Tc(e.prev, e, e.next) > 0))
          );
        }
        function Tc(t, e, n) {
          return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
        }
        function Ac(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        function wc(t, e, n, i) {
          const r = Cc(Tc(t, e, n)),
            s = Cc(Tc(t, e, i)),
            a = Cc(Tc(n, i, t)),
            o = Cc(Tc(n, i, e));
          return (
            (r !== s && a !== o) ||
            !(0 !== r || !Rc(t, n, e)) ||
            !(0 !== s || !Rc(t, i, e)) ||
            !(0 !== a || !Rc(n, t, i)) ||
            !(0 !== o || !Rc(n, e, i))
          );
        }
        function Rc(t, e, n) {
          return (
            e.x <= Math.max(t.x, n.x) &&
            e.x >= Math.min(t.x, n.x) &&
            e.y <= Math.max(t.y, n.y) &&
            e.y >= Math.min(t.y, n.y)
          );
        }
        function Cc(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0;
        }
        function Lc(t, e) {
          return Tc(t.prev, t, t.next) < 0
            ? Tc(t, e, t.next) >= 0 && Tc(t, t.prev, e) >= 0
            : Tc(t, e, t.prev) < 0 || Tc(t, t.next, e) < 0;
        }
        function Pc(t, e) {
          const n = new Nc(t.i, t.x, t.y),
            i = new Nc(e.i, e.x, e.y),
            r = t.next,
            s = e.prev;
          return (
            (t.next = e),
            (e.prev = t),
            (n.next = r),
            (r.prev = n),
            (i.next = n),
            (n.prev = i),
            (s.next = i),
            (i.prev = s),
            i
          );
        }
        function Ic(t, e, n, i) {
          const r = new Nc(t, e, n);
          return (
            i
              ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
              : ((r.prev = r), (r.next = r)),
            r
          );
        }
        function Uc(t) {
          (t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function Nc(t, e, n) {
          (this.i = t),
            (this.x = e),
            (this.y = n),
            (this.prev = null),
            (this.next = null),
            (this.z = 0),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1);
        }
        class Dc {
          static area(t) {
            const e = t.length;
            let n = 0;
            for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
            return 0.5 * n;
          }
          static isClockWise(t) {
            return Dc.area(t) < 0;
          }
          static triangulateShape(t, e) {
            const n = [],
              i = [],
              r = [];
            Oc(t), Bc(n, t);
            let s = t.length;
            e.forEach(Oc);
            for (let t = 0; t < e.length; t++) i.push(s), (s += e[t].length), Bc(n, e[t]);
            const a = (function (t, e, n = 2) {
              const i = e && e.length,
                r = i ? e[0] * n : t.length;
              let s = uc(t, 0, r, n, !0);
              const a = [];
              if (!s || s.next === s.prev) return a;
              let o, l, c, h, u, d, p;
              if (
                (i &&
                  (s = (function (t, e, n, i) {
                    const r = [];
                    let s, a, o, l, c;
                    for (s = 0, a = e.length; s < a; s++)
                      (o = e[s] * i),
                        (l = s < a - 1 ? e[s + 1] * i : t.length),
                        (c = uc(t, o, l, i, !1)),
                        c === c.next && (c.steiner = !0),
                        r.push(Sc(c));
                    for (r.sort(vc), s = 0; s < r.length; s++) n = xc(r[s], n);
                    return n;
                  })(t, e, s, n)),
                t.length > 80 * n)
              ) {
                (o = c = t[0]), (l = h = t[1]);
                for (let e = n; e < r; e += n)
                  (u = t[e]),
                    (d = t[e + 1]),
                    u < o && (o = u),
                    d < l && (l = d),
                    u > c && (c = u),
                    d > h && (h = d);
                (p = Math.max(c - o, h - l)), (p = 0 !== p ? 32767 / p : 0);
              }
              return pc(s, a, n, o, l, p, 0), a;
            })(n, i);
            for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
            return r;
          }
        }
        function Oc(t) {
          const e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function Bc(t, e) {
          for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
        }
        class Fc extends Li {
          constructor(
            t = new hc([
              new de(0.5, 0.5),
              new de(-0.5, 0.5),
              new de(-0.5, -0.5),
              new de(0.5, -0.5),
            ]),
            e = {}
          ) {
            super(),
              (this.type = "ExtrudeGeometry"),
              (this.parameters = { shapes: t, options: e }),
              (t = Array.isArray(t) ? t : [t]);
            const n = this,
              i = [],
              r = [];
            for (let e = 0, n = t.length; e < n; e++) s(t[e]);
            function s(t) {
              const s = [],
                a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                o = void 0 !== e.steps ? e.steps : 1,
                l = void 0 !== e.depth ? e.depth : 1;
              let c = void 0 === e.bevelEnabled || e.bevelEnabled,
                h = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
                u = void 0 !== e.bevelSize ? e.bevelSize : h - 0.1,
                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
              const f = e.extrudePath,
                m = void 0 !== e.UVGenerator ? e.UVGenerator : zc;
              let g,
                _,
                v,
                x,
                y,
                M = !1;
              f &&
                ((g = f.getSpacedPoints(o)),
                (M = !0),
                (c = !1),
                (_ = f.computeFrenetFrames(o, !1)),
                (v = new ke()),
                (x = new ke()),
                (y = new ke())),
                c || ((p = 0), (h = 0), (u = 0), (d = 0));
              const S = t.extractPoints(a);
              let b = S.shape;
              const E = S.holes;
              if (!Dc.isClockWise(b)) {
                b = b.reverse();
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = E[t];
                  Dc.isClockWise(e) && (E[t] = e.reverse());
                }
              }
              const T = Dc.triangulateShape(b, E),
                A = b;
              for (let t = 0, e = E.length; t < e; t++) {
                const e = E[t];
                b = b.concat(e);
              }
              function w(t, e, n) {
                return (
                  e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                  t.clone().addScaledVector(e, n)
                );
              }
              const R = b.length,
                C = T.length;
              function L(t, e, n) {
                let i, r, s;
                const a = t.x - e.x,
                  o = t.y - e.y,
                  l = n.x - t.x,
                  c = n.y - t.y,
                  h = a * a + o * o,
                  u = a * c - o * l;
                if (Math.abs(u) > Number.EPSILON) {
                  const u = Math.sqrt(h),
                    d = Math.sqrt(l * l + c * c),
                    p = e.x - o / u,
                    f = e.y + a / u,
                    m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (a * c - o * l);
                  (i = p + a * m - t.x), (r = f + o * m - t.y);
                  const g = i * i + r * r;
                  if (g <= 2) return new de(i, r);
                  s = Math.sqrt(g / 2);
                } else {
                  let t = !1;
                  a > Number.EPSILON
                    ? l > Number.EPSILON && (t = !0)
                    : a < -Number.EPSILON
                    ? l < -Number.EPSILON && (t = !0)
                    : Math.sign(o) === Math.sign(c) && (t = !0),
                    t
                      ? ((i = -o), (r = a), (s = Math.sqrt(h)))
                      : ((i = a), (r = o), (s = Math.sqrt(h / 2)));
                }
                return new de(i / s, r / s);
              }
              const P = [];
              for (let t = 0, e = A.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)
                n === e && (n = 0), i === e && (i = 0), (P[t] = L(A[t], A[n], A[i]));
              const I = [];
              let U,
                N = P.concat();
              for (let t = 0, e = E.length; t < e; t++) {
                const e = E[t];
                U = [];
                for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++)
                  i === n && (i = 0), r === n && (r = 0), (U[t] = L(e[t], e[i], e[r]));
                I.push(U), (N = N.concat(U));
              }
              for (let t = 0; t < p; t++) {
                const e = t / p,
                  n = h * Math.cos((e * Math.PI) / 2),
                  i = u * Math.sin((e * Math.PI) / 2) + d;
                for (let t = 0, e = A.length; t < e; t++) {
                  const e = w(A[t], P[t], i);
                  B(e.x, e.y, -n);
                }
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = E[t];
                  U = I[t];
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = w(e[t], U[t], i);
                    B(r.x, r.y, -n);
                  }
                }
              }
              const D = u + d;
              for (let t = 0; t < R; t++) {
                const e = c ? w(b[t], N[t], D) : b[t];
                M
                  ? (x.copy(_.normals[0]).multiplyScalar(e.x),
                    v.copy(_.binormals[0]).multiplyScalar(e.y),
                    y.copy(g[0]).add(x).add(v),
                    B(y.x, y.y, y.z))
                  : B(e.x, e.y, 0);
              }
              for (let t = 1; t <= o; t++)
                for (let e = 0; e < R; e++) {
                  const n = c ? w(b[e], N[e], D) : b[e];
                  M
                    ? (x.copy(_.normals[t]).multiplyScalar(n.x),
                      v.copy(_.binormals[t]).multiplyScalar(n.y),
                      y.copy(g[t]).add(x).add(v),
                      B(y.x, y.y, y.z))
                    : B(n.x, n.y, (l / o) * t);
                }
              for (let t = p - 1; t >= 0; t--) {
                const e = t / p,
                  n = h * Math.cos((e * Math.PI) / 2),
                  i = u * Math.sin((e * Math.PI) / 2) + d;
                for (let t = 0, e = A.length; t < e; t++) {
                  const e = w(A[t], P[t], i);
                  B(e.x, e.y, l + n);
                }
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = E[t];
                  U = I[t];
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = w(e[t], U[t], i);
                    M ? B(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : B(r.x, r.y, l + n);
                  }
                }
              }
              function O(t, e) {
                let n = t.length;
                for (; --n >= 0; ) {
                  const i = n;
                  let r = n - 1;
                  r < 0 && (r = t.length - 1);
                  for (let t = 0, n = o + 2 * p; t < n; t++) {
                    const n = R * t,
                      s = R * (t + 1);
                    z(e + i + n, e + r + n, e + r + s, e + i + s);
                  }
                }
              }
              function B(t, e, n) {
                s.push(t), s.push(e), s.push(n);
              }
              function F(t, e, r) {
                H(t), H(e), H(r);
                const s = i.length / 3,
                  a = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
                G(a[0]), G(a[1]), G(a[2]);
              }
              function z(t, e, r, s) {
                H(t), H(e), H(s), H(e), H(r), H(s);
                const a = i.length / 3,
                  o = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                G(o[0]), G(o[1]), G(o[3]), G(o[1]), G(o[2]), G(o[3]);
              }
              function H(t) {
                i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]);
              }
              function G(t) {
                r.push(t.x), r.push(t.y);
              }
              !(function () {
                const t = i.length / 3;
                if (c) {
                  let t = 0,
                    e = R * t;
                  for (let t = 0; t < C; t++) {
                    const n = T[t];
                    F(n[2] + e, n[1] + e, n[0] + e);
                  }
                  (t = o + 2 * p), (e = R * t);
                  for (let t = 0; t < C; t++) {
                    const n = T[t];
                    F(n[0] + e, n[1] + e, n[2] + e);
                  }
                } else {
                  for (let t = 0; t < C; t++) {
                    const e = T[t];
                    F(e[2], e[1], e[0]);
                  }
                  for (let t = 0; t < C; t++) {
                    const e = T[t];
                    F(e[0] + R * o, e[1] + R * o, e[2] + R * o);
                  }
                }
                n.addGroup(t, i.length / 3 - t, 0);
              })(),
                (function () {
                  const t = i.length / 3;
                  let e = 0;
                  O(A, e), (e += A.length);
                  for (let t = 0, n = E.length; t < n; t++) {
                    const n = E[t];
                    O(n, e), (e += n.length);
                  }
                  n.addGroup(t, i.length / 3 - t, 1);
                })();
            }
            this.setAttribute("position", new Si(i, 3)),
              this.setAttribute("uv", new Si(r, 2)),
              this.computeVertexNormals();
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (function (t, e, n) {
              if (((n.shapes = []), Array.isArray(t)))
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  n.shapes.push(i.uuid);
                }
              else n.shapes.push(t.uuid);
              return (
                (n.options = Object.assign({}, e)),
                void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()),
                n
              );
            })(this.parameters.shapes, this.parameters.options, t);
          }
          static fromJSON(t, e) {
            const n = [];
            for (let i = 0, r = t.shapes.length; i < r; i++) {
              const r = e[t.shapes[i]];
              n.push(r);
            }
            const i = t.options.extrudePath;
            return (
              void 0 !== i && (t.options.extrudePath = new Kl[i.type]().fromJSON(i)),
              new Fc(n, t.options)
            );
          }
        }
        const zc = {
          generateTopUV: function (t, e, n, i, r) {
            const s = e[3 * n],
              a = e[3 * n + 1],
              o = e[3 * i],
              l = e[3 * i + 1],
              c = e[3 * r],
              h = e[3 * r + 1];
            return [new de(s, a), new de(o, l), new de(c, h)];
          },
          generateSideWallUV: function (t, e, n, i, r, s) {
            const a = e[3 * n],
              o = e[3 * n + 1],
              l = e[3 * n + 2],
              c = e[3 * i],
              h = e[3 * i + 1],
              u = e[3 * i + 2],
              d = e[3 * r],
              p = e[3 * r + 1],
              f = e[3 * r + 2],
              m = e[3 * s],
              g = e[3 * s + 1],
              _ = e[3 * s + 2];
            return Math.abs(o - h) < Math.abs(a - c)
              ? [new de(a, 1 - l), new de(c, 1 - u), new de(d, 1 - f), new de(m, 1 - _)]
              : [new de(o, 1 - l), new de(h, 1 - u), new de(p, 1 - f), new de(g, 1 - _)];
          },
        };
        class Hc extends ic {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2;
            super(
              [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10,
                7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2,
                10, 8, 6, 7, 9, 8, 1,
              ],
              t,
              e
            ),
              (this.type = "IcosahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
          static fromJSON(t) {
            return new Hc(t.radius, t.detail);
          }
        }
        class Gc extends ic {
          constructor(t = 1, e = 0) {
            super(
              [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
              [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
              t,
              e
            ),
              (this.type = "OctahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
          static fromJSON(t) {
            return new Gc(t.radius, t.detail);
          }
        }
        class kc extends Li {
          constructor(t = 0.5, e = 1, n = 32, i = 1, r = 0, s = 2 * Math.PI) {
            super(),
              (this.type = "RingGeometry"),
              (this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: s,
              }),
              (n = Math.max(3, n));
            const a = [],
              o = [],
              l = [],
              c = [];
            let h = t;
            const u = (e - t) / (i = Math.max(1, i)),
              d = new ke(),
              p = new de();
            for (let t = 0; t <= i; t++) {
              for (let t = 0; t <= n; t++) {
                const i = r + (t / n) * s;
                (d.x = h * Math.cos(i)),
                  (d.y = h * Math.sin(i)),
                  o.push(d.x, d.y, d.z),
                  l.push(0, 0, 1),
                  (p.x = (d.x / e + 1) / 2),
                  (p.y = (d.y / e + 1) / 2),
                  c.push(p.x, p.y);
              }
              h += u;
            }
            for (let t = 0; t < i; t++) {
              const e = t * (n + 1);
              for (let t = 0; t < n; t++) {
                const i = t + e,
                  r = i,
                  s = i + n + 1,
                  o = i + n + 2,
                  l = i + 1;
                a.push(r, s, l), a.push(s, o, l);
              }
            }
            this.setIndex(a),
              this.setAttribute("position", new Si(o, 3)),
              this.setAttribute("normal", new Si(l, 3)),
              this.setAttribute("uv", new Si(c, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new kc(
              t.innerRadius,
              t.outerRadius,
              t.thetaSegments,
              t.phiSegments,
              t.thetaStart,
              t.thetaLength
            );
          }
        }
        class Vc extends Li {
          constructor(t = new hc([new de(0, 0.5), new de(-0.5, -0.5), new de(0.5, -0.5)]), e = 12) {
            super(),
              (this.type = "ShapeGeometry"),
              (this.parameters = { shapes: t, curveSegments: e });
            const n = [],
              i = [],
              r = [],
              s = [];
            let a = 0,
              o = 0;
            if (!1 === Array.isArray(t)) l(t);
            else
              for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);
            function l(t) {
              const a = i.length / 3,
                l = t.extractPoints(e);
              let c = l.shape;
              const h = l.holes;
              !1 === Dc.isClockWise(c) && (c = c.reverse());
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                !0 === Dc.isClockWise(e) && (h[t] = e.reverse());
              }
              const u = Dc.triangulateShape(c, h);
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                c = c.concat(e);
              }
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y);
              }
              for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t],
                  i = e[0] + a,
                  r = e[1] + a,
                  s = e[2] + a;
                n.push(i, r, s), (o += 3);
              }
            }
            this.setIndex(n),
              this.setAttribute("position", new Si(i, 3)),
              this.setAttribute("normal", new Si(r, 3)),
              this.setAttribute("uv", new Si(s, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (function (t, e) {
              if (((e.shapes = []), Array.isArray(t)))
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n];
                  e.shapes.push(i.uuid);
                }
              else e.shapes.push(t.uuid);
              return e;
            })(this.parameters.shapes, t);
          }
          static fromJSON(t, e) {
            const n = [];
            for (let i = 0, r = t.shapes.length; i < r; i++) {
              const r = e[t.shapes[i]];
              n.push(r);
            }
            return new Vc(n, t.curveSegments);
          }
        }
        class Wc extends Li {
          constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, a = Math.PI) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: s,
                thetaLength: a,
              }),
              (e = Math.max(3, Math.floor(e))),
              (n = Math.max(2, Math.floor(n)));
            const o = Math.min(s + a, Math.PI);
            let l = 0;
            const c = [],
              h = new ke(),
              u = new ke(),
              d = [],
              p = [],
              f = [],
              m = [];
            for (let d = 0; d <= n; d++) {
              const g = [],
                _ = d / n;
              let v = 0;
              0 === d && 0 === s ? (v = 0.5 / e) : d === n && o === Math.PI && (v = -0.5 / e);
              for (let n = 0; n <= e; n++) {
                const o = n / e;
                (h.x = -t * Math.cos(i + o * r) * Math.sin(s + _ * a)),
                  (h.y = t * Math.cos(s + _ * a)),
                  (h.z = t * Math.sin(i + o * r) * Math.sin(s + _ * a)),
                  p.push(h.x, h.y, h.z),
                  u.copy(h).normalize(),
                  f.push(u.x, u.y, u.z),
                  m.push(o + v, 1 - _),
                  g.push(l++);
              }
              c.push(g);
            }
            for (let t = 0; t < n; t++)
              for (let i = 0; i < e; i++) {
                const e = c[t][i + 1],
                  r = c[t][i],
                  a = c[t + 1][i],
                  l = c[t + 1][i + 1];
                (0 !== t || s > 0) && d.push(e, r, l),
                  (t !== n - 1 || o < Math.PI) && d.push(r, a, l);
              }
            this.setIndex(d),
              this.setAttribute("position", new Si(p, 3)),
              this.setAttribute("normal", new Si(f, 3)),
              this.setAttribute("uv", new Si(m, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new Wc(
              t.radius,
              t.widthSegments,
              t.heightSegments,
              t.phiStart,
              t.phiLength,
              t.thetaStart,
              t.thetaLength
            );
          }
        }
        class Xc extends ic {
          constructor(t = 1, e = 0) {
            super(
              [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
              [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
              t,
              e
            ),
              (this.type = "TetrahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
          static fromJSON(t) {
            return new Xc(t.radius, t.detail);
          }
        }
        class jc extends Li {
          constructor(t = 1, e = 0.4, n = 12, i = 48, r = 2 * Math.PI) {
            super(),
              (this.type = "TorusGeometry"),
              (this.parameters = {
                radius: t,
                tube: e,
                radialSegments: n,
                tubularSegments: i,
                arc: r,
              }),
              (n = Math.floor(n)),
              (i = Math.floor(i));
            const s = [],
              a = [],
              o = [],
              l = [],
              c = new ke(),
              h = new ke(),
              u = new ke();
            for (let s = 0; s <= n; s++)
              for (let d = 0; d <= i; d++) {
                const p = (d / i) * r,
                  f = (s / n) * Math.PI * 2;
                (h.x = (t + e * Math.cos(f)) * Math.cos(p)),
                  (h.y = (t + e * Math.cos(f)) * Math.sin(p)),
                  (h.z = e * Math.sin(f)),
                  a.push(h.x, h.y, h.z),
                  (c.x = t * Math.cos(p)),
                  (c.y = t * Math.sin(p)),
                  u.subVectors(h, c).normalize(),
                  o.push(u.x, u.y, u.z),
                  l.push(d / i),
                  l.push(s / n);
              }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * t + e - 1,
                  r = (i + 1) * (t - 1) + e - 1,
                  a = (i + 1) * (t - 1) + e,
                  o = (i + 1) * t + e;
                s.push(n, r, o), s.push(r, a, o);
              }
            this.setIndex(s),
              this.setAttribute("position", new Si(a, 3)),
              this.setAttribute("normal", new Si(o, 3)),
              this.setAttribute("uv", new Si(l, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new jc(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc);
          }
        }
        class qc extends Li {
          constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, s = 3) {
            super(),
              (this.type = "TorusKnotGeometry"),
              (this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: n,
                radialSegments: i,
                p: r,
                q: s,
              }),
              (n = Math.floor(n)),
              (i = Math.floor(i));
            const a = [],
              o = [],
              l = [],
              c = [],
              h = new ke(),
              u = new ke(),
              d = new ke(),
              p = new ke(),
              f = new ke(),
              m = new ke(),
              g = new ke();
            for (let a = 0; a <= n; ++a) {
              const v = (a / n) * r * Math.PI * 2;
              _(v, r, s, t, d),
                _(v + 0.01, r, s, t, p),
                m.subVectors(p, d),
                g.addVectors(p, d),
                f.crossVectors(m, g),
                g.crossVectors(f, m),
                f.normalize(),
                g.normalize();
              for (let t = 0; t <= i; ++t) {
                const r = (t / i) * Math.PI * 2,
                  s = -e * Math.cos(r),
                  p = e * Math.sin(r);
                (h.x = d.x + (s * g.x + p * f.x)),
                  (h.y = d.y + (s * g.y + p * f.y)),
                  (h.z = d.z + (s * g.z + p * f.z)),
                  o.push(h.x, h.y, h.z),
                  u.subVectors(h, d).normalize(),
                  l.push(u.x, u.y, u.z),
                  c.push(a / n),
                  c.push(t / i);
              }
            }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  s = (i + 1) * t + e,
                  o = (i + 1) * (t - 1) + e;
                a.push(n, r, o), a.push(r, s, o);
              }
            function _(t, e, n, i, r) {
              const s = Math.cos(t),
                a = Math.sin(t),
                o = (n / e) * t,
                l = Math.cos(o);
              (r.x = i * (2 + l) * 0.5 * s),
                (r.y = i * (2 + l) * a * 0.5),
                (r.z = i * Math.sin(o) * 0.5);
            }
            this.setIndex(a),
              this.setAttribute("position", new Si(o, 3)),
              this.setAttribute("normal", new Si(l, 3)),
              this.setAttribute("uv", new Si(c, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new qc(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q);
          }
        }
        class Yc extends Li {
          constructor(
            t = new ql(new ke(-1, -1, 0), new ke(-1, 1, 0), new ke(1, 1, 0)),
            e = 64,
            n = 1,
            i = 8,
            r = !1
          ) {
            super(),
              (this.type = "TubeGeometry"),
              (this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: r,
              });
            const s = t.computeFrenetFrames(e, r);
            (this.tangents = s.tangents),
              (this.normals = s.normals),
              (this.binormals = s.binormals);
            const a = new ke(),
              o = new ke(),
              l = new de();
            let c = new ke();
            const h = [],
              u = [],
              d = [],
              p = [];
            function f(r) {
              c = t.getPointAt(r / e, c);
              const l = s.normals[r],
                d = s.binormals[r];
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * Math.PI * 2,
                  r = Math.sin(e),
                  s = -Math.cos(e);
                (o.x = s * l.x + r * d.x),
                  (o.y = s * l.y + r * d.y),
                  (o.z = s * l.z + r * d.z),
                  o.normalize(),
                  u.push(o.x, o.y, o.z),
                  (a.x = c.x + n * o.x),
                  (a.y = c.y + n * o.y),
                  (a.z = c.z + n * o.z),
                  h.push(a.x, a.y, a.z);
              }
            }
            !(function () {
              for (let t = 0; t < e; t++) f(t);
              f(!1 === r ? e : 0),
                (function () {
                  for (let t = 0; t <= e; t++)
                    for (let n = 0; n <= i; n++) (l.x = t / e), (l.y = n / i), d.push(l.x, l.y);
                })(),
                (function () {
                  for (let t = 1; t <= e; t++)
                    for (let e = 1; e <= i; e++) {
                      const n = (i + 1) * (t - 1) + (e - 1),
                        r = (i + 1) * t + (e - 1),
                        s = (i + 1) * t + e,
                        a = (i + 1) * (t - 1) + e;
                      p.push(n, r, a), p.push(r, s, a);
                    }
                })();
            })(),
              this.setIndex(p),
              this.setAttribute("position", new Si(h, 3)),
              this.setAttribute("normal", new Si(u, 3)),
              this.setAttribute("uv", new Si(d, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.path = this.parameters.path.toJSON()), t;
          }
          static fromJSON(t) {
            return new Yc(
              new Kl[t.path.type]().fromJSON(t.path),
              t.tubularSegments,
              t.radius,
              t.radialSegments,
              t.closed
            );
          }
        }
        class Kc extends Li {
          constructor(t = null) {
            if (
              (super(),
              (this.type = "WireframeGeometry"),
              (this.parameters = { geometry: t }),
              null !== t)
            ) {
              const e = [],
                n = new Set(),
                i = new ke(),
                r = new ke();
              if (null !== t.index) {
                const s = t.attributes.position,
                  a = t.index;
                let o = t.groups;
                0 === o.length && (o = [{ start: 0, count: a.count, materialIndex: 0 }]);
                for (let t = 0, l = o.length; t < l; ++t) {
                  const l = o[t],
                    c = l.start;
                  for (let t = c, o = c + l.count; t < o; t += 3)
                    for (let o = 0; o < 3; o++) {
                      const l = a.getX(t + o),
                        c = a.getX(t + ((o + 1) % 3));
                      i.fromBufferAttribute(s, l),
                        r.fromBufferAttribute(s, c),
                        !0 === Zc(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
                    }
                }
              } else {
                const s = t.attributes.position;
                for (let t = 0, a = s.count / 3; t < a; t++)
                  for (let a = 0; a < 3; a++) {
                    const o = 3 * t + a,
                      l = 3 * t + ((a + 1) % 3);
                    i.fromBufferAttribute(s, o),
                      r.fromBufferAttribute(s, l),
                      !0 === Zc(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
                  }
              }
              this.setAttribute("position", new Si(e, 3));
            }
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
        }
        function Zc(t, e, n) {
          const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
            r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
          return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i), n.add(r), !0);
        }
        var Jc = Object.freeze({
          __proto__: null,
          BoxGeometry: Zi,
          CapsuleGeometry: $l,
          CircleGeometry: tc,
          ConeGeometry: nc,
          CylinderGeometry: ec,
          DodecahedronGeometry: rc,
          EdgesGeometry: cc,
          ExtrudeGeometry: Fc,
          IcosahedronGeometry: Hc,
          LatheGeometry: Ql,
          OctahedronGeometry: Gc,
          PlaneGeometry: _r,
          PolyhedronGeometry: ic,
          RingGeometry: kc,
          ShapeGeometry: Vc,
          SphereGeometry: Wc,
          TetrahedronGeometry: Xc,
          TorusGeometry: jc,
          TorusKnotGeometry: qc,
          TubeGeometry: Yc,
          WireframeGeometry: Kc,
        });
        class Qc extends hi {
          constructor(t) {
            super(),
              (this.isShadowMaterial = !0),
              (this.type = "ShadowMaterial"),
              (this.color = new oi(0)),
              (this.transparent = !0),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), (this.fog = t.fog), this;
          }
        }
        class $c extends er {
          constructor(t) {
            super(t), (this.isRawShaderMaterial = !0), (this.type = "RawShaderMaterial");
          }
        }
        class th extends hi {
          constructor(t) {
            super(),
              (this.isMeshStandardMaterial = !0),
              (this.defines = { STANDARD: "" }),
              (this.type = "MeshStandardMaterial"),
              (this.color = new oi(16777215)),
              (this.roughness = 1),
              (this.metalness = 0),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new oi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new de(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.roughnessMap = null),
              (this.metalnessMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.envMapIntensity = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "" }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              (this.fog = t.fog),
              this
            );
          }
        }
        class eh extends th {
          constructor(t) {
            super(),
              (this.isMeshPhysicalMaterial = !0),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.type = "MeshPhysicalMaterial"),
              (this.anisotropyRotation = 0),
              (this.anisotropyMap = null),
              (this.clearcoatMap = null),
              (this.clearcoatRoughness = 0),
              (this.clearcoatRoughnessMap = null),
              (this.clearcoatNormalScale = new de(1, 1)),
              (this.clearcoatNormalMap = null),
              (this.ior = 1.5),
              Object.defineProperty(this, "reflectivity", {
                get: function () {
                  return re((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                  this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
              }),
              (this.iridescenceMap = null),
              (this.iridescenceIOR = 1.3),
              (this.iridescenceThicknessRange = [100, 400]),
              (this.iridescenceThicknessMap = null),
              (this.sheenColor = new oi(0)),
              (this.sheenColorMap = null),
              (this.sheenRoughness = 1),
              (this.sheenRoughnessMap = null),
              (this.transmissionMap = null),
              (this.thickness = 0),
              (this.thicknessMap = null),
              (this.attenuationDistance = 1 / 0),
              (this.attenuationColor = new oi(1, 1, 1)),
              (this.specularIntensity = 1),
              (this.specularIntensityMap = null),
              (this.specularColor = new oi(1, 1, 1)),
              (this.specularColorMap = null),
              (this._anisotropy = 0),
              (this._clearcoat = 0),
              (this._iridescence = 0),
              (this._sheen = 0),
              (this._transmission = 0),
              this.setValues(t);
          }
          get anisotropy() {
            return this._anisotropy;
          }
          set anisotropy(t) {
            this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t);
          }
          get clearcoat() {
            return this._clearcoat;
          }
          set clearcoat(t) {
            this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
          }
          get iridescence() {
            return this._iridescence;
          }
          set iridescence(t) {
            this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t);
          }
          get sheen() {
            return this._sheen;
          }
          set sheen(t) {
            this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
          }
          get transmission() {
            return this._transmission;
          }
          set transmission(t) {
            this._transmission > 0 != t > 0 && this.version++, (this._transmission = t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.anisotropy = t.anisotropy),
              (this.anisotropyRotation = t.anisotropyRotation),
              (this.anisotropyMap = t.anisotropyMap),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.ior = t.ior),
              (this.iridescence = t.iridescence),
              (this.iridescenceMap = t.iridescenceMap),
              (this.iridescenceIOR = t.iridescenceIOR),
              (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
              (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
              (this.sheen = t.sheen),
              this.sheenColor.copy(t.sheenColor),
              (this.sheenColorMap = t.sheenColorMap),
              (this.sheenRoughness = t.sheenRoughness),
              (this.sheenRoughnessMap = t.sheenRoughnessMap),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              (this.thickness = t.thickness),
              (this.thicknessMap = t.thicknessMap),
              (this.attenuationDistance = t.attenuationDistance),
              this.attenuationColor.copy(t.attenuationColor),
              (this.specularIntensity = t.specularIntensity),
              (this.specularIntensityMap = t.specularIntensityMap),
              this.specularColor.copy(t.specularColor),
              (this.specularColorMap = t.specularColorMap),
              this
            );
          }
        }
        class nh extends hi {
          constructor(t) {
            super(),
              (this.isMeshPhongMaterial = !0),
              (this.type = "MeshPhongMaterial"),
              (this.color = new oi(16777215)),
              (this.specular = new oi(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new oi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new de(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = c),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              (this.fog = t.fog),
              this
            );
          }
        }
        class ih extends hi {
          constructor(t) {
            super(),
              (this.isMeshToonMaterial = !0),
              (this.defines = { TOON: "" }),
              (this.type = "MeshToonMaterial"),
              (this.color = new oi(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new oi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new de(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        class rh extends hi {
          constructor(t) {
            super(),
              (this.isMeshNormalMaterial = !0),
              (this.type = "MeshNormalMaterial"),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new de(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        class sh extends hi {
          constructor(t) {
            super(),
              (this.isMeshLambertMaterial = !0),
              (this.type = "MeshLambertMaterial"),
              (this.color = new oi(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new oi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new de(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = c),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              (this.fog = t.fog),
              this
            );
          }
        }
        class ah extends hi {
          constructor(t) {
            super(),
              (this.isMeshMatcapMaterial = !0),
              (this.defines = { MATCAP: "" }),
              (this.type = "MeshMatcapMaterial"),
              (this.color = new oi(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new de(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.flatShading = !1),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: "" }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.flatShading = t.flatShading),
              (this.fog = t.fog),
              this
            );
          }
        }
        class oh extends ul {
          constructor(t) {
            super(),
              (this.isLineDashedMaterial = !0),
              (this.type = "LineDashedMaterial"),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.scale = t.scale),
              (this.dashSize = t.dashSize),
              (this.gapSize = t.gapSize),
              this
            );
          }
        }
        function lh(t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        }
        function ch(t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        }
        function hh(t) {
          const e = t.length,
            n = new Array(e);
          for (let t = 0; t !== e; ++t) n[t] = t;
          return (
            n.sort(function (e, n) {
              return t[e] - t[n];
            }),
            n
          );
        }
        function uh(t, e, n) {
          const i = t.length,
            r = new t.constructor(i);
          for (let s = 0, a = 0; a !== i; ++s) {
            const i = n[s] * e;
            for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
          }
          return r;
        }
        function dh(t, e, n, i) {
          let r = 1,
            s = t[0];
          for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
          if (void 0 === s) return;
          let a = s[i];
          if (void 0 !== a)
            if (Array.isArray(a))
              do {
                (a = s[i]), void 0 !== a && (e.push(s.time), n.push.apply(n, a)), (s = t[r++]);
              } while (void 0 !== s);
            else if (void 0 !== a.toArray)
              do {
                (a = s[i]), void 0 !== a && (e.push(s.time), a.toArray(n, n.length)), (s = t[r++]);
              } while (void 0 !== s);
            else
              do {
                (a = s[i]), void 0 !== a && (e.push(s.time), n.push(a)), (s = t[r++]);
              } while (void 0 !== s);
        }
        const ph = {
          convertArray: lh,
          isTypedArray: ch,
          getKeyframeOrder: hh,
          sortedArray: uh,
          flattenJSON: dh,
          subclip: function (t, e, n, i, r = 30) {
            const s = t.clone();
            s.name = e;
            const a = [];
            for (let t = 0; t < s.tracks.length; ++t) {
              const e = s.tracks[t],
                o = e.getValueSize(),
                l = [],
                c = [];
              for (let t = 0; t < e.times.length; ++t) {
                const s = e.times[t] * r;
                if (!(s < n || s >= i)) {
                  l.push(e.times[t]);
                  for (let n = 0; n < o; ++n) c.push(e.values[t * o + n]);
                }
              }
              0 !== l.length &&
                ((e.times = lh(l, e.times.constructor)),
                (e.values = lh(c, e.values.constructor)),
                a.push(e));
            }
            s.tracks = a;
            let o = 1 / 0;
            for (let t = 0; t < s.tracks.length; ++t)
              o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
            for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
            return s.resetDuration(), s;
          },
          makeClipAdditive: function (t, e = 0, n = t, i = 30) {
            i <= 0 && (i = 30);
            const r = n.tracks.length,
              s = e / i;
            for (let e = 0; e < r; ++e) {
              const i = n.tracks[e],
                r = i.ValueTypeName;
              if ("bool" === r || "string" === r) continue;
              const a = t.tracks.find(function (t) {
                return t.name === i.name && t.ValueTypeName === r;
              });
              if (void 0 === a) continue;
              let o = 0;
              const l = i.getValueSize();
              i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
              let c = 0;
              const h = a.getValueSize();
              a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
              const u = i.times.length - 1;
              let d;
              if (s <= i.times[0]) {
                const t = o,
                  e = l - o;
                d = i.values.slice(t, e);
              } else if (s >= i.times[u]) {
                const t = u * l + o,
                  e = t + l - o;
                d = i.values.slice(t, e);
              } else {
                const t = i.createInterpolant(),
                  e = o,
                  n = l - o;
                t.evaluate(s), (d = t.resultBuffer.slice(e, n));
              }
              "quaternion" === r && new Ge().fromArray(d).normalize().conjugate().toArray(d);
              const p = a.times.length;
              for (let t = 0; t < p; ++t) {
                const e = t * h + c;
                if ("quaternion" === r) Ge.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                else {
                  const t = h - 2 * c;
                  for (let n = 0; n < t; ++n) a.values[e + n] -= d[n];
                }
              }
            }
            return (t.blendMode = Nt), t;
          },
        };
        class fh {
          constructor(t, e, n, i) {
            (this.parameterPositions = t),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
              (this.sampleValues = e),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              i = e[n],
              r = e[n - 1];
            t: {
              e: {
                let s;
                n: {
                  i: if (!(t < i)) {
                    for (let s = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i;
                        return (
                          (n = e.length), (this._cachedIndex = n), this.copySampleValue_(n - 1)
                        );
                      }
                      if (n === s) break;
                      if (((r = i), (i = e[++n]), t < i)) break e;
                    }
                    s = e.length;
                    break n;
                  }
                  if (t >= r) break t;
                  {
                    const a = e[1];
                    t < a && ((n = 2), (r = a));
                    for (let s = n - 2; ; ) {
                      if (void 0 === r) return (this._cachedIndex = 0), this.copySampleValue_(0);
                      if (n === s) break;
                      if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                    }
                    (s = n), (n = 0);
                  }
                }
                for (; n < s; ) {
                  const i = (n + s) >>> 1;
                  t < e[i] ? (s = i) : (n = i + 1);
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (void 0 === i)
                  return (n = e.length), (this._cachedIndex = n), this.copySampleValue_(n - 1);
              }
              (this._cachedIndex = n), this.intervalChanged_(n, r, i);
            }
            return this.interpolate_(n, r, t, i);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e;
          }
          interpolate_() {
            throw new Error("call to abstract method");
          }
          intervalChanged_() {}
        }
        class mh extends fh {
          constructor(t, e, n, i) {
            super(t, e, n, i),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: Pt, endingEnd: Pt });
          }
          intervalChanged_(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2,
              s = t + 1,
              a = i[r],
              o = i[s];
            if (void 0 === a)
              switch (this.getSettings_().endingStart) {
                case It:
                  (r = t), (a = 2 * e - n);
                  break;
                case Ut:
                  (r = i.length - 2), (a = e + i[r] - i[r + 1]);
                  break;
                default:
                  (r = t), (a = n);
              }
            if (void 0 === o)
              switch (this.getSettings_().endingEnd) {
                case It:
                  (s = t), (o = 2 * n - e);
                  break;
                case Ut:
                  (s = 1), (o = n + i[1] - i[0]);
                  break;
                default:
                  (s = t - 1), (o = e);
              }
            const l = 0.5 * (n - e),
              c = this.valueSize;
            (this._weightPrev = l / (e - a)),
              (this._weightNext = l / (o - n)),
              (this._offsetPrev = r * c),
              (this._offsetNext = s * c);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = t * a,
              l = o - a,
              c = this._offsetPrev,
              h = this._offsetNext,
              u = this._weightPrev,
              d = this._weightNext,
              p = (n - e) / (i - e),
              f = p * p,
              m = f * p,
              g = -u * m + 2 * u * f - u * p,
              _ = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
              v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
              x = d * m - d * f;
            for (let t = 0; t !== a; ++t)
              r[t] = g * s[c + t] + _ * s[l + t] + v * s[o + t] + x * s[h + t];
            return r;
          }
        }
        class gh extends fh {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = t * a,
              l = o - a,
              c = (n - e) / (i - e),
              h = 1 - c;
            for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
            return r;
          }
        }
        class _h extends fh {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t) {
            return this.copySampleValue_(t - 1);
          }
        }
        class vh {
          constructor(t, e, n, i) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
              throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            (this.name = t),
              (this.times = lh(e, this.TimeBufferType)),
              (this.values = lh(n, this.ValueBufferType)),
              this.setInterpolation(i || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = { name: t.name, times: lh(t.times, Array), values: lh(t.values, Array) };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new _h(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new gh(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new mh(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case Rt:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case Ct:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case Lt:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Rt;
              case this.InterpolantFactoryMethodLinear:
                return Ct;
              case this.InterpolantFactoryMethodSmooth:
                return Lt;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              i = n.length;
            let r = 0,
              s = i - 1;
            for (; r !== i && n[r] < t; ) ++r;
            for (; -1 !== s && n[s] > e; ) --s;
            if ((++s, 0 !== r || s !== i)) {
              r >= s && ((s = Math.max(s, 1)), (r = s - 1));
              const t = this.getValueSize();
              (this.times = n.slice(r, s)), (this.values = this.values.slice(r * t, s * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), (t = !1));
            const n = this.times,
              i = this.values,
              r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
            let s = null;
            for (let e = 0; e !== r; e++) {
              const i = n[e];
              if ("number" == typeof i && isNaN(i)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                  (t = !1);
                break;
              }
              if (null !== s && s > i) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), (t = !1);
                break;
              }
              s = i;
            }
            if (void 0 !== i && ch(i))
              for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e];
                if (isNaN(n)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                    (t = !1);
                  break;
                }
              }
            return t;
          }
          optimize() {
            const t = this.times.slice(),
              e = this.values.slice(),
              n = this.getValueSize(),
              i = this.getInterpolation() === Lt,
              r = t.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
              let r = !1;
              const o = t[a];
              if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                if (i) r = !0;
                else {
                  const t = a * n,
                    i = t - n,
                    s = t + n;
                  for (let a = 0; a !== n; ++a) {
                    const n = e[t + a];
                    if (n !== e[i + a] || n !== e[s + a]) {
                      r = !0;
                      break;
                    }
                  }
                }
              if (r) {
                if (a !== s) {
                  t[s] = t[a];
                  const i = a * n,
                    r = s * n;
                  for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
                }
                ++s;
              }
            }
            if (r > 0) {
              t[s] = t[r];
              for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
              ++s;
            }
            return (
              s !== t.length
                ? ((this.times = t.slice(0, s)), (this.values = e.slice(0, s * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = this.times.slice(),
              e = this.values.slice(),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (vh.prototype.TimeBufferType = Float32Array),
          (vh.prototype.ValueBufferType = Float32Array),
          (vh.prototype.DefaultInterpolation = Ct);
        class xh extends vh {}
        (xh.prototype.ValueTypeName = "bool"),
          (xh.prototype.ValueBufferType = Array),
          (xh.prototype.DefaultInterpolation = Rt),
          (xh.prototype.InterpolantFactoryMethodLinear = void 0),
          (xh.prototype.InterpolantFactoryMethodSmooth = void 0);
        class yh extends vh {}
        yh.prototype.ValueTypeName = "color";
        class Mh extends vh {}
        Mh.prototype.ValueTypeName = "number";
        class Sh extends fh {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = (n - e) / (i - e);
            let l = t * a;
            for (let t = l + a; l !== t; l += 4) Ge.slerpFlat(r, 0, s, l - a, s, l, o);
            return r;
          }
        }
        class bh extends vh {
          InterpolantFactoryMethodLinear(t) {
            return new Sh(this.times, this.values, this.getValueSize(), t);
          }
        }
        (bh.prototype.ValueTypeName = "quaternion"),
          (bh.prototype.DefaultInterpolation = Ct),
          (bh.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Eh extends vh {}
        (Eh.prototype.ValueTypeName = "string"),
          (Eh.prototype.ValueBufferType = Array),
          (Eh.prototype.DefaultInterpolation = Rt),
          (Eh.prototype.InterpolantFactoryMethodLinear = void 0),
          (Eh.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Th extends vh {}
        Th.prototype.ValueTypeName = "vector";
        class Ah {
          constructor(t, e = -1, n, i = 2500) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = i),
              (this.uuid = ie()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t) e.push(wh(n[t]).scale(i));
            const r = new this(t.name, t.duration, e, t.blendMode);
            return (r.uuid = t.uuid), r;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let t = 0, i = n.length; t !== i; ++t) e.push(vh.toJSON(n[t]));
            return i;
          }
          static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length,
              s = [];
            for (let t = 0; t < r; t++) {
              let a = [],
                o = [];
              a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
              const l = hh(a);
              (a = uh(a, 1, l)),
                (o = uh(o, 1, l)),
                i || 0 !== a[0] || (a.push(r), o.push(o[0])),
                s.push(new Mh(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n));
            }
            return new this(t, -1, s);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                s = n.name.match(r);
              if (s && s.length > 1) {
                const t = s[1];
                let e = i[t];
                e || (i[t] = e = []), e.push(n);
              }
            }
            const s = [];
            for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
            return s;
          }
          static parseAnimation(t, e) {
            if (!t)
              return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  const s = [],
                    a = [];
                  dh(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a));
                }
              },
              i = [],
              r = t.name || "default",
              s = t.fps || 30,
              a = t.blendMode;
            let o = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
              const r = l[t].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const t = {};
                  let e;
                  for (e = 0; e < r.length; e++)
                    if (r[e].morphTargets)
                      for (let n = 0; n < r[e].morphTargets.length; n++)
                        t[r[e].morphTargets[n]] = -1;
                  for (const n in t) {
                    const t = [],
                      s = [];
                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                      const i = r[e];
                      t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                    }
                    i.push(new Mh(".morphTargetInfluence[" + n + "]", t, s));
                  }
                  o = t.length * s;
                } else {
                  const s = ".bones[" + e[t].name + "]";
                  n(Th, s + ".position", r, "pos", i),
                    n(bh, s + ".quaternion", r, "rot", i),
                    n(Th, s + ".scale", r, "scl", i);
                }
            }
            return 0 === i.length ? null : new this(r, o, i, a);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
            return new this.constructor(this.name, this.duration, t, this.blendMode);
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function wh(t) {
          if (void 0 === t.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return Mh;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return Th;
              case "color":
                return yh;
              case "quaternion":
                return bh;
              case "bool":
              case "boolean":
                return xh;
              case "string":
                return Eh;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
          })(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            dh(t.keys, e, n, "value"), (t.times = e), (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        const Rh = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        class Ch {
          constructor(t, e, n) {
            const i = this;
            let r,
              s = !1,
              a = 0,
              o = 0;
            const l = [];
            (this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = n),
              (this.itemStart = function (t) {
                o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), (s = !0);
              }),
              (this.itemEnd = function (t) {
                a++,
                  void 0 !== i.onProgress && i.onProgress(t, a, o),
                  a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
              }),
              (this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t);
              }),
              (this.resolveURL = function (t) {
                return r ? r(t) : t;
              }),
              (this.setURLModifier = function (t) {
                return (r = t), this;
              }),
              (this.addHandler = function (t, e) {
                return l.push(t, e), this;
              }),
              (this.removeHandler = function (t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this;
              }),
              (this.getHandler = function (t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                  const n = l[e],
                    i = l[e + 1];
                  if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
                }
                return null;
              });
          }
        }
        const Lh = new Ch();
        class Ph {
          constructor(t) {
            (this.manager = void 0 !== t ? t : Lh),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.load(t, i, e, r);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        Ph.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Ih = {};
        class Uh extends Error {
          constructor(t, e) {
            super(t), (this.response = e);
          }
        }
        class Nh extends Ph {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = Rh.get(t);
            if (void 0 !== r)
              return (
                this.manager.itemStart(t),
                setTimeout(() => {
                  e && e(r), this.manager.itemEnd(t);
                }, 0),
                r
              );
            if (void 0 !== Ih[t]) return void Ih[t].push({ onLoad: e, onProgress: n, onError: i });
            (Ih[t] = []), Ih[t].push({ onLoad: e, onProgress: n, onError: i });
            const s = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
              }),
              a = this.mimeType,
              o = this.responseType;
            fetch(s)
              .then((e) => {
                if (200 === e.status || 0 === e.status) {
                  if (
                    (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    "undefined" == typeof ReadableStream ||
                      void 0 === e.body ||
                      void 0 === e.body.getReader)
                  )
                    return e;
                  const n = Ih[t],
                    i = e.body.getReader(),
                    r = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
                    s = r ? parseInt(r) : 0,
                    a = 0 !== s;
                  let o = 0;
                  const l = new ReadableStream({
                    start(t) {
                      !(function e() {
                        i.read().then(({ done: i, value: r }) => {
                          if (i) t.close();
                          else {
                            o += r.byteLength;
                            const i = new ProgressEvent("progress", {
                              lengthComputable: a,
                              loaded: o,
                              total: s,
                            });
                            for (let t = 0, e = n.length; t < e; t++) {
                              const e = n[t];
                              e.onProgress && e.onProgress(i);
                            }
                            t.enqueue(r), e();
                          }
                        });
                      })();
                    },
                  });
                  return new Response(l);
                }
                throw new Uh(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e);
              })
              .then((t) => {
                switch (o) {
                  case "arraybuffer":
                    return t.arrayBuffer();
                  case "blob":
                    return t.blob();
                  case "document":
                    return t.text().then((t) => new DOMParser().parseFromString(t, a));
                  case "json":
                    return t.json();
                  default:
                    if (void 0 === a) return t.text();
                    {
                      const e = /charset="?([^;"\s]*)"?/i.exec(a),
                        n = e && e[1] ? e[1].toLowerCase() : void 0,
                        i = new TextDecoder(n);
                      return t.arrayBuffer().then((t) => i.decode(t));
                    }
                }
              })
              .then((e) => {
                Rh.add(t, e);
                const n = Ih[t];
                delete Ih[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onLoad && i.onLoad(e);
                }
              })
              .catch((e) => {
                const n = Ih[t];
                if (void 0 === n) throw (this.manager.itemError(t), e);
                delete Ih[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onError && i.onError(e);
                }
                this.manager.itemError(t);
              })
              .finally(() => {
                this.manager.itemEnd(t);
              }),
              this.manager.itemStart(t);
          }
          setResponseType(t) {
            return (this.responseType = t), this;
          }
          setMimeType(t) {
            return (this.mimeType = t), this;
          }
        }
        class Dh extends Ph {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
            const r = this,
              s = Rh.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            const a = ve("img");
            function o() {
              c(), Rh.add(t, this), e && e(this), r.manager.itemEnd(t);
            }
            function l(e) {
              c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }
            function c() {
              a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1);
            }
            return (
              a.addEventListener("load", o, !1),
              a.addEventListener("error", l, !1),
              "data:" !== t.slice(0, 5) &&
                void 0 !== this.crossOrigin &&
                (a.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (a.src = t),
              a
            );
          }
        }
        class Oh extends Wn {
          constructor(t, e = 1) {
            super(),
              (this.isLight = !0),
              (this.type = "Light"),
              (this.color = new oi(t)),
              (this.intensity = e);
          }
          dispose() {}
          copy(t, e) {
            return super.copy(t, e), this.color.copy(t.color), (this.intensity = t.intensity), this;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        class Bh extends Oh {
          constructor(t, e, n) {
            super(t, n),
              (this.isHemisphereLight = !0),
              (this.type = "HemisphereLight"),
              this.position.copy(Wn.DEFAULT_UP),
              this.updateMatrix(),
              (this.groundColor = new oi(e));
          }
          copy(t, e) {
            return super.copy(t, e), this.groundColor.copy(t.groundColor), this;
          }
        }
        const Fh = new xn(),
          zh = new ke(),
          Hh = new ke();
        class Gh {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new de(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new xn()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new fr()),
              (this._frameExtents = new de(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new Oe(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            zh.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(zh),
              Hh.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(Hh),
              e.updateMatrixWorld(),
              Fh.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Fh),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(Fh);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class kh extends Gh {
          constructor() {
            super(new ir(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * ne * t.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far;
            (n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        class Vh extends Oh {
          constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) {
            super(t, e),
              (this.isSpotLight = !0),
              (this.type = "SpotLight"),
              this.position.copy(Wn.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new Wn()),
              (this.distance = n),
              (this.angle = i),
              (this.penumbra = r),
              (this.decay = s),
              (this.map = null),
              (this.shadow = new kh());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        const Wh = new xn(),
          Xh = new ke(),
          jh = new ke();
        class qh extends Gh {
          constructor() {
            super(new ir(90, 1, 0.5, 500)),
              (this.isPointLightShadow = !0),
              (this._frameExtents = new de(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new Oe(2, 1, 1, 1),
                new Oe(0, 1, 1, 1),
                new Oe(3, 1, 1, 1),
                new Oe(1, 1, 1, 1),
                new Oe(3, 0, 1, 1),
                new Oe(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new ke(1, 0, 0),
                new ke(-1, 0, 0),
                new ke(0, 0, 1),
                new ke(0, 0, -1),
                new ke(0, 1, 0),
                new ke(0, -1, 0),
              ]),
              (this._cubeUps = [
                new ke(0, 1, 0),
                new ke(0, 1, 0),
                new ke(0, 1, 0),
                new ke(0, 1, 0),
                new ke(0, 0, 1),
                new ke(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              i = this.matrix,
              r = t.distance || n.far;
            r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
              Xh.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(Xh),
              jh.copy(n.position),
              jh.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(jh),
              n.updateMatrixWorld(),
              i.makeTranslation(-Xh.x, -Xh.y, -Xh.z),
              Wh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Wh);
          }
        }
        class Yh extends Oh {
          constructor(t, e, n = 0, i = 2) {
            super(t, e),
              (this.isPointLight = !0),
              (this.type = "PointLight"),
              (this.distance = n),
              (this.decay = i),
              (this.shadow = new qh());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        class Kh extends Gh {
          constructor() {
            super(new Rr(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
          }
        }
        class Zh extends Oh {
          constructor(t, e) {
            super(t, e),
              (this.isDirectionalLight = !0),
              (this.type = "DirectionalLight"),
              this.position.copy(Wn.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new Wn()),
              (this.shadow = new Kh());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        class Jh extends Oh {
          constructor(t, e) {
            super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
          }
        }
        class Qh extends Oh {
          constructor(t, e, n = 10, i = 10) {
            super(t, e),
              (this.isRectAreaLight = !0),
              (this.type = "RectAreaLight"),
              (this.width = n),
              (this.height = i);
          }
          get power() {
            return this.intensity * this.width * this.height * Math.PI;
          }
          set power(t) {
            this.intensity = t / (this.width * this.height * Math.PI);
          }
          copy(t) {
            return super.copy(t), (this.width = t.width), (this.height = t.height), this;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (e.object.width = this.width), (e.object.height = this.height), e;
          }
        }
        class $h {
          constructor() {
            (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
            for (let t = 0; t < 9; t++) this.coefficients.push(new ke());
          }
          set(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this;
          }
          zero() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this;
          }
          getAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.coefficients;
            return (
              e.copy(s[0]).multiplyScalar(0.282095),
              e.addScaledVector(s[1], 0.488603 * i),
              e.addScaledVector(s[2], 0.488603 * r),
              e.addScaledVector(s[3], 0.488603 * n),
              e.addScaledVector(s[4], n * i * 1.092548),
              e.addScaledVector(s[5], i * r * 1.092548),
              e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
              e.addScaledVector(s[7], n * r * 1.092548),
              e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
              e
            );
          }
          getIrradianceAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.coefficients;
            return (
              e.copy(s[0]).multiplyScalar(0.886227),
              e.addScaledVector(s[1], 1.023328 * i),
              e.addScaledVector(s[2], 1.023328 * r),
              e.addScaledVector(s[3], 1.023328 * n),
              e.addScaledVector(s[4], 0.858086 * n * i),
              e.addScaledVector(s[5], 0.858086 * i * r),
              e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
              e.addScaledVector(s[7], 0.858086 * n * r),
              e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
              e
            );
          }
          add(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
            return this;
          }
          addScaledSH(t, e) {
            for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this;
          }
          scale(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this;
          }
          lerp(t, e) {
            for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
            return this;
          }
          equals(t) {
            for (let e = 0; e < 9; e++)
              if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0;
          }
          copy(t) {
            return this.set(t.coefficients);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          fromArray(t, e = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
            return t;
          }
          static getBasisAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z;
            (e[0] = 0.282095),
              (e[1] = 0.488603 * i),
              (e[2] = 0.488603 * r),
              (e[3] = 0.488603 * n),
              (e[4] = 1.092548 * n * i),
              (e[5] = 1.092548 * i * r),
              (e[6] = 0.315392 * (3 * r * r - 1)),
              (e[7] = 1.092548 * n * r),
              (e[8] = 0.546274 * (n * n - i * i));
          }
        }
        class tu extends Oh {
          constructor(t = new $h(), e = 1) {
            super(void 0, e), (this.isLightProbe = !0), (this.sh = t);
          }
          copy(t) {
            return super.copy(t), this.sh.copy(t.sh), this;
          }
          fromJSON(t) {
            return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (e.object.sh = this.sh.toArray()), e;
          }
        }
        class eu extends Ph {
          constructor(t) {
            super(t), (this.textures = {});
          }
          load(t, e, n, i) {
            const r = this,
              s = new Nh(r.manager);
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i
              );
          }
          parse(t) {
            const e = this.textures;
            function n(t) {
              return (
                void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
              );
            }
            const i = eu.createMaterialFromType(t.type);
            if (
              (void 0 !== t.uuid && (i.uuid = t.uuid),
              void 0 !== t.name && (i.name = t.name),
              void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
              void 0 !== t.roughness && (i.roughness = t.roughness),
              void 0 !== t.metalness && (i.metalness = t.metalness),
              void 0 !== t.sheen && (i.sheen = t.sheen),
              void 0 !== t.sheenColor && (i.sheenColor = new oi().setHex(t.sheenColor)),
              void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness),
              void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive),
              void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular),
              void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity),
              void 0 !== t.specularColor &&
                void 0 !== i.specularColor &&
                i.specularColor.setHex(t.specularColor),
              void 0 !== t.shininess && (i.shininess = t.shininess),
              void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
              void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness),
              void 0 !== t.iridescence && (i.iridescence = t.iridescence),
              void 0 !== t.iridescenceIOR && (i.iridescenceIOR = t.iridescenceIOR),
              void 0 !== t.iridescenceThicknessRange &&
                (i.iridescenceThicknessRange = t.iridescenceThicknessRange),
              void 0 !== t.transmission && (i.transmission = t.transmission),
              void 0 !== t.thickness && (i.thickness = t.thickness),
              void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance),
              void 0 !== t.attenuationColor &&
                void 0 !== i.attenuationColor &&
                i.attenuationColor.setHex(t.attenuationColor),
              void 0 !== t.anisotropy && (i.anisotropy = t.anisotropy),
              void 0 !== t.anisotropyRotation && (i.anisotropyRotation = t.anisotropyRotation),
              void 0 !== t.fog && (i.fog = t.fog),
              void 0 !== t.flatShading && (i.flatShading = t.flatShading),
              void 0 !== t.blending && (i.blending = t.blending),
              void 0 !== t.combine && (i.combine = t.combine),
              void 0 !== t.side && (i.side = t.side),
              void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
              void 0 !== t.opacity && (i.opacity = t.opacity),
              void 0 !== t.transparent && (i.transparent = t.transparent),
              void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
              void 0 !== t.alphaHash && (i.alphaHash = t.alphaHash),
              void 0 !== t.depthFunc && (i.depthFunc = t.depthFunc),
              void 0 !== t.depthTest && (i.depthTest = t.depthTest),
              void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
              void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
              void 0 !== t.blendSrc && (i.blendSrc = t.blendSrc),
              void 0 !== t.blendDst && (i.blendDst = t.blendDst),
              void 0 !== t.blendEquation && (i.blendEquation = t.blendEquation),
              void 0 !== t.blendSrcAlpha && (i.blendSrcAlpha = t.blendSrcAlpha),
              void 0 !== t.blendDstAlpha && (i.blendDstAlpha = t.blendDstAlpha),
              void 0 !== t.blendEquationAlpha && (i.blendEquationAlpha = t.blendEquationAlpha),
              void 0 !== t.blendColor &&
                void 0 !== i.blendColor &&
                i.blendColor.setHex(t.blendColor),
              void 0 !== t.blendAlpha && (i.blendAlpha = t.blendAlpha),
              void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask),
              void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
              void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
              void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask),
              void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
              void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
              void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
              void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
              void 0 !== t.wireframe && (i.wireframe = t.wireframe),
              void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth),
              void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap),
              void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin),
              void 0 !== t.rotation && (i.rotation = t.rotation),
              void 0 !== t.linewidth && (i.linewidth = t.linewidth),
              void 0 !== t.dashSize && (i.dashSize = t.dashSize),
              void 0 !== t.gapSize && (i.gapSize = t.gapSize),
              void 0 !== t.scale && (i.scale = t.scale),
              void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
              void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor),
              void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits),
              void 0 !== t.dithering && (i.dithering = t.dithering),
              void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage),
              void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha),
              void 0 !== t.forceSinglePass && (i.forceSinglePass = t.forceSinglePass),
              void 0 !== t.visible && (i.visible = t.visible),
              void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
              void 0 !== t.userData && (i.userData = t.userData),
              void 0 !== t.vertexColors &&
                ("number" == typeof t.vertexColors
                  ? (i.vertexColors = t.vertexColors > 0)
                  : (i.vertexColors = t.vertexColors)),
              void 0 !== t.uniforms)
            )
              for (const e in t.uniforms) {
                const r = t.uniforms[e];
                switch (((i.uniforms[e] = {}), r.type)) {
                  case "t":
                    i.uniforms[e].value = n(r.value);
                    break;
                  case "c":
                    i.uniforms[e].value = new oi().setHex(r.value);
                    break;
                  case "v2":
                    i.uniforms[e].value = new de().fromArray(r.value);
                    break;
                  case "v3":
                    i.uniforms[e].value = new ke().fromArray(r.value);
                    break;
                  case "v4":
                    i.uniforms[e].value = new Oe().fromArray(r.value);
                    break;
                  case "m3":
                    i.uniforms[e].value = new pe().fromArray(r.value);
                    break;
                  case "m4":
                    i.uniforms[e].value = new xn().fromArray(r.value);
                    break;
                  default:
                    i.uniforms[e].value = r.value;
                }
              }
            if (
              (void 0 !== t.defines && (i.defines = t.defines),
              void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
              void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
              void 0 !== t.glslVersion && (i.glslVersion = t.glslVersion),
              void 0 !== t.extensions)
            )
              for (const e in t.extensions) i.extensions[e] = t.extensions[e];
            if (
              (void 0 !== t.lights && (i.lights = t.lights),
              void 0 !== t.clipping && (i.clipping = t.clipping),
              void 0 !== t.size && (i.size = t.size),
              void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation),
              void 0 !== t.map && (i.map = n(t.map)),
              void 0 !== t.matcap && (i.matcap = n(t.matcap)),
              void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
              void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
              void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
              void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
              void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
              void 0 !== t.normalScale)
            ) {
              let e = t.normalScale;
              !1 === Array.isArray(e) && (e = [e, e]), (i.normalScale = new de().fromArray(e));
            }
            return (
              void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)),
              void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale),
              void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias),
              void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
              void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
              void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
              void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity),
              void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
              void 0 !== t.specularIntensityMap &&
                (i.specularIntensityMap = n(t.specularIntensityMap)),
              void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)),
              void 0 !== t.envMap && (i.envMap = n(t.envMap)),
              void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity),
              void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
              void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio),
              void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
              void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity),
              void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
              void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
              void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
              void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
              void 0 !== t.clearcoatRoughnessMap &&
                (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
              void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
              void 0 !== t.clearcoatNormalScale &&
                (i.clearcoatNormalScale = new de().fromArray(t.clearcoatNormalScale)),
              void 0 !== t.iridescenceMap && (i.iridescenceMap = n(t.iridescenceMap)),
              void 0 !== t.iridescenceThicknessMap &&
                (i.iridescenceThicknessMap = n(t.iridescenceThicknessMap)),
              void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)),
              void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)),
              void 0 !== t.anisotropyMap && (i.anisotropyMap = n(t.anisotropyMap)),
              void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)),
              void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)),
              i
            );
          }
          setTextures(t) {
            return (this.textures = t), this;
          }
          static createMaterialFromType(t) {
            return new {
              ShadowMaterial: Qc,
              SpriteMaterial: ro,
              RawShaderMaterial: $c,
              ShaderMaterial: er,
              PointsMaterial: Sl,
              MeshPhysicalMaterial: eh,
              MeshStandardMaterial: th,
              MeshPhongMaterial: nh,
              MeshToonMaterial: ih,
              MeshNormalMaterial: rh,
              MeshLambertMaterial: sh,
              MeshDepthMaterial: Ba,
              MeshDistanceMaterial: Fa,
              MeshBasicMaterial: ui,
              MeshMatcapMaterial: ah,
              LineDashedMaterial: oh,
              LineBasicMaterial: ul,
              Material: hi,
            }[t]();
          }
        }
        class nu {
          static decodeText(t) {
            if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
            let e = "";
            for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
            try {
              return decodeURIComponent(escape(e));
            } catch (t) {
              return e;
            }
          }
          static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.slice(0, e + 1);
          }
          static resolveURL(t, e) {
            return "string" != typeof t || "" === t
              ? ""
              : (/^https?:\/\//i.test(e) &&
                  /^\//.test(t) &&
                  (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t)
                  ? t
                  : e + t);
          }
        }
        class iu extends Li {
          constructor() {
            super(),
              (this.isInstancedBufferGeometry = !0),
              (this.type = "InstancedBufferGeometry"),
              (this.instanceCount = 1 / 0);
          }
          copy(t) {
            return super.copy(t), (this.instanceCount = t.instanceCount), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t;
          }
        }
        class ru extends Ph {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              s = new Nh(r.manager);
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i
              );
          }
          parse(t) {
            const e = {},
              n = {};
            function i(t, i) {
              if (void 0 !== e[i]) return e[i];
              const r = t.interleavedBuffers[i],
                s = (function (t, e) {
                  if (void 0 !== n[e]) return n[e];
                  const i = t.arrayBuffers[e],
                    r = new Uint32Array(i).buffer;
                  return (n[e] = r), r;
                })(t, r.buffer),
                a = _e(r.type, s),
                o = new eo(a, r.stride);
              return (o.uuid = r.uuid), (e[i] = o), o;
            }
            const r = t.isInstancedBufferGeometry ? new iu() : new Li(),
              s = t.data.index;
            if (void 0 !== s) {
              const t = _e(s.type, s.array);
              r.setIndex(new xi(t, 1));
            }
            const a = t.data.attributes;
            for (const e in a) {
              const n = a[e];
              let s;
              if (n.isInterleavedBufferAttribute) {
                const e = i(t.data, n.data);
                s = new io(e, n.itemSize, n.offset, n.normalized);
              } else {
                const t = _e(n.type, n.array);
                s = new (n.isInstancedBufferAttribute ? zo : xi)(t, n.itemSize, n.normalized);
              }
              void 0 !== n.name && (s.name = n.name),
                void 0 !== n.usage && s.setUsage(n.usage),
                r.setAttribute(e, s);
            }
            const o = t.data.morphAttributes;
            if (o)
              for (const e in o) {
                const n = o[e],
                  s = [];
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e];
                  let a;
                  if (r.isInterleavedBufferAttribute) {
                    const e = i(t.data, r.data);
                    a = new io(e, r.itemSize, r.offset, r.normalized);
                  } else {
                    const t = _e(r.type, r.array);
                    a = new xi(t, r.itemSize, r.normalized);
                  }
                  void 0 !== r.name && (a.name = r.name), s.push(a);
                }
                r.morphAttributes[e] = s;
              }
            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
            const l = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== l)
              for (let t = 0, e = l.length; t !== e; ++t) {
                const e = l[t];
                r.addGroup(e.start, e.count, e.materialIndex);
              }
            const c = t.data.boundingSphere;
            if (void 0 !== c) {
              const t = new ke();
              void 0 !== c.center && t.fromArray(c.center),
                (r.boundingSphere = new hn(t, c.radius));
            }
            return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r;
          }
        }
        const su = {
            UVMapping: M,
            CubeReflectionMapping: S,
            CubeRefractionMapping: b,
            EquirectangularReflectionMapping: E,
            EquirectangularRefractionMapping: T,
            CubeUVReflectionMapping: A,
          },
          au = { RepeatWrapping: w, ClampToEdgeWrapping: R, MirroredRepeatWrapping: C },
          ou = {
            NearestFilter: L,
            NearestMipmapNearestFilter: P,
            NearestMipmapLinearFilter: I,
            LinearFilter: U,
            LinearMipmapNearestFilter: N,
            LinearMipmapLinearFilter: D,
          };
        let lu;
        class cu {
          static getContext() {
            return (
              void 0 === lu && (lu = new (window.AudioContext || window.webkitAudioContext)()), lu
            );
          }
          static setContext(t) {
            lu = t;
          }
        }
        const hu = new xn(),
          uu = new xn(),
          du = new xn();
        class pu {
          constructor(t = !0) {
            (this.autoStart = t),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = fu()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              const e = fu();
              (t = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += t);
            }
            return t;
          }
        }
        function fu() {
          return ("undefined" == typeof performance ? Date : performance).now();
        }
        const mu = new ke(),
          gu = new Ge(),
          _u = new ke(),
          vu = new ke();
        class xu extends Wn {
          constructor(t) {
            super(),
              (this.type = "Audio"),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = "empty"),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = []);
          }
          getOutput() {
            return this.gain;
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "audioNode"),
              (this.source = t),
              this.connect(),
              this
            );
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaNode"),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            );
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaStreamNode"),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            );
          }
          setBuffer(t) {
            return (
              (this.buffer = t), (this.sourceType = "buffer"), this.autoplay && this.play(), this
            );
          }
          play(t = 0) {
            if (!0 === this.isPlaying)
              return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl)
              return void console.warn("THREE.Audio: this Audio has no playback control.");
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(this._startedAt, this._progress + this.offset, this.duration),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            );
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
                  !0 === this.loop &&
                    (this._progress = this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this._progress = 0),
                null !== this.source && (this.source.stop(), (this.source.onended = null)),
                (this.isPlaying = !1),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].connect(this.filters[t]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return (this._connected = !0), this;
          }
          disconnect() {
            if (!1 !== this._connected) {
              if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                  this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
              } else this.source.disconnect(this.getOutput());
              return (this._connected = !1), this;
            }
          }
          getFilters() {
            return this.filters;
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(), (this.filters = t.slice()), this.connect())
                : (this.filters = t.slice()),
              this
            );
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
                this
              );
          }
          getDetune() {
            return this.detune;
          }
          getFilter() {
            return this.getFilters()[0];
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : []);
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          getPlaybackRate() {
            return this.playbackRate;
          }
          onEnded() {
            this.isPlaying = !1;
          }
          getLoop() {
            return !1 === this.hasPlaybackControl
              ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
              : this.loop;
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          setLoopStart(t) {
            return (this.loopStart = t), this;
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this;
          }
          getVolume() {
            return this.gain.gain.value;
          }
          setVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
          }
        }
        const yu = new ke(),
          Mu = new Ge(),
          Su = new ke(),
          bu = new ke();
        class Eu {
          constructor(t, e, n) {
            let i, r, s;
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case "quaternion":
                (i = this._slerp),
                  (r = this._slerpAdditive),
                  (s = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (i = this._select),
                  (r = this._select),
                  (s = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (i = this._lerp),
                  (r = this._lerpAdditive),
                  (s = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = i),
              (this._mixBufferRegionAdditive = r),
              (this._setIdentity = s),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(t, e) {
            const n = this.buffer,
              i = this.valueSize,
              r = t * i + i;
            let s = this.cumulativeWeight;
            if (0 === s) {
              for (let t = 0; t !== i; ++t) n[r + t] = n[t];
              s = e;
            } else {
              s += e;
              const t = e / s;
              this._mixBufferRegion(n, r, 0, t, i);
            }
            this.cumulativeWeight = s;
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, i, 0, t, n),
              (this.cumulativeWeightAdditive += t);
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              i = t * e + e,
              r = this.cumulativeWeight,
              s = this.cumulativeWeightAdditive,
              a = this.binding;
            if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)) {
              const t = e * this._origIndex;
              this._mixBufferRegion(n, i, t, 1 - r, e);
            }
            s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
              if (n[t] !== n[t + e]) {
                a.setValue(n, i);
                break;
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
            this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n];
          }
          _select(t, e, n, i, r) {
            if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
          }
          _slerp(t, e, n, i) {
            Ge.slerpFlat(t, e, t, e, t, n, i);
          }
          _slerpAdditive(t, e, n, i, r) {
            const s = this._workIndex * r;
            Ge.multiplyQuaternionsFlat(t, s, t, e, t, n), Ge.slerpFlat(t, e, t, e, t, s, i);
          }
          _lerp(t, e, n, i, r) {
            const s = 1 - i;
            for (let a = 0; a !== r; ++a) {
              const r = e + a;
              t[r] = t[r] * s + t[n + a] * i;
            }
          }
          _lerpAdditive(t, e, n, i, r) {
            for (let s = 0; s !== r; ++s) {
              const r = e + s;
              t[r] = t[r] + t[n + s] * i;
            }
          }
        }
        const Tu = "\\[\\]\\.:\\/",
          Au = new RegExp("[" + Tu + "]", "g"),
          wu = "[^" + Tu + "]",
          Ru = "[^" + Tu.replace("\\.", "") + "]",
          Cu = new RegExp(
            "^" +
              /((?:WC+[\/:])*)/.source.replace("WC", wu) +
              /(WCOD+)?/.source.replace("WCOD", Ru) +
              /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wu) +
              /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wu) +
              "$"
          ),
          Lu = ["material", "materials", "bones", "map"];
        class Pu {
          constructor(t, e, n) {
            (this.path = e),
              (this.parsedPath = n || Pu.parseTrackName(e)),
              (this.node = Pu.findNode(t, this.parsedPath.nodeName)),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, e, n) {
            return t && t.isAnimationObjectGroup ? new Pu.Composite(t, e, n) : new Pu(t, e, n);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(Au, "");
          }
          static parseTrackName(t) {
            const e = Cu.exec(t);
            if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6],
              },
              i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
              const t = n.nodeName.substring(i + 1);
              -1 !== Lu.indexOf(t) &&
                ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n;
          }
          static findNode(t, e) {
            if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
              return t;
            if (t.skeleton) {
              const n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              const n = function (t) {
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    if (r.name === e || r.uuid === e) return r;
                    const s = n(r.children);
                    if (s) return s;
                  }
                  return null;
                },
                i = n(t.children);
              if (i) return i;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName];
          }
          _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
          }
          _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
          }
          _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
          }
          _setValue_direct_setNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          }
          _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          }
          _setValue_arrayElement_setNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
          }
          _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
          }
          _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
          }
          bind() {
            let t = this.node;
            const e = this.parsedPath,
              n = e.objectName,
              i = e.propertyName;
            let r = e.propertyIndex;
            if (
              (t || ((t = Pu.findNode(this.rootNode, e.nodeName)), (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.warn(
                "THREE.PropertyBinding: No target node found for track: " + this.path + "."
              );
            if (n) {
              let i = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let e = 0; e < t.length; e++)
                    if (t[e].name === i) {
                      i = e;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in t) {
                    t = t.map;
                    break;
                  }
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.map)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this
                    );
                  t = t.material.map;
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== i) {
                if (void 0 === t[i])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[i];
              }
            }
            const s = t[i];
            if (void 0 === s) {
              const n = e.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  n +
                  "." +
                  i +
                  " but it wasn't found.",
                t
              );
            }
            let a = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (a = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === i) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
              }
              (o = this.BindingType.ArrayElement),
                (this.resolvedProperty = s),
                (this.propertyIndex = r);
            } else
              void 0 !== s.fromArray && void 0 !== s.toArray
                ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                : Array.isArray(s)
                ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
                : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[o]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        (Pu.Composite = class {
          constructor(t, e, n) {
            const i = n || Pu.parseTrackName(e);
            (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
          }
          getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              i = this._bindings[n];
            void 0 !== i && i.getValue(t, e);
          }
          setValue(t, e) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
              n[i].setValue(t, e);
          }
          bind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
          }
          unbind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
              t[e].unbind();
          }
        }),
          (Pu.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          }),
          (Pu.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
          (Pu.prototype.GetterByBindingType = [
            Pu.prototype._getValue_direct,
            Pu.prototype._getValue_array,
            Pu.prototype._getValue_arrayElement,
            Pu.prototype._getValue_toArray,
          ]),
          (Pu.prototype.SetterByBindingTypeAndVersioning = [
            [
              Pu.prototype._setValue_direct,
              Pu.prototype._setValue_direct_setNeedsUpdate,
              Pu.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
            ],
            [
              Pu.prototype._setValue_array,
              Pu.prototype._setValue_array_setNeedsUpdate,
              Pu.prototype._setValue_array_setMatrixWorldNeedsUpdate,
            ],
            [
              Pu.prototype._setValue_arrayElement,
              Pu.prototype._setValue_arrayElement_setNeedsUpdate,
              Pu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
            ],
            [
              Pu.prototype._setValue_fromArray,
              Pu.prototype._setValue_fromArray_setNeedsUpdate,
              Pu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
            ],
          ]);
        class Iu {
          constructor(t, e, n = null, i = e.blendMode) {
            (this._mixer = t), (this._clip = e), (this._localRoot = n), (this.blendMode = i);
            const r = e.tracks,
              s = r.length,
              a = new Array(s),
              o = { endingStart: Pt, endingEnd: Pt };
            for (let t = 0; t !== s; ++t) {
              const e = r[t].createInterpolant(null);
              (a[t] = e), (e.settings = o);
            }
            (this._interpolantSettings = o),
              (this._interpolants = a),
              (this._propertyBindings = new Array(s)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = 2201),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(t) {
            return (this._startTime = t), this;
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          }
          setEffectiveWeight(t) {
            return (
              (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                i = t._clip.duration,
                r = i / n,
                s = n / i;
              t.warp(1, r, e), this.warp(s, 1, e);
            }
            return this;
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n);
          }
          stopFading() {
            const t = this._weightInterpolant;
            return (
              null !== t &&
                ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          setEffectiveTimeScale(t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(t) {
            return (this.timeScale = this._clip.duration / t), this.stopWarping();
          }
          syncWith(t) {
            return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping();
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          }
          warp(t, e, n) {
            const i = this._mixer,
              r = i.time,
              s = this.timeScale;
            let a = this._timeScaleInterpolant;
            null === a && ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
            const o = a.parameterPositions,
              l = a.sampleValues;
            return (o[0] = r), (o[1] = r + n), (l[0] = t / s), (l[1] = e / s), this;
          }
          stopWarping() {
            const t = this._timeScaleInterpolant;
            return (
              null !== t &&
                ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
              const i = (t - r) * n;
              i < 0 || 0 === n ? (e = 0) : ((this._startTime = null), (e = n * i));
            }
            e *= this._updateTimeScale(t);
            const s = this._updateTime(e),
              a = this._updateWeight(t);
            if (a > 0) {
              const t = this._interpolants,
                e = this._propertyBindings;
              if (this.blendMode === Nt)
                for (let n = 0, i = t.length; n !== i; ++n)
                  t[n].evaluate(s), e[n].accumulateAdditive(a);
              else
                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, a);
            }
          }
          _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
              e = this.weight;
              const n = this._weightInterpolant;
              if (null !== n) {
                const i = n.evaluate(t)[0];
                (e *= i),
                  t > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === i && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          }
          _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
              e = this.timeScale;
              const n = this._timeScaleInterpolant;
              null !== n &&
                ((e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)));
            }
            return (this._effectiveTimeScale = e), e;
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop;
            let i = this.time + t,
              r = this._loopCount;
            const s = 2202 === n;
            if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
            if (2200 === n) {
              -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (i >= e) i = e;
                else {
                  if (!(i < 0)) {
                    this.time = i;
                    break t;
                  }
                  i = 0;
                }
                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === r &&
                  (t >= 0
                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                    : this._setEndings(0 === this.repetitions, !0, s)),
                i >= e || i < 0)
              ) {
                const n = Math.floor(i / e);
                (i -= e * n), (r += Math.abs(n));
                const a = this.repetitions - r;
                if (a <= 0)
                  this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                    (i = t > 0 ? e : 0),
                    (this.time = i),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === a) {
                    const e = t < 0;
                    this._setEndings(e, !e, s);
                  } else this._setEndings(!1, !1, s);
                  (this._loopCount = r),
                    (this.time = i),
                    this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n });
                }
              } else this.time = i;
              if (s && 1 == (1 & r)) return e - i;
            }
            return i;
          }
          _setEndings(t, e, n) {
            const i = this._interpolantSettings;
            n
              ? ((i.endingStart = It), (i.endingEnd = It))
              : ((i.endingStart = t ? (this.zeroSlopeAtStart ? It : Pt) : Ut),
                (i.endingEnd = e ? (this.zeroSlopeAtEnd ? It : Pt) : Ut));
          }
          _scheduleFading(t, e, n) {
            const i = this._mixer,
              r = i.time;
            let s = this._weightInterpolant;
            null === s && ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
            const a = s.parameterPositions,
              o = s.sampleValues;
            return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = n), this;
          }
        }
        const Uu = new Float32Array(1);
        class Nu {
          constructor(t) {
            this.value = t;
          }
          clone() {
            return new Nu(void 0 === this.value.clone ? this.value : this.value.clone());
          }
        }
        let Du = 0;
        function Ou(t, e) {
          return t.distance - e.distance;
        }
        function Bu(t, e, n, i) {
          if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++) Bu(i[t], e, n, !0);
          }
        }
        const Fu = new de(),
          zu = new ke(),
          Hu = new ke(),
          Gu = new ke(),
          ku = new ke(),
          Vu = new xn(),
          Wu = new xn();
        function Xu(t) {
          const e = [];
          !0 === t.isBone && e.push(t);
          for (let n = 0; n < t.children.length; n++) e.push.apply(e, Xu(t.children[n]));
          return e;
        }
        const ju = new ke(),
          qu = new oi(),
          Yu = new oi(),
          Ku = new ke(),
          Zu = new ke(),
          Ju = new ke(),
          Qu = new ke(),
          $u = new nr();
        function td(t, e, n, i, r, s, a) {
          Qu.set(r, s, a).unproject(i);
          const o = e[t];
          if (void 0 !== o) {
            const t = n.getAttribute("position");
            for (let e = 0, n = o.length; e < n; e++) t.setXYZ(o[e], Qu.x, Qu.y, Qu.z);
          }
        }
        const ed = new Xe(),
          nd = new ke();
        let id, rd;
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: n } })
          ),
          "undefined" != typeof window &&
            (window.__THREE__
              ? console.warn("WARNING: Multiple instances of Three.js being imported.")
              : (window.__THREE__ = n)),
          (e.ACESFilmicToneMapping = g),
          (e.AddEquation = a),
          (e.AddOperation = u),
          (e.AdditiveAnimationBlendMode = Nt),
          (e.AdditiveBlending = 2),
          (e.AgXToneMapping = v),
          (e.AlphaFormat = 1021),
          (e.AlwaysCompare = 519),
          (e.AlwaysDepth = 1),
          (e.AlwaysStencilFunc = 519),
          (e.AmbientLight = Jh),
          (e.AnimationAction = Iu),
          (e.AnimationClip = Ah),
          (e.AnimationLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new Nh(this.manager);
              s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(
                  t,
                  function (n) {
                    try {
                      e(r.parse(JSON.parse(n)));
                    } catch (e) {
                      i ? i(e) : console.error(e), r.manager.itemError(t);
                    }
                  },
                  n,
                  i
                );
            }
            parse(t) {
              const e = [];
              for (let n = 0; n < t.length; n++) {
                const i = Ah.parse(t[n]);
                e.push(i);
              }
              return e;
            }
          }),
          (e.AnimationMixer = class extends Qt {
            constructor(t) {
              super(),
                (this._root = t),
                this._initMemoryManager(),
                (this._accuIndex = 0),
                (this.time = 0),
                (this.timeScale = 1);
            }
            _bindAction(t, e) {
              const n = t._localRoot || this._root,
                i = t._clip.tracks,
                r = i.length,
                s = t._propertyBindings,
                a = t._interpolants,
                o = n.uuid,
                l = this._bindingsByRootAndName;
              let c = l[o];
              void 0 === c && ((c = {}), (l[o] = c));
              for (let t = 0; t !== r; ++t) {
                const r = i[t],
                  l = r.name;
                let h = c[l];
                if (void 0 !== h) ++h.referenceCount, (s[t] = h);
                else {
                  if (((h = s[t]), void 0 !== h)) {
                    null === h._cacheIndex &&
                      (++h.referenceCount, this._addInactiveBinding(h, o, l));
                    continue;
                  }
                  const i = e && e._propertyBindings[t].binding.parsedPath;
                  (h = new Eu(Pu.create(n, l, i), r.ValueTypeName, r.getValueSize())),
                    ++h.referenceCount,
                    this._addInactiveBinding(h, o, l),
                    (s[t] = h);
                }
                a[t].resultBuffer = h.buffer;
              }
            }
            _activateAction(t) {
              if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                  const e = (t._localRoot || this._root).uuid,
                    n = t._clip.uuid,
                    i = this._actionsByClip[n];
                  this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e);
                }
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                  const n = e[t];
                  0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
                }
                this._lendAction(t);
              }
            }
            _deactivateAction(t) {
              if (this._isActiveAction(t)) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                  const n = e[t];
                  0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n));
                }
                this._takeBackAction(t);
              }
            }
            _initMemoryManager() {
              (this._actions = []),
                (this._nActiveActions = 0),
                (this._actionsByClip = {}),
                (this._bindings = []),
                (this._nActiveBindings = 0),
                (this._bindingsByRootAndName = {}),
                (this._controlInterpolants = []),
                (this._nActiveControlInterpolants = 0);
              const t = this;
              this.stats = {
                actions: {
                  get total() {
                    return t._actions.length;
                  },
                  get inUse() {
                    return t._nActiveActions;
                  },
                },
                bindings: {
                  get total() {
                    return t._bindings.length;
                  },
                  get inUse() {
                    return t._nActiveBindings;
                  },
                },
                controlInterpolants: {
                  get total() {
                    return t._controlInterpolants.length;
                  },
                  get inUse() {
                    return t._nActiveControlInterpolants;
                  },
                },
              };
            }
            _isActiveAction(t) {
              const e = t._cacheIndex;
              return null !== e && e < this._nActiveActions;
            }
            _addInactiveAction(t, e, n) {
              const i = this._actions,
                r = this._actionsByClip;
              let s = r[e];
              if (void 0 === s)
                (s = { knownActions: [t], actionByRoot: {} }),
                  (t._byClipCacheIndex = 0),
                  (r[e] = s);
              else {
                const e = s.knownActions;
                (t._byClipCacheIndex = e.length), e.push(t);
              }
              (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
            }
            _removeInactiveAction(t) {
              const e = this._actions,
                n = e[e.length - 1],
                i = t._cacheIndex;
              (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
              const r = t._clip.uuid,
                s = this._actionsByClip,
                a = s[r],
                o = a.knownActions,
                l = o[o.length - 1],
                c = t._byClipCacheIndex;
              (l._byClipCacheIndex = c),
                (o[c] = l),
                o.pop(),
                (t._byClipCacheIndex = null),
                delete a.actionByRoot[(t._localRoot || this._root).uuid],
                0 === o.length && delete s[r],
                this._removeInactiveBindingsForAction(t);
            }
            _removeInactiveBindingsForAction(t) {
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n);
              }
            }
            _lendAction(t) {
              const e = this._actions,
                n = t._cacheIndex,
                i = this._nActiveActions++,
                r = e[i];
              (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
            }
            _takeBackAction(t) {
              const e = this._actions,
                n = t._cacheIndex,
                i = --this._nActiveActions,
                r = e[i];
              (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
            }
            _addInactiveBinding(t, e, n) {
              const i = this._bindingsByRootAndName,
                r = this._bindings;
              let s = i[e];
              void 0 === s && ((s = {}), (i[e] = s)),
                (s[n] = t),
                (t._cacheIndex = r.length),
                r.push(t);
            }
            _removeInactiveBinding(t) {
              const e = this._bindings,
                n = t.binding,
                i = n.rootNode.uuid,
                r = n.path,
                s = this._bindingsByRootAndName,
                a = s[i],
                o = e[e.length - 1],
                l = t._cacheIndex;
              (o._cacheIndex = l),
                (e[l] = o),
                e.pop(),
                delete a[r],
                0 === Object.keys(a).length && delete s[i];
            }
            _lendBinding(t) {
              const e = this._bindings,
                n = t._cacheIndex,
                i = this._nActiveBindings++,
                r = e[i];
              (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
            }
            _takeBackBinding(t) {
              const e = this._bindings,
                n = t._cacheIndex,
                i = --this._nActiveBindings,
                r = e[i];
              (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
            }
            _lendControlInterpolant() {
              const t = this._controlInterpolants,
                e = this._nActiveControlInterpolants++;
              let n = t[e];
              return (
                void 0 === n &&
                  ((n = new gh(new Float32Array(2), new Float32Array(2), 1, Uu)),
                  (n.__cacheIndex = e),
                  (t[e] = n)),
                n
              );
            }
            _takeBackControlInterpolant(t) {
              const e = this._controlInterpolants,
                n = t.__cacheIndex,
                i = --this._nActiveControlInterpolants,
                r = e[i];
              (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
            }
            clipAction(t, e, n) {
              const i = e || this._root,
                r = i.uuid;
              let s = "string" == typeof t ? Ah.findByName(i, t) : t;
              const a = null !== s ? s.uuid : t,
                o = this._actionsByClip[a];
              let l = null;
              if ((void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o)) {
                const t = o.actionByRoot[r];
                if (void 0 !== t && t.blendMode === n) return t;
                (l = o.knownActions[0]), null === s && (s = l._clip);
              }
              if (null === s) return null;
              const c = new Iu(this, s, e, n);
              return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
            }
            existingAction(t, e) {
              const n = e || this._root,
                i = n.uuid,
                r = "string" == typeof t ? Ah.findByName(n, t) : t,
                s = r ? r.uuid : t,
                a = this._actionsByClip[s];
              return (void 0 !== a && a.actionByRoot[i]) || null;
            }
            stopAllAction() {
              const t = this._actions;
              for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
              return this;
            }
            update(t) {
              t *= this.timeScale;
              const e = this._actions,
                n = this._nActiveActions,
                i = (this.time += t),
                r = Math.sign(t),
                s = (this._accuIndex ^= 1);
              for (let a = 0; a !== n; ++a) e[a]._update(i, t, r, s);
              const a = this._bindings,
                o = this._nActiveBindings;
              for (let t = 0; t !== o; ++t) a[t].apply(s);
              return this;
            }
            setTime(t) {
              this.time = 0;
              for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
              return this.update(t);
            }
            getRoot() {
              return this._root;
            }
            uncacheClip(t) {
              const e = this._actions,
                n = t.uuid,
                i = this._actionsByClip,
                r = i[n];
              if (void 0 !== r) {
                const t = r.knownActions;
                for (let n = 0, i = t.length; n !== i; ++n) {
                  const i = t[n];
                  this._deactivateAction(i);
                  const r = i._cacheIndex,
                    s = e[e.length - 1];
                  (i._cacheIndex = null),
                    (i._byClipCacheIndex = null),
                    (s._cacheIndex = r),
                    (e[r] = s),
                    e.pop(),
                    this._removeInactiveBindingsForAction(i);
                }
                delete i[n];
              }
            }
            uncacheRoot(t) {
              const e = t.uuid,
                n = this._actionsByClip;
              for (const t in n) {
                const i = n[t].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
              }
              const i = this._bindingsByRootAndName[e];
              if (void 0 !== i)
                for (const t in i) {
                  const e = i[t];
                  e.restoreOriginalState(), this._removeInactiveBinding(e);
                }
            }
            uncacheAction(t, e) {
              const n = this.existingAction(t, e);
              null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
            }
          }),
          (e.AnimationObjectGroup = class {
            constructor() {
              (this.isAnimationObjectGroup = !0),
                (this.uuid = ie()),
                (this._objects = Array.prototype.slice.call(arguments)),
                (this.nCachedObjects_ = 0);
              const t = {};
              this._indicesByUUID = t;
              for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
              (this._paths = []),
                (this._parsedPaths = []),
                (this._bindings = []),
                (this._bindingsIndicesByPath = {});
              const e = this;
              this.stats = {
                objects: {
                  get total() {
                    return e._objects.length;
                  },
                  get inUse() {
                    return this.total - e.nCachedObjects_;
                  },
                },
                get bindingsPerObject() {
                  return e._bindings.length;
                },
              };
            }
            add() {
              const t = this._objects,
                e = this._indicesByUUID,
                n = this._paths,
                i = this._parsedPaths,
                r = this._bindings,
                s = r.length;
              let a,
                o = t.length,
                l = this.nCachedObjects_;
              for (let c = 0, h = arguments.length; c !== h; ++c) {
                const h = arguments[c],
                  u = h.uuid;
                let d = e[u];
                if (void 0 === d) {
                  (d = o++), (e[u] = d), t.push(h);
                  for (let t = 0, e = s; t !== e; ++t) r[t].push(new Pu(h, n[t], i[t]));
                } else if (d < l) {
                  a = t[d];
                  const o = --l,
                    c = t[o];
                  (e[c.uuid] = d), (t[d] = c), (e[u] = o), (t[o] = h);
                  for (let t = 0, e = s; t !== e; ++t) {
                    const e = r[t],
                      s = e[o];
                    let a = e[d];
                    (e[d] = s), void 0 === a && (a = new Pu(h, n[t], i[t])), (e[o] = a);
                  }
                } else
                  t[d] !== a &&
                    console.error(
                      "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                    );
              }
              this.nCachedObjects_ = l;
            }
            remove() {
              const t = this._objects,
                e = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
              let r = this.nCachedObjects_;
              for (let s = 0, a = arguments.length; s !== a; ++s) {
                const a = arguments[s],
                  o = a.uuid,
                  l = e[o];
                if (void 0 !== l && l >= r) {
                  const s = r++,
                    c = t[s];
                  (e[c.uuid] = l), (t[l] = c), (e[o] = s), (t[s] = a);
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t],
                      i = e[s],
                      r = e[l];
                    (e[l] = i), (e[s] = r);
                  }
                }
              }
              this.nCachedObjects_ = r;
            }
            uncache() {
              const t = this._objects,
                e = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
              let r = this.nCachedObjects_,
                s = t.length;
              for (let a = 0, o = arguments.length; a !== o; ++a) {
                const o = arguments[a].uuid,
                  l = e[o];
                if (void 0 !== l)
                  if ((delete e[o], l < r)) {
                    const a = --r,
                      o = t[a],
                      c = --s,
                      h = t[c];
                    (e[o.uuid] = l), (t[l] = o), (e[h.uuid] = a), (t[a] = h), t.pop();
                    for (let t = 0, e = i; t !== e; ++t) {
                      const e = n[t],
                        i = e[a],
                        r = e[c];
                      (e[l] = i), (e[a] = r), e.pop();
                    }
                  } else {
                    const r = --s,
                      a = t[r];
                    r > 0 && (e[a.uuid] = l), (t[l] = a), t.pop();
                    for (let t = 0, e = i; t !== e; ++t) {
                      const e = n[t];
                      (e[l] = e[r]), e.pop();
                    }
                  }
              }
              this.nCachedObjects_ = r;
            }
            subscribe_(t, e) {
              const n = this._bindingsIndicesByPath;
              let i = n[t];
              const r = this._bindings;
              if (void 0 !== i) return r[i];
              const s = this._paths,
                a = this._parsedPaths,
                o = this._objects,
                l = o.length,
                c = this.nCachedObjects_,
                h = new Array(l);
              (i = r.length), (n[t] = i), s.push(t), a.push(e), r.push(h);
              for (let n = c, i = o.length; n !== i; ++n) {
                const i = o[n];
                h[n] = new Pu(i, t, e);
              }
              return h;
            }
            unsubscribe_(t) {
              const e = this._bindingsIndicesByPath,
                n = e[t];
              if (void 0 !== n) {
                const i = this._paths,
                  r = this._parsedPaths,
                  s = this._bindings,
                  a = s.length - 1,
                  o = s[a];
                (e[t[a]] = n), (s[n] = o), s.pop(), (r[n] = r[a]), r.pop(), (i[n] = i[a]), i.pop();
              }
            }
          }),
          (e.AnimationUtils = ph),
          (e.ArcCurve = Il),
          (e.ArrayCamera = Va),
          (e.ArrowHelper = class extends Wn {
            constructor(
              t = new ke(0, 0, 1),
              e = new ke(0, 0, 0),
              n = 1,
              i = 16776960,
              r = 0.2 * n,
              s = 0.2 * r
            ) {
              super(),
                (this.type = "ArrowHelper"),
                void 0 === id &&
                  ((id = new Li()),
                  id.setAttribute("position", new Si([0, 0, 0, 0, 1, 0], 3)),
                  (rd = new ec(0, 0.5, 1, 5, 1)),
                  rd.translate(0, -0.5, 0)),
                this.position.copy(e),
                (this.line = new _l(id, new ul({ color: i, toneMapped: !1 }))),
                (this.line.matrixAutoUpdate = !1),
                this.add(this.line),
                (this.cone = new Yi(rd, new ui({ color: i, toneMapped: !1 }))),
                (this.cone.matrixAutoUpdate = !1),
                this.add(this.cone),
                this.setDirection(t),
                this.setLength(n, r, s);
            }
            setDirection(t) {
              if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
              else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
              else {
                nd.set(t.z, 0, -t.x).normalize();
                const e = Math.acos(t.y);
                this.quaternion.setFromAxisAngle(nd, e);
              }
            }
            setLength(t, e = 0.2 * t, n = 0.2 * e) {
              this.line.scale.set(1, Math.max(1e-4, t - e), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(n, e, n),
                (this.cone.position.y = t),
                this.cone.updateMatrix();
            }
            setColor(t) {
              this.line.material.color.set(t), this.cone.material.color.set(t);
            }
            copy(t) {
              return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
            }
            dispose() {
              this.line.geometry.dispose(),
                this.line.material.dispose(),
                this.cone.geometry.dispose(),
                this.cone.material.dispose();
            }
          }),
          (e.AttachedBindMode = x),
          (e.Audio = xu),
          (e.AudioAnalyser = class {
            constructor(t, e = 2048) {
              (this.analyser = t.context.createAnalyser()),
                (this.analyser.fftSize = e),
                (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
                t.getOutput().connect(this.analyser);
            }
            getFrequencyData() {
              return this.analyser.getByteFrequencyData(this.data), this.data;
            }
            getAverageFrequency() {
              let t = 0;
              const e = this.getFrequencyData();
              for (let n = 0; n < e.length; n++) t += e[n];
              return t / e.length;
            }
          }),
          (e.AudioContext = cu),
          (e.AudioListener = class extends Wn {
            constructor() {
              super(),
                (this.type = "AudioListener"),
                (this.context = cu.getContext()),
                (this.gain = this.context.createGain()),
                this.gain.connect(this.context.destination),
                (this.filter = null),
                (this.timeDelta = 0),
                (this._clock = new pu());
            }
            getInput() {
              return this.gain;
            }
            removeFilter() {
              return (
                null !== this.filter &&
                  (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination),
                  this.gain.connect(this.context.destination),
                  (this.filter = null)),
                this
              );
            }
            getFilter() {
              return this.filter;
            }
            setFilter(t) {
              return (
                null !== this.filter
                  ? (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination))
                  : this.gain.disconnect(this.context.destination),
                (this.filter = t),
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
              );
            }
            getMasterVolume() {
              return this.gain.gain.value;
            }
            setMasterVolume(t) {
              return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
            }
            updateMatrixWorld(t) {
              super.updateMatrixWorld(t);
              const e = this.context.listener,
                n = this.up;
              if (
                ((this.timeDelta = this._clock.getDelta()),
                this.matrixWorld.decompose(mu, gu, _u),
                vu.set(0, 0, -1).applyQuaternion(gu),
                e.positionX)
              ) {
                const t = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(mu.x, t),
                  e.positionY.linearRampToValueAtTime(mu.y, t),
                  e.positionZ.linearRampToValueAtTime(mu.z, t),
                  e.forwardX.linearRampToValueAtTime(vu.x, t),
                  e.forwardY.linearRampToValueAtTime(vu.y, t),
                  e.forwardZ.linearRampToValueAtTime(vu.z, t),
                  e.upX.linearRampToValueAtTime(n.x, t),
                  e.upY.linearRampToValueAtTime(n.y, t),
                  e.upZ.linearRampToValueAtTime(n.z, t);
              } else
                e.setPosition(mu.x, mu.y, mu.z), e.setOrientation(vu.x, vu.y, vu.z, n.x, n.y, n.z);
            }
          }),
          (e.AudioLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new Nh(this.manager);
              function a(e) {
                i ? i(e) : console.error(e), r.manager.itemError(t);
              }
              s.setResponseType("arraybuffer"),
                s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(
                  t,
                  function (t) {
                    try {
                      const n = t.slice(0);
                      cu.getContext()
                        .decodeAudioData(n, function (t) {
                          e(t);
                        })
                        .catch(a);
                    } catch (t) {
                      a(t);
                    }
                  },
                  n,
                  i
                );
            }
          }),
          (e.AxesHelper = class extends yl {
            constructor(t = 1) {
              const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                n = new Li();
              n.setAttribute("position", new Si(e, 3)),
                n.setAttribute(
                  "color",
                  new Si([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
                ),
                super(n, new ul({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "AxesHelper");
            }
            setColors(t, e, n) {
              const i = new oi(),
                r = this.geometry.attributes.color.array;
              return (
                i.set(t),
                i.toArray(r, 0),
                i.toArray(r, 3),
                i.set(e),
                i.toArray(r, 6),
                i.toArray(r, 9),
                i.set(n),
                i.toArray(r, 12),
                i.toArray(r, 15),
                (this.geometry.attributes.color.needsUpdate = !0),
                this
              );
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.BackSide = 1),
          (e.BasicDepthPacking = 3200),
          (e.BasicShadowMap = 0),
          (e.BatchedMesh = hl),
          (e.Bone = No),
          (e.BooleanKeyframeTrack = xh),
          (e.Box2 = class {
            constructor(t = new de(1 / 0, 1 / 0), e = new de(-1 / 0, -1 / 0)) {
              (this.isBox2 = !0), (this.min = t), (this.max = e);
            }
            set(t, e) {
              return this.min.copy(t), this.max.copy(e), this;
            }
            setFromPoints(t) {
              this.makeEmpty();
              for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
              return this;
            }
            setFromCenterAndSize(t, e) {
              const n = Fu.copy(e).multiplyScalar(0.5);
              return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(t) {
              return this.min.copy(t.min), this.max.copy(t.max), this;
            }
            makeEmpty() {
              return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
            }
            isEmpty() {
              return this.max.x < this.min.x || this.max.y < this.min.y;
            }
            getCenter(t) {
              return this.isEmpty()
                ? t.set(0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
            getSize(t) {
              return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
            }
            expandByPoint(t) {
              return this.min.min(t), this.max.max(t), this;
            }
            expandByVector(t) {
              return this.min.sub(t), this.max.add(t), this;
            }
            expandByScalar(t) {
              return this.min.addScalar(-t), this.max.addScalar(t), this;
            }
            containsPoint(t) {
              return !(
                t.x < this.min.x ||
                t.x > this.max.x ||
                t.y < this.min.y ||
                t.y > this.max.y
              );
            }
            containsBox(t) {
              return (
                this.min.x <= t.min.x &&
                t.max.x <= this.max.x &&
                this.min.y <= t.min.y &&
                t.max.y <= this.max.y
              );
            }
            getParameter(t, e) {
              return e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y)
              );
            }
            intersectsBox(t) {
              return !(
                t.max.x < this.min.x ||
                t.min.x > this.max.x ||
                t.max.y < this.min.y ||
                t.min.y > this.max.y
              );
            }
            clampPoint(t, e) {
              return e.copy(t).clamp(this.min, this.max);
            }
            distanceToPoint(t) {
              return this.clampPoint(t, Fu).distanceTo(t);
            }
            intersect(t) {
              return (
                this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
              );
            }
            union(t) {
              return this.min.min(t.min), this.max.max(t.max), this;
            }
            translate(t) {
              return this.min.add(t), this.max.add(t), this;
            }
            equals(t) {
              return t.min.equals(this.min) && t.max.equals(this.max);
            }
          }),
          (e.Box3 = Xe),
          (e.Box3Helper = class extends yl {
            constructor(t, e = 16776960) {
              const n = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
                ]),
                i = new Li();
              i.setIndex(new xi(n, 1)),
                i.setAttribute(
                  "position",
                  new Si(
                    [
                      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1,
                      -1, -1,
                    ],
                    3
                  )
                ),
                super(i, new ul({ color: e, toneMapped: !1 })),
                (this.box = t),
                (this.type = "Box3Helper"),
                this.geometry.computeBoundingSphere();
            }
            updateMatrixWorld(t) {
              const e = this.box;
              e.isEmpty() ||
                (e.getCenter(this.position),
                e.getSize(this.scale),
                this.scale.multiplyScalar(0.5),
                super.updateMatrixWorld(t));
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.BoxGeometry = Zi),
          (e.BoxHelper = class extends yl {
            constructor(t, e = 16776960) {
              const n = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
                ]),
                i = new Float32Array(24),
                r = new Li();
              r.setIndex(new xi(n, 1)),
                r.setAttribute("position", new xi(i, 3)),
                super(r, new ul({ color: e, toneMapped: !1 })),
                (this.object = t),
                (this.type = "BoxHelper"),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            update(t) {
              if (
                (void 0 !== t &&
                  console.warn("THREE.BoxHelper: .update() has no longer arguments."),
                void 0 !== this.object && ed.setFromObject(this.object),
                ed.isEmpty())
              )
                return;
              const e = ed.min,
                n = ed.max,
                i = this.geometry.attributes.position,
                r = i.array;
              (r[0] = n.x),
                (r[1] = n.y),
                (r[2] = n.z),
                (r[3] = e.x),
                (r[4] = n.y),
                (r[5] = n.z),
                (r[6] = e.x),
                (r[7] = e.y),
                (r[8] = n.z),
                (r[9] = n.x),
                (r[10] = e.y),
                (r[11] = n.z),
                (r[12] = n.x),
                (r[13] = n.y),
                (r[14] = e.z),
                (r[15] = e.x),
                (r[16] = n.y),
                (r[17] = e.z),
                (r[18] = e.x),
                (r[19] = e.y),
                (r[20] = e.z),
                (r[21] = n.x),
                (r[22] = e.y),
                (r[23] = e.z),
                (i.needsUpdate = !0),
                this.geometry.computeBoundingSphere();
            }
            setFromObject(t) {
              return (this.object = t), this.update(), this;
            }
            copy(t, e) {
              return super.copy(t, e), (this.object = t.object), this;
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.BufferAttribute = xi),
          (e.BufferGeometry = Li),
          (e.BufferGeometryLoader = ru),
          (e.ByteType = 1010),
          (e.Cache = Rh),
          (e.Camera = nr),
          (e.CameraHelper = class extends yl {
            constructor(t) {
              const e = new Li(),
                n = new ul({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
                i = [],
                r = [],
                s = {};
              function a(t, e) {
                o(t), o(e);
              }
              function o(t) {
                i.push(0, 0, 0),
                  r.push(0, 0, 0),
                  void 0 === s[t] && (s[t] = []),
                  s[t].push(i.length / 3 - 1);
              }
              a("n1", "n2"),
                a("n2", "n4"),
                a("n4", "n3"),
                a("n3", "n1"),
                a("f1", "f2"),
                a("f2", "f4"),
                a("f4", "f3"),
                a("f3", "f1"),
                a("n1", "f1"),
                a("n2", "f2"),
                a("n3", "f3"),
                a("n4", "f4"),
                a("p", "n1"),
                a("p", "n2"),
                a("p", "n3"),
                a("p", "n4"),
                a("u1", "u2"),
                a("u2", "u3"),
                a("u3", "u1"),
                a("c", "t"),
                a("p", "c"),
                a("cn1", "cn2"),
                a("cn3", "cn4"),
                a("cf1", "cf2"),
                a("cf3", "cf4"),
                e.setAttribute("position", new Si(i, 3)),
                e.setAttribute("color", new Si(r, 3)),
                super(e, n),
                (this.type = "CameraHelper"),
                (this.camera = t),
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.pointMap = s),
                this.update();
              const l = new oi(16755200),
                c = new oi(16711680),
                h = new oi(43775),
                u = new oi(16777215),
                d = new oi(3355443);
              this.setColors(l, c, h, u, d);
            }
            setColors(t, e, n, i, r) {
              const s = this.geometry.getAttribute("color");
              s.setXYZ(0, t.r, t.g, t.b),
                s.setXYZ(1, t.r, t.g, t.b),
                s.setXYZ(2, t.r, t.g, t.b),
                s.setXYZ(3, t.r, t.g, t.b),
                s.setXYZ(4, t.r, t.g, t.b),
                s.setXYZ(5, t.r, t.g, t.b),
                s.setXYZ(6, t.r, t.g, t.b),
                s.setXYZ(7, t.r, t.g, t.b),
                s.setXYZ(8, t.r, t.g, t.b),
                s.setXYZ(9, t.r, t.g, t.b),
                s.setXYZ(10, t.r, t.g, t.b),
                s.setXYZ(11, t.r, t.g, t.b),
                s.setXYZ(12, t.r, t.g, t.b),
                s.setXYZ(13, t.r, t.g, t.b),
                s.setXYZ(14, t.r, t.g, t.b),
                s.setXYZ(15, t.r, t.g, t.b),
                s.setXYZ(16, t.r, t.g, t.b),
                s.setXYZ(17, t.r, t.g, t.b),
                s.setXYZ(18, t.r, t.g, t.b),
                s.setXYZ(19, t.r, t.g, t.b),
                s.setXYZ(20, t.r, t.g, t.b),
                s.setXYZ(21, t.r, t.g, t.b),
                s.setXYZ(22, t.r, t.g, t.b),
                s.setXYZ(23, t.r, t.g, t.b),
                s.setXYZ(24, e.r, e.g, e.b),
                s.setXYZ(25, e.r, e.g, e.b),
                s.setXYZ(26, e.r, e.g, e.b),
                s.setXYZ(27, e.r, e.g, e.b),
                s.setXYZ(28, e.r, e.g, e.b),
                s.setXYZ(29, e.r, e.g, e.b),
                s.setXYZ(30, e.r, e.g, e.b),
                s.setXYZ(31, e.r, e.g, e.b),
                s.setXYZ(32, n.r, n.g, n.b),
                s.setXYZ(33, n.r, n.g, n.b),
                s.setXYZ(34, n.r, n.g, n.b),
                s.setXYZ(35, n.r, n.g, n.b),
                s.setXYZ(36, n.r, n.g, n.b),
                s.setXYZ(37, n.r, n.g, n.b),
                s.setXYZ(38, i.r, i.g, i.b),
                s.setXYZ(39, i.r, i.g, i.b),
                s.setXYZ(40, r.r, r.g, r.b),
                s.setXYZ(41, r.r, r.g, r.b),
                s.setXYZ(42, r.r, r.g, r.b),
                s.setXYZ(43, r.r, r.g, r.b),
                s.setXYZ(44, r.r, r.g, r.b),
                s.setXYZ(45, r.r, r.g, r.b),
                s.setXYZ(46, r.r, r.g, r.b),
                s.setXYZ(47, r.r, r.g, r.b),
                s.setXYZ(48, r.r, r.g, r.b),
                s.setXYZ(49, r.r, r.g, r.b),
                (s.needsUpdate = !0);
            }
            update() {
              const t = this.geometry,
                e = this.pointMap;
              $u.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                td("c", e, t, $u, 0, 0, -1),
                td("t", e, t, $u, 0, 0, 1),
                td("n1", e, t, $u, -1, -1, -1),
                td("n2", e, t, $u, 1, -1, -1),
                td("n3", e, t, $u, -1, 1, -1),
                td("n4", e, t, $u, 1, 1, -1),
                td("f1", e, t, $u, -1, -1, 1),
                td("f2", e, t, $u, 1, -1, 1),
                td("f3", e, t, $u, -1, 1, 1),
                td("f4", e, t, $u, 1, 1, 1),
                td("u1", e, t, $u, 0.7, 1.1, -1),
                td("u2", e, t, $u, -0.7, 1.1, -1),
                td("u3", e, t, $u, 0, 2, -1),
                td("cf1", e, t, $u, -1, 0, 1),
                td("cf2", e, t, $u, 1, 0, 1),
                td("cf3", e, t, $u, 0, -1, 1),
                td("cf4", e, t, $u, 0, 1, 1),
                td("cn1", e, t, $u, -1, 0, -1),
                td("cn2", e, t, $u, 1, 0, -1),
                td("cn3", e, t, $u, 0, -1, -1),
                td("cn4", e, t, $u, 0, 1, -1),
                (t.getAttribute("position").needsUpdate = !0);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.CanvasTexture = class extends De {
            constructor(t, e, n, i, r, s, a, o, l) {
              super(t, e, n, i, r, s, a, o, l),
                (this.isCanvasTexture = !0),
                (this.needsUpdate = !0);
            }
          }),
          (e.CapsuleGeometry = $l),
          (e.CatmullRomCurve3 = Fl),
          (e.CineonToneMapping = m),
          (e.CircleGeometry = tc),
          (e.ClampToEdgeWrapping = R),
          (e.Clock = pu),
          (e.Color = oi),
          (e.ColorKeyframeTrack = yh),
          (e.ColorManagement = Ae),
          (e.CompressedArrayTexture = class extends Cl {
            constructor(t, e, n, i, r, s) {
              super(t, e, n, r, s),
                (this.isCompressedArrayTexture = !0),
                (this.image.depth = i),
                (this.wrapR = R);
            }
          }),
          (e.CompressedCubeTexture = class extends Cl {
            constructor(t, e, n) {
              super(void 0, t[0].width, t[0].height, e, n, S),
                (this.isCompressedCubeTexture = !0),
                (this.isCubeTexture = !0),
                (this.image = t);
            }
          }),
          (e.CompressedTexture = Cl),
          (e.CompressedTextureLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = [],
                a = new Cl(),
                o = new Nh(this.manager);
              o.setPath(this.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(r.withCredentials);
              let l = 0;
              function c(c) {
                o.load(
                  t[c],
                  function (t) {
                    const n = r.parse(t, !0);
                    (s[c] = {
                      width: n.width,
                      height: n.height,
                      format: n.format,
                      mipmaps: n.mipmaps,
                    }),
                      (l += 1),
                      6 === l &&
                        (1 === n.mipmapCount && (a.minFilter = U),
                        (a.image = s),
                        (a.format = n.format),
                        (a.needsUpdate = !0),
                        e && e(a));
                  },
                  n,
                  i
                );
              }
              if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) c(e);
              else
                o.load(
                  t,
                  function (t) {
                    const n = r.parse(t, !0);
                    if (n.isCubemap) {
                      const t = n.mipmaps.length / n.mipmapCount;
                      for (let e = 0; e < t; e++) {
                        s[e] = { mipmaps: [] };
                        for (let t = 0; t < n.mipmapCount; t++)
                          s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                            (s[e].format = n.format),
                            (s[e].width = n.width),
                            (s[e].height = n.height);
                      }
                      a.image = s;
                    } else
                      (a.image.width = n.width),
                        (a.image.height = n.height),
                        (a.mipmaps = n.mipmaps);
                    1 === n.mipmapCount && (a.minFilter = U),
                      (a.format = n.format),
                      (a.needsUpdate = !0),
                      e && e(a);
                  },
                  n,
                  i
                );
              return a;
            }
          }),
          (e.ConeGeometry = nc),
          (e.ConstantAlphaFactor = 213),
          (e.ConstantColorFactor = 211),
          (e.CubeCamera = sr),
          (e.CubeReflectionMapping = S),
          (e.CubeRefractionMapping = b),
          (e.CubeTexture = ar),
          (e.CubeTextureLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = new ar();
              r.colorSpace = Ft;
              const s = new Dh(this.manager);
              s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
              let a = 0;
              function o(n) {
                s.load(
                  t[n],
                  function (t) {
                    (r.images[n] = t), a++, 6 === a && ((r.needsUpdate = !0), e && e(r));
                  },
                  void 0,
                  i
                );
              }
              for (let e = 0; e < t.length; ++e) o(e);
              return r;
            }
          }),
          (e.CubeUVReflectionMapping = A),
          (e.CubicBezierCurve = kl),
          (e.CubicBezierCurve3 = Vl),
          (e.CubicInterpolant = mh),
          (e.CullFaceBack = 1),
          (e.CullFaceFront = 2),
          (e.CullFaceFrontBack = 3),
          (e.CullFaceNone = 0),
          (e.Curve = Ll),
          (e.CurvePath = Zl),
          (e.CustomBlending = 5),
          (e.CustomToneMapping = _),
          (e.CylinderGeometry = ec),
          (e.Cylindrical = class {
            constructor(t = 1, e = 0, n = 0) {
              return (this.radius = t), (this.theta = e), (this.y = n), this;
            }
            set(t, e, n) {
              return (this.radius = t), (this.theta = e), (this.y = n), this;
            }
            copy(t) {
              return (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this;
            }
            setFromVector3(t) {
              return this.setFromCartesianCoords(t.x, t.y, t.z);
            }
            setFromCartesianCoords(t, e, n) {
              return (
                (this.radius = Math.sqrt(t * t + n * n)),
                (this.theta = Math.atan2(t, n)),
                (this.y = e),
                this
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }),
          (e.Data3DTexture = He),
          (e.DataArrayTexture = ze),
          (e.DataTexture = Do),
          (e.DataTextureLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new Do(),
                a = new Nh(this.manager);
              return (
                a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setPath(this.path),
                a.setWithCredentials(r.withCredentials),
                a.load(
                  t,
                  function (t) {
                    let n;
                    try {
                      n = r.parse(t);
                    } catch (t) {
                      if (void 0 === i) return void console.error(t);
                      i(t);
                    }
                    void 0 !== n.image
                      ? (s.image = n.image)
                      : void 0 !== n.data &&
                        ((s.image.width = n.width),
                        (s.image.height = n.height),
                        (s.image.data = n.data)),
                      (s.wrapS = void 0 !== n.wrapS ? n.wrapS : R),
                      (s.wrapT = void 0 !== n.wrapT ? n.wrapT : R),
                      (s.magFilter = void 0 !== n.magFilter ? n.magFilter : U),
                      (s.minFilter = void 0 !== n.minFilter ? n.minFilter : U),
                      (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                      void 0 !== n.colorSpace
                        ? (s.colorSpace = n.colorSpace)
                        : void 0 !== n.encoding && (s.encoding = n.encoding),
                      void 0 !== n.flipY && (s.flipY = n.flipY),
                      void 0 !== n.format && (s.format = n.format),
                      void 0 !== n.type && (s.type = n.type),
                      void 0 !== n.mipmaps && ((s.mipmaps = n.mipmaps), (s.minFilter = D)),
                      1 === n.mipmapCount && (s.minFilter = U),
                      void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                      (s.needsUpdate = !0),
                      e && e(s, n);
                  },
                  n,
                  i
                ),
                s
              );
            }
          }),
          (e.DataUtils = gi),
          (e.DecrementStencilOp = 7683),
          (e.DecrementWrapStencilOp = 34056),
          (e.DefaultLoadingManager = Lh),
          (e.DepthFormat = j),
          (e.DepthStencilFormat = q),
          (e.DepthTexture = Qr),
          (e.DetachedBindMode = y),
          (e.DirectionalLight = Zh),
          (e.DirectionalLightHelper = class extends Wn {
            constructor(t, e, n) {
              super(),
                (this.light = t),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                (this.type = "DirectionalLightHelper"),
                void 0 === e && (e = 1);
              let i = new Li();
              i.setAttribute(
                "position",
                new Si([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
              );
              const r = new ul({ fog: !1, toneMapped: !1 });
              (this.lightPlane = new _l(i, r)),
                this.add(this.lightPlane),
                (i = new Li()),
                i.setAttribute("position", new Si([0, 0, 0, 0, 0, 1], 3)),
                (this.targetLine = new _l(i, r)),
                this.add(this.targetLine),
                this.update();
            }
            dispose() {
              this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1),
                Ku.setFromMatrixPosition(this.light.matrixWorld),
                Zu.setFromMatrixPosition(this.light.target.matrixWorld),
                Ju.subVectors(Zu, Ku),
                this.lightPlane.lookAt(Zu),
                void 0 !== this.color
                  ? (this.lightPlane.material.color.set(this.color),
                    this.targetLine.material.color.set(this.color))
                  : (this.lightPlane.material.color.copy(this.light.color),
                    this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(Zu),
                (this.targetLine.scale.z = Ju.length());
            }
          }),
          (e.DiscreteInterpolant = _h),
          (e.DisplayP3ColorSpace = Ht),
          (e.DodecahedronGeometry = rc),
          (e.DoubleSide = 2),
          (e.DstAlphaFactor = 206),
          (e.DstColorFactor = 208),
          (e.DynamicCopyUsage = 35050),
          (e.DynamicDrawUsage = 35048),
          (e.DynamicReadUsage = 35049),
          (e.EdgesGeometry = cc),
          (e.EllipseCurve = Pl),
          (e.EqualCompare = 514),
          (e.EqualDepth = 4),
          (e.EqualStencilFunc = 514),
          (e.EquirectangularReflectionMapping = E),
          (e.EquirectangularRefractionMapping = T),
          (e.Euler = Cn),
          (e.EventDispatcher = Qt),
          (e.ExtrudeGeometry = Fc),
          (e.FileLoader = Nh),
          (e.Float16BufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Uint16Array(t), e, n), (this.isFloat16BufferAttribute = !0);
            }
            getX(t) {
              let e = mi(this.array[t * this.itemSize]);
              return this.normalized && (e = ce(e, this.array)), e;
            }
            setX(t, e) {
              return (
                this.normalized && (e = he(e, this.array)),
                (this.array[t * this.itemSize] = fi(e)),
                this
              );
            }
            getY(t) {
              let e = mi(this.array[t * this.itemSize + 1]);
              return this.normalized && (e = ce(e, this.array)), e;
            }
            setY(t, e) {
              return (
                this.normalized && (e = he(e, this.array)),
                (this.array[t * this.itemSize + 1] = fi(e)),
                this
              );
            }
            getZ(t) {
              let e = mi(this.array[t * this.itemSize + 2]);
              return this.normalized && (e = ce(e, this.array)), e;
            }
            setZ(t, e) {
              return (
                this.normalized && (e = he(e, this.array)),
                (this.array[t * this.itemSize + 2] = fi(e)),
                this
              );
            }
            getW(t) {
              let e = mi(this.array[t * this.itemSize + 3]);
              return this.normalized && (e = ce(e, this.array)), e;
            }
            setW(t, e) {
              return (
                this.normalized && (e = he(e, this.array)),
                (this.array[t * this.itemSize + 3] = fi(e)),
                this
              );
            }
            setXY(t, e, n) {
              return (
                (t *= this.itemSize),
                this.normalized && ((e = he(e, this.array)), (n = he(n, this.array))),
                (this.array[t + 0] = fi(e)),
                (this.array[t + 1] = fi(n)),
                this
              );
            }
            setXYZ(t, e, n, i) {
              return (
                (t *= this.itemSize),
                this.normalized &&
                  ((e = he(e, this.array)), (n = he(n, this.array)), (i = he(i, this.array))),
                (this.array[t + 0] = fi(e)),
                (this.array[t + 1] = fi(n)),
                (this.array[t + 2] = fi(i)),
                this
              );
            }
            setXYZW(t, e, n, i, r) {
              return (
                (t *= this.itemSize),
                this.normalized &&
                  ((e = he(e, this.array)),
                  (n = he(n, this.array)),
                  (i = he(i, this.array)),
                  (r = he(r, this.array))),
                (this.array[t + 0] = fi(e)),
                (this.array[t + 1] = fi(n)),
                (this.array[t + 2] = fi(i)),
                (this.array[t + 3] = fi(r)),
                this
              );
            }
          }),
          (e.Float32BufferAttribute = Si),
          (e.Float64BufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Float64Array(t), e, n);
            }
          }),
          (e.FloatType = H),
          (e.Fog = $a),
          (e.FogExp2 = Qa),
          (e.FramebufferTexture = class extends De {
            constructor(t, e) {
              super({ width: t, height: e }),
                (this.isFramebufferTexture = !0),
                (this.magFilter = L),
                (this.minFilter = L),
                (this.generateMipmaps = !1),
                (this.needsUpdate = !0);
            }
          }),
          (e.FrontSide = 0),
          (e.Frustum = fr),
          (e.GLBufferAttribute = class {
            constructor(t, e, n, i, r) {
              (this.isGLBufferAttribute = !0),
                (this.name = ""),
                (this.buffer = t),
                (this.type = e),
                (this.itemSize = n),
                (this.elementSize = i),
                (this.count = r),
                (this.version = 0);
            }
            set needsUpdate(t) {
              !0 === t && this.version++;
            }
            setBuffer(t) {
              return (this.buffer = t), this;
            }
            setType(t, e) {
              return (this.type = t), (this.elementSize = e), this;
            }
            setItemSize(t) {
              return (this.itemSize = t), this;
            }
            setCount(t) {
              return (this.count = t), this;
            }
          }),
          (e.GLSL1 = "100"),
          (e.GLSL3 = Yt),
          (e.GreaterCompare = 516),
          (e.GreaterDepth = 6),
          (e.GreaterEqualCompare = 518),
          (e.GreaterEqualDepth = 5),
          (e.GreaterEqualStencilFunc = 518),
          (e.GreaterStencilFunc = 516),
          (e.GridHelper = class extends yl {
            constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
              (n = new oi(n)), (i = new oi(i));
              const r = e / 2,
                s = t / e,
                a = t / 2,
                o = [],
                l = [];
              for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
                o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                const e = t === r ? n : i;
                e.toArray(l, c),
                  (c += 3),
                  e.toArray(l, c),
                  (c += 3),
                  e.toArray(l, c),
                  (c += 3),
                  e.toArray(l, c),
                  (c += 3);
              }
              const c = new Li();
              c.setAttribute("position", new Si(o, 3)),
                c.setAttribute("color", new Si(l, 3)),
                super(c, new ul({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "GridHelper");
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.Group = Wa),
          (e.HalfFloatType = G),
          (e.HemisphereLight = Bh),
          (e.HemisphereLightHelper = class extends Wn {
            constructor(t, e, n) {
              super(),
                (this.light = t),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                (this.type = "HemisphereLightHelper");
              const i = new Gc(e);
              i.rotateY(0.5 * Math.PI),
                (this.material = new ui({ wireframe: !0, fog: !1, toneMapped: !1 })),
                void 0 === this.color && (this.material.vertexColors = !0);
              const r = i.getAttribute("position"),
                s = new Float32Array(3 * r.count);
              i.setAttribute("color", new xi(s, 3)),
                this.add(new Yi(i, this.material)),
                this.update();
            }
            dispose() {
              this.children[0].geometry.dispose(), this.children[0].material.dispose();
            }
            update() {
              const t = this.children[0];
              if (void 0 !== this.color) this.material.color.set(this.color);
              else {
                const e = t.geometry.getAttribute("color");
                qu.copy(this.light.color), Yu.copy(this.light.groundColor);
                for (let t = 0, n = e.count; t < n; t++) {
                  const i = t < n / 2 ? qu : Yu;
                  e.setXYZ(t, i.r, i.g, i.b);
                }
                e.needsUpdate = !0;
              }
              this.light.updateWorldMatrix(!0, !1),
                t.lookAt(ju.setFromMatrixPosition(this.light.matrixWorld).negate());
            }
          }),
          (e.IcosahedronGeometry = Hc),
          (e.ImageBitmapLoader = class extends Ph {
            constructor(t) {
              super(t),
                (this.isImageBitmapLoader = !0),
                "undefined" == typeof createImageBitmap &&
                  console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch &&
                  console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                (this.options = { premultiplyAlpha: "none" });
            }
            setOptions(t) {
              return (this.options = t), this;
            }
            load(t, e, n, i) {
              void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                (t = this.manager.resolveURL(t));
              const r = this,
                s = Rh.get(t);
              if (void 0 !== s)
                return (
                  r.manager.itemStart(t),
                  s.then
                    ? void s
                        .then((n) => {
                          e && e(n), r.manager.itemEnd(t);
                        })
                        .catch((t) => {
                          i && i(t);
                        })
                    : (setTimeout(function () {
                        e && e(s), r.manager.itemEnd(t);
                      }, 0),
                      s)
                );
              const a = {};
              (a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include"),
                (a.headers = this.requestHeader);
              const o = fetch(t, a)
                .then(function (t) {
                  return t.blob();
                })
                .then(function (t) {
                  return createImageBitmap(
                    t,
                    Object.assign(r.options, { colorSpaceConversion: "none" })
                  );
                })
                .then(function (n) {
                  return Rh.add(t, n), e && e(n), r.manager.itemEnd(t), n;
                })
                .catch(function (e) {
                  i && i(e), Rh.remove(t), r.manager.itemError(t), r.manager.itemEnd(t);
                });
              Rh.add(t, o), r.manager.itemStart(t);
            }
          }),
          (e.ImageLoader = Dh),
          (e.ImageUtils = Le),
          (e.IncrementStencilOp = 7682),
          (e.IncrementWrapStencilOp = 34055),
          (e.InstancedBufferAttribute = zo),
          (e.InstancedBufferGeometry = iu),
          (e.InstancedInterleavedBuffer = class extends eo {
            constructor(t, e, n = 1) {
              super(t, e), (this.isInstancedInterleavedBuffer = !0), (this.meshPerAttribute = n);
            }
            copy(t) {
              return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
            }
            clone(t) {
              const e = super.clone(t);
              return (e.meshPerAttribute = this.meshPerAttribute), e;
            }
            toJSON(t) {
              const e = super.toJSON(t);
              return (
                (e.isInstancedInterleavedBuffer = !0),
                (e.meshPerAttribute = this.meshPerAttribute),
                e
              );
            }
          }),
          (e.InstancedMesh = qo),
          (e.Int16BufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Int16Array(t), e, n);
            }
          }),
          (e.Int32BufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Int32Array(t), e, n);
            }
          }),
          (e.Int8BufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Int8Array(t), e, n);
            }
          }),
          (e.IntType = F),
          (e.InterleavedBuffer = eo),
          (e.InterleavedBufferAttribute = io),
          (e.Interpolant = fh),
          (e.InterpolateDiscrete = Rt),
          (e.InterpolateLinear = Ct),
          (e.InterpolateSmooth = Lt),
          (e.InvertStencilOp = 5386),
          (e.KeepStencilOp = jt),
          (e.KeyframeTrack = vh),
          (e.LOD = bo),
          (e.LatheGeometry = Ql),
          (e.Layers = Ln),
          (e.LessCompare = 513),
          (e.LessDepth = 2),
          (e.LessEqualCompare = 515),
          (e.LessEqualDepth = 3),
          (e.LessEqualStencilFunc = 515),
          (e.LessStencilFunc = 513),
          (e.Light = Oh),
          (e.LightProbe = tu),
          (e.Line = _l),
          (e.Line3 = class {
            constructor(t = new ke(), e = new ke()) {
              (this.start = t), (this.end = e);
            }
            set(t, e) {
              return this.start.copy(t), this.end.copy(e), this;
            }
            copy(t) {
              return this.start.copy(t.start), this.end.copy(t.end), this;
            }
            getCenter(t) {
              return t.addVectors(this.start, this.end).multiplyScalar(0.5);
            }
            delta(t) {
              return t.subVectors(this.end, this.start);
            }
            distanceSq() {
              return this.start.distanceToSquared(this.end);
            }
            distance() {
              return this.start.distanceTo(this.end);
            }
            at(t, e) {
              return this.delta(e).multiplyScalar(t).add(this.start);
            }
            closestPointToPointParameter(t, e) {
              zu.subVectors(t, this.start), Hu.subVectors(this.end, this.start);
              const n = Hu.dot(Hu);
              let i = Hu.dot(zu) / n;
              return e && (i = re(i, 0, 1)), i;
            }
            closestPointToPoint(t, e, n) {
              const i = this.closestPointToPointParameter(t, e);
              return this.delta(n).multiplyScalar(i).add(this.start);
            }
            applyMatrix4(t) {
              return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
            }
            equals(t) {
              return t.start.equals(this.start) && t.end.equals(this.end);
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }),
          (e.LineBasicMaterial = ul),
          (e.LineCurve = Wl),
          (e.LineCurve3 = Xl),
          (e.LineDashedMaterial = oh),
          (e.LineLoop = Ml),
          (e.LineSegments = yl),
          (e.LinearDisplayP3ColorSpace = Gt),
          (e.LinearEncoding = Dt),
          (e.LinearFilter = U),
          (e.LinearInterpolant = gh),
          (e.LinearMipMapLinearFilter = 1008),
          (e.LinearMipMapNearestFilter = 1007),
          (e.LinearMipmapLinearFilter = D),
          (e.LinearMipmapNearestFilter = N),
          (e.LinearSRGBColorSpace = zt),
          (e.LinearToneMapping = p),
          (e.LinearTransfer = kt),
          (e.Loader = Ph),
          (e.LoaderUtils = nu),
          (e.LoadingManager = Ch),
          (e.LoopOnce = 2200),
          (e.LoopPingPong = 2202),
          (e.LoopRepeat = 2201),
          (e.LuminanceAlphaFormat = 1025),
          (e.LuminanceFormat = 1024),
          (e.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }),
          (e.Material = hi),
          (e.MaterialLoader = eu),
          (e.MathUtils = ue),
          (e.Matrix3 = pe),
          (e.Matrix4 = xn),
          (e.MaxEquation = 104),
          (e.Mesh = Yi),
          (e.MeshBasicMaterial = ui),
          (e.MeshDepthMaterial = Ba),
          (e.MeshDistanceMaterial = Fa),
          (e.MeshLambertMaterial = sh),
          (e.MeshMatcapMaterial = ah),
          (e.MeshNormalMaterial = rh),
          (e.MeshPhongMaterial = nh),
          (e.MeshPhysicalMaterial = eh),
          (e.MeshStandardMaterial = th),
          (e.MeshToonMaterial = ih),
          (e.MinEquation = 103),
          (e.MirroredRepeatWrapping = C),
          (e.MixOperation = h),
          (e.MultiplyBlending = 4),
          (e.MultiplyOperation = c),
          (e.NearestFilter = L),
          (e.NearestMipMapLinearFilter = 1005),
          (e.NearestMipMapNearestFilter = 1004),
          (e.NearestMipmapLinearFilter = I),
          (e.NearestMipmapNearestFilter = P),
          (e.NeverCompare = 512),
          (e.NeverDepth = 0),
          (e.NeverStencilFunc = 512),
          (e.NoBlending = 0),
          (e.NoColorSpace = Bt),
          (e.NoToneMapping = d),
          (e.NormalAnimationBlendMode = 2500),
          (e.NormalBlending = 1),
          (e.NotEqualCompare = 517),
          (e.NotEqualDepth = 7),
          (e.NotEqualStencilFunc = 517),
          (e.NumberKeyframeTrack = Mh),
          (e.Object3D = Wn),
          (e.ObjectLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = "" === this.path ? nu.extractUrlBase(t) : this.path;
              this.resourcePath = this.resourcePath || s;
              const a = new Nh(this.manager);
              a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(
                  t,
                  function (n) {
                    let s = null;
                    try {
                      s = JSON.parse(n);
                    } catch (e) {
                      return (
                        void 0 !== i && i(e),
                        void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                      );
                    }
                    const a = s.metadata;
                    if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase())
                      return (
                        void 0 !== i && i(new Error("THREE.ObjectLoader: Can't load " + t)),
                        void console.error("THREE.ObjectLoader: Can't load " + t)
                      );
                    r.parse(s, e);
                  },
                  n,
                  i
                );
            }
            async loadAsync(t, e) {
              const n = "" === this.path ? nu.extractUrlBase(t) : this.path;
              this.resourcePath = this.resourcePath || n;
              const i = new Nh(this.manager);
              i.setPath(this.path),
                i.setRequestHeader(this.requestHeader),
                i.setWithCredentials(this.withCredentials);
              const r = await i.loadAsync(t, e),
                s = JSON.parse(r),
                a = s.metadata;
              if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase())
                throw new Error("THREE.ObjectLoader: Can't load " + t);
              return await this.parseAsync(s);
            }
            parse(t, e) {
              const n = this.parseAnimations(t.animations),
                i = this.parseShapes(t.shapes),
                r = this.parseGeometries(t.geometries, i),
                s = this.parseImages(t.images, function () {
                  void 0 !== e && e(l);
                }),
                a = this.parseTextures(t.textures, s),
                o = this.parseMaterials(t.materials, a),
                l = this.parseObject(t.object, r, o, a, n),
                c = this.parseSkeletons(t.skeletons, l);
              if ((this.bindSkeletons(l, c), void 0 !== e)) {
                let t = !1;
                for (const e in s)
                  if (s[e].data instanceof HTMLImageElement) {
                    t = !0;
                    break;
                  }
                !1 === t && e(l);
              }
              return l;
            }
            async parseAsync(t) {
              const e = this.parseAnimations(t.animations),
                n = this.parseShapes(t.shapes),
                i = this.parseGeometries(t.geometries, n),
                r = await this.parseImagesAsync(t.images),
                s = this.parseTextures(t.textures, r),
                a = this.parseMaterials(t.materials, s),
                o = this.parseObject(t.object, i, a, s, e),
                l = this.parseSkeletons(t.skeletons, o);
              return this.bindSkeletons(o, l), o;
            }
            parseShapes(t) {
              const e = {};
              if (void 0 !== t)
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = new hc().fromJSON(t[n]);
                  e[i.uuid] = i;
                }
              return e;
            }
            parseSkeletons(t, e) {
              const n = {},
                i = {};
              if (
                (e.traverse(function (t) {
                  t.isBone && (i[t.uuid] = t);
                }),
                void 0 !== t)
              )
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = new Fo().fromJSON(t[e], i);
                  n[r.uuid] = r;
                }
              return n;
            }
            parseGeometries(t, e) {
              const n = {};
              if (void 0 !== t) {
                const i = new ru();
                for (let r = 0, s = t.length; r < s; r++) {
                  let s;
                  const a = t[r];
                  switch (a.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                      s = i.parse(a);
                      break;
                    default:
                      a.type in Jc
                        ? (s = Jc[a.type].fromJSON(a, e))
                        : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`);
                  }
                  (s.uuid = a.uuid),
                    void 0 !== a.name && (s.name = a.name),
                    void 0 !== a.userData && (s.userData = a.userData),
                    (n[a.uuid] = s);
                }
              }
              return n;
            }
            parseMaterials(t, e) {
              const n = {},
                i = {};
              if (void 0 !== t) {
                const r = new eu();
                r.setTextures(e);
                for (let e = 0, s = t.length; e < s; e++) {
                  const s = t[e];
                  void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), (i[s.uuid] = n[s.uuid]);
                }
              }
              return i;
            }
            parseAnimations(t) {
              const e = {};
              if (void 0 !== t)
                for (let n = 0; n < t.length; n++) {
                  const i = t[n],
                    r = Ah.parse(i);
                  e[r.uuid] = r;
                }
              return e;
            }
            parseImages(t, e) {
              const n = this,
                i = {};
              let r;
              function s(t) {
                if ("string" == typeof t) {
                  const e = t;
                  return (function (t) {
                    return (
                      n.manager.itemStart(t),
                      r.load(
                        t,
                        function () {
                          n.manager.itemEnd(t);
                        },
                        void 0,
                        function () {
                          n.manager.itemError(t), n.manager.itemEnd(t);
                        }
                      )
                    );
                  })(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e);
                }
                return t.data
                  ? { data: _e(t.type, t.data), width: t.width, height: t.height }
                  : null;
              }
              if (void 0 !== t && t.length > 0) {
                const n = new Ch(e);
                (r = new Dh(n)), r.setCrossOrigin(this.crossOrigin);
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e],
                    r = n.url;
                  if (Array.isArray(r)) {
                    const t = [];
                    for (let e = 0, n = r.length; e < n; e++) {
                      const n = s(r[e]);
                      null !== n &&
                        (n instanceof HTMLImageElement
                          ? t.push(n)
                          : t.push(new Do(n.data, n.width, n.height)));
                    }
                    i[n.uuid] = new Ie(t);
                  } else {
                    const t = s(n.url);
                    i[n.uuid] = new Ie(t);
                  }
                }
              }
              return i;
            }
            async parseImagesAsync(t) {
              const e = this,
                n = {};
              let i;
              async function r(t) {
                if ("string" == typeof t) {
                  const n = t,
                    r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : e.resourcePath + n;
                  return await i.loadAsync(r);
                }
                return t.data
                  ? { data: _e(t.type, t.data), width: t.width, height: t.height }
                  : null;
              }
              if (void 0 !== t && t.length > 0) {
                (i = new Dh(this.manager)), i.setCrossOrigin(this.crossOrigin);
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e],
                    s = i.url;
                  if (Array.isArray(s)) {
                    const t = [];
                    for (let e = 0, n = s.length; e < n; e++) {
                      const n = s[e],
                        i = await r(n);
                      null !== i &&
                        (i instanceof HTMLImageElement
                          ? t.push(i)
                          : t.push(new Do(i.data, i.width, i.height)));
                    }
                    n[i.uuid] = new Ie(t);
                  } else {
                    const t = await r(i.url);
                    n[i.uuid] = new Ie(t);
                  }
                }
              }
              return n;
            }
            parseTextures(t, e) {
              function n(t, e) {
                return "number" == typeof t
                  ? t
                  : (console.warn(
                      "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                      t
                    ),
                    e[t]);
              }
              const i = {};
              if (void 0 !== t)
                for (let r = 0, s = t.length; r < s; r++) {
                  const s = t[r];
                  void 0 === s.image &&
                    console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                    void 0 === e[s.image] &&
                      console.warn("THREE.ObjectLoader: Undefined image", s.image);
                  const a = e[s.image],
                    o = a.data;
                  let l;
                  Array.isArray(o)
                    ? ((l = new ar()), 6 === o.length && (l.needsUpdate = !0))
                    : ((l = o && o.data ? new Do() : new De()), o && (l.needsUpdate = !0)),
                    (l.source = a),
                    (l.uuid = s.uuid),
                    void 0 !== s.name && (l.name = s.name),
                    void 0 !== s.mapping && (l.mapping = n(s.mapping, su)),
                    void 0 !== s.channel && (l.channel = s.channel),
                    void 0 !== s.offset && l.offset.fromArray(s.offset),
                    void 0 !== s.repeat && l.repeat.fromArray(s.repeat),
                    void 0 !== s.center && l.center.fromArray(s.center),
                    void 0 !== s.rotation && (l.rotation = s.rotation),
                    void 0 !== s.wrap &&
                      ((l.wrapS = n(s.wrap[0], au)), (l.wrapT = n(s.wrap[1], au))),
                    void 0 !== s.format && (l.format = s.format),
                    void 0 !== s.internalFormat && (l.internalFormat = s.internalFormat),
                    void 0 !== s.type && (l.type = s.type),
                    void 0 !== s.colorSpace && (l.colorSpace = s.colorSpace),
                    void 0 !== s.encoding && (l.encoding = s.encoding),
                    void 0 !== s.minFilter && (l.minFilter = n(s.minFilter, ou)),
                    void 0 !== s.magFilter && (l.magFilter = n(s.magFilter, ou)),
                    void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (l.flipY = s.flipY),
                    void 0 !== s.generateMipmaps && (l.generateMipmaps = s.generateMipmaps),
                    void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment),
                    void 0 !== s.compareFunction && (l.compareFunction = s.compareFunction),
                    void 0 !== s.userData && (l.userData = s.userData),
                    (i[s.uuid] = l);
                }
              return i;
            }
            parseObject(t, e, n, i, r) {
              let s, a, o;
              function l(t) {
                return (
                  void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                );
              }
              function c(t) {
                if (void 0 !== t) {
                  if (Array.isArray(t)) {
                    const e = [];
                    for (let i = 0, r = t.length; i < r; i++) {
                      const r = t[i];
                      void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r),
                        e.push(n[r]);
                    }
                    return e;
                  }
                  return (
                    void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
                    n[t]
                  );
                }
              }
              function h(t) {
                return (
                  void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), i[t]
                );
              }
              switch (t.type) {
                case "Scene":
                  (s = new to()),
                    void 0 !== t.background &&
                      (Number.isInteger(t.background)
                        ? (s.background = new oi(t.background))
                        : (s.background = h(t.background))),
                    void 0 !== t.environment && (s.environment = h(t.environment)),
                    void 0 !== t.fog &&
                      ("Fog" === t.fog.type
                        ? (s.fog = new $a(t.fog.color, t.fog.near, t.fog.far))
                        : "FogExp2" === t.fog.type && (s.fog = new Qa(t.fog.color, t.fog.density)),
                      "" !== t.fog.name && (s.fog.name = t.fog.name)),
                    void 0 !== t.backgroundBlurriness &&
                      (s.backgroundBlurriness = t.backgroundBlurriness),
                    void 0 !== t.backgroundIntensity &&
                      (s.backgroundIntensity = t.backgroundIntensity);
                  break;
                case "PerspectiveCamera":
                  (s = new ir(t.fov, t.aspect, t.near, t.far)),
                    void 0 !== t.focus && (s.focus = t.focus),
                    void 0 !== t.zoom && (s.zoom = t.zoom),
                    void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge),
                    void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset),
                    void 0 !== t.view && (s.view = Object.assign({}, t.view));
                  break;
                case "OrthographicCamera":
                  (s = new Rr(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                    void 0 !== t.zoom && (s.zoom = t.zoom),
                    void 0 !== t.view && (s.view = Object.assign({}, t.view));
                  break;
                case "AmbientLight":
                  s = new Jh(t.color, t.intensity);
                  break;
                case "DirectionalLight":
                  s = new Zh(t.color, t.intensity);
                  break;
                case "PointLight":
                  s = new Yh(t.color, t.intensity, t.distance, t.decay);
                  break;
                case "RectAreaLight":
                  s = new Qh(t.color, t.intensity, t.width, t.height);
                  break;
                case "SpotLight":
                  s = new Vh(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                  break;
                case "HemisphereLight":
                  s = new Bh(t.color, t.groundColor, t.intensity);
                  break;
                case "LightProbe":
                  s = new tu().fromJSON(t);
                  break;
                case "SkinnedMesh":
                  (a = l(t.geometry)),
                    (o = c(t.material)),
                    (s = new Uo(a, o)),
                    void 0 !== t.bindMode && (s.bindMode = t.bindMode),
                    void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix),
                    void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                  break;
                case "Mesh":
                  (a = l(t.geometry)), (o = c(t.material)), (s = new Yi(a, o));
                  break;
                case "InstancedMesh":
                  (a = l(t.geometry)), (o = c(t.material));
                  const e = t.count,
                    n = t.instanceMatrix,
                    i = t.instanceColor;
                  (s = new qo(a, o, e)),
                    (s.instanceMatrix = new zo(new Float32Array(n.array), 16)),
                    void 0 !== i &&
                      (s.instanceColor = new zo(new Float32Array(i.array), i.itemSize));
                  break;
                case "BatchedMesh":
                  (a = l(t.geometry)),
                    (o = c(t.material)),
                    (s = new hl(t.maxGeometryCount, t.maxVertexCount, t.maxIndexCount, o)),
                    (s.geometry = a),
                    (s.perObjectFrustumCulled = t.perObjectFrustumCulled),
                    (s.sortObjects = t.sortObjects),
                    (s._drawRanges = t.drawRanges),
                    (s._reservedRanges = t.reservedRanges),
                    (s._visibility = t.visibility),
                    (s._active = t.active),
                    (s._bounds = t.bounds.map((t) => {
                      const e = new Xe();
                      e.min.fromArray(t.boxMin), e.max.fromArray(t.boxMax);
                      const n = new hn();
                      return (
                        (n.radius = t.sphereRadius),
                        n.center.fromArray(t.sphereCenter),
                        {
                          boxInitialized: t.boxInitialized,
                          box: e,
                          sphereInitialized: t.sphereInitialized,
                          sphere: n,
                        }
                      );
                    })),
                    (s._maxGeometryCount = t.maxGeometryCount),
                    (s._maxVertexCount = t.maxVertexCount),
                    (s._maxIndexCount = t.maxIndexCount),
                    (s._geometryInitialized = t.geometryInitialized),
                    (s._geometryCount = t.geometryCount),
                    (s._matricesTexture = h(t.matricesTexture.uuid));
                  break;
                case "LOD":
                  s = new bo();
                  break;
                case "Line":
                  s = new _l(l(t.geometry), c(t.material));
                  break;
                case "LineLoop":
                  s = new Ml(l(t.geometry), c(t.material));
                  break;
                case "LineSegments":
                  s = new yl(l(t.geometry), c(t.material));
                  break;
                case "PointCloud":
                case "Points":
                  s = new wl(l(t.geometry), c(t.material));
                  break;
                case "Sprite":
                  s = new xo(c(t.material));
                  break;
                case "Group":
                  s = new Wa();
                  break;
                case "Bone":
                  s = new No();
                  break;
                default:
                  s = new Wn();
              }
              if (
                ((s.uuid = t.uuid),
                void 0 !== t.name && (s.name = t.name),
                void 0 !== t.matrix
                  ? (s.matrix.fromArray(t.matrix),
                    void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate),
                    s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale))
                  : (void 0 !== t.position && s.position.fromArray(t.position),
                    void 0 !== t.rotation && s.rotation.fromArray(t.rotation),
                    void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion),
                    void 0 !== t.scale && s.scale.fromArray(t.scale)),
                void 0 !== t.up && s.up.fromArray(t.up),
                void 0 !== t.castShadow && (s.castShadow = t.castShadow),
                void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow),
                t.shadow &&
                  (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias),
                  void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias),
                  void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius),
                  void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize),
                  void 0 !== t.shadow.camera &&
                    (s.shadow.camera = this.parseObject(t.shadow.camera))),
                void 0 !== t.visible && (s.visible = t.visible),
                void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled),
                void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder),
                void 0 !== t.userData && (s.userData = t.userData),
                void 0 !== t.layers && (s.layers.mask = t.layers),
                void 0 !== t.children)
              ) {
                const a = t.children;
                for (let t = 0; t < a.length; t++) s.add(this.parseObject(a[t], e, n, i, r));
              }
              if (void 0 !== t.animations) {
                const e = t.animations;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t];
                  s.animations.push(r[n]);
                }
              }
              if ("LOD" === t.type) {
                void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
                const e = t.levels;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t],
                    i = s.getObjectByProperty("uuid", n.object);
                  void 0 !== i && s.addLevel(i, n.distance, n.hysteresis);
                }
              }
              return s;
            }
            bindSkeletons(t, e) {
              0 !== Object.keys(e).length &&
                t.traverse(function (t) {
                  if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                    const n = e[t.skeleton];
                    void 0 === n
                      ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton)
                      : t.bind(n, t.bindMatrix);
                  }
                });
            }
          }),
          (e.ObjectSpaceNormalMap = 1),
          (e.OctahedronGeometry = Gc),
          (e.OneFactor = 201),
          (e.OneMinusConstantAlphaFactor = 214),
          (e.OneMinusConstantColorFactor = 212),
          (e.OneMinusDstAlphaFactor = 207),
          (e.OneMinusDstColorFactor = 209),
          (e.OneMinusSrcAlphaFactor = l),
          (e.OneMinusSrcColorFactor = 203),
          (e.OrthographicCamera = Rr),
          (e.P3Primaries = Xt),
          (e.PCFShadowMap = i),
          (e.PCFSoftShadowMap = r),
          (e.PMREMGenerator = Fr),
          (e.Path = Jl),
          (e.PerspectiveCamera = ir),
          (e.Plane = ur),
          (e.PlaneGeometry = _r),
          (e.PlaneHelper = class extends _l {
            constructor(t, e = 1, n = 16776960) {
              const i = n,
                r = new Li();
              r.setAttribute(
                "position",
                new Si(
                  [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
                  3
                )
              ),
                r.computeBoundingSphere(),
                super(r, new ul({ color: i, toneMapped: !1 })),
                (this.type = "PlaneHelper"),
                (this.plane = t),
                (this.size = e);
              const s = new Li();
              s.setAttribute(
                "position",
                new Si([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)
              ),
                s.computeBoundingSphere(),
                this.add(
                  new Yi(
                    s,
                    new ui({
                      color: i,
                      opacity: 0.2,
                      transparent: !0,
                      depthWrite: !1,
                      toneMapped: !1,
                    })
                  )
                );
            }
            updateMatrixWorld(t) {
              this.position.set(0, 0, 0),
                this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
                this.lookAt(this.plane.normal),
                this.translateZ(-this.plane.constant),
                super.updateMatrixWorld(t);
            }
            dispose() {
              this.geometry.dispose(),
                this.material.dispose(),
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose();
            }
          }),
          (e.PointLight = Yh),
          (e.PointLightHelper = class extends Yi {
            constructor(t, e, n) {
              super(new Wc(e, 4, 2), new ui({ wireframe: !0, fog: !1, toneMapped: !1 })),
                (this.light = t),
                (this.color = n),
                (this.type = "PointLightHelper"),
                (this.matrix = this.light.matrixWorld),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1),
                void 0 !== this.color
                  ? this.material.color.set(this.color)
                  : this.material.color.copy(this.light.color);
            }
          }),
          (e.Points = wl),
          (e.PointsMaterial = Sl),
          (e.PolarGridHelper = class extends yl {
            constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
              (r = new oi(r)), (s = new oi(s));
              const a = [],
                o = [];
              if (e > 1)
                for (let n = 0; n < e; n++) {
                  const i = (n / e) * (2 * Math.PI),
                    l = Math.sin(i) * t,
                    c = Math.cos(i) * t;
                  a.push(0, 0, 0), a.push(l, 0, c);
                  const h = 1 & n ? r : s;
                  o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b);
                }
              for (let e = 0; e < n; e++) {
                const l = 1 & e ? r : s,
                  c = t - (t / n) * e;
                for (let t = 0; t < i; t++) {
                  let e = (t / i) * (2 * Math.PI),
                    n = Math.sin(e) * c,
                    r = Math.cos(e) * c;
                  a.push(n, 0, r),
                    o.push(l.r, l.g, l.b),
                    (e = ((t + 1) / i) * (2 * Math.PI)),
                    (n = Math.sin(e) * c),
                    (r = Math.cos(e) * c),
                    a.push(n, 0, r),
                    o.push(l.r, l.g, l.b);
                }
              }
              const l = new Li();
              l.setAttribute("position", new Si(a, 3)),
                l.setAttribute("color", new Si(o, 3)),
                super(l, new ul({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "PolarGridHelper");
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.PolyhedronGeometry = ic),
          (e.PositionalAudio = class extends xu {
            constructor(t) {
              super(t),
                (this.panner = this.context.createPanner()),
                (this.panner.panningModel = "HRTF"),
                this.panner.connect(this.gain);
            }
            connect() {
              super.connect(), this.panner.connect(this.gain);
            }
            disconnect() {
              super.disconnect(), this.panner.disconnect(this.gain);
            }
            getOutput() {
              return this.panner;
            }
            getRefDistance() {
              return this.panner.refDistance;
            }
            setRefDistance(t) {
              return (this.panner.refDistance = t), this;
            }
            getRolloffFactor() {
              return this.panner.rolloffFactor;
            }
            setRolloffFactor(t) {
              return (this.panner.rolloffFactor = t), this;
            }
            getDistanceModel() {
              return this.panner.distanceModel;
            }
            setDistanceModel(t) {
              return (this.panner.distanceModel = t), this;
            }
            getMaxDistance() {
              return this.panner.maxDistance;
            }
            setMaxDistance(t) {
              return (this.panner.maxDistance = t), this;
            }
            setDirectionalCone(t, e, n) {
              return (
                (this.panner.coneInnerAngle = t),
                (this.panner.coneOuterAngle = e),
                (this.panner.coneOuterGain = n),
                this
              );
            }
            updateMatrixWorld(t) {
              if (
                (super.updateMatrixWorld(t),
                !0 === this.hasPlaybackControl && !1 === this.isPlaying)
              )
                return;
              this.matrixWorld.decompose(yu, Mu, Su), bu.set(0, 0, 1).applyQuaternion(Mu);
              const e = this.panner;
              if (e.positionX) {
                const t = this.context.currentTime + this.listener.timeDelta;
                e.positionX.linearRampToValueAtTime(yu.x, t),
                  e.positionY.linearRampToValueAtTime(yu.y, t),
                  e.positionZ.linearRampToValueAtTime(yu.z, t),
                  e.orientationX.linearRampToValueAtTime(bu.x, t),
                  e.orientationY.linearRampToValueAtTime(bu.y, t),
                  e.orientationZ.linearRampToValueAtTime(bu.z, t);
              } else e.setPosition(yu.x, yu.y, yu.z), e.setOrientation(bu.x, bu.y, bu.z);
            }
          }),
          (e.PropertyBinding = Pu),
          (e.PropertyMixer = Eu),
          (e.QuadraticBezierCurve = jl),
          (e.QuadraticBezierCurve3 = ql),
          (e.Quaternion = Ge),
          (e.QuaternionKeyframeTrack = bh),
          (e.QuaternionLinearInterpolant = Sh),
          (e.RED_GREEN_RGTC2_Format = At),
          (e.RED_RGTC1_Format = 36283),
          (e.REVISION = n),
          (e.RGBADepthPacking = 3201),
          (e.RGBAFormat = X),
          (e.RGBAIntegerFormat = Z),
          (e.RGBA_ASTC_10x10_Format = xt),
          (e.RGBA_ASTC_10x5_Format = gt),
          (e.RGBA_ASTC_10x6_Format = _t),
          (e.RGBA_ASTC_10x8_Format = vt),
          (e.RGBA_ASTC_12x10_Format = yt),
          (e.RGBA_ASTC_12x12_Format = Mt),
          (e.RGBA_ASTC_4x4_Format = lt),
          (e.RGBA_ASTC_5x4_Format = ct),
          (e.RGBA_ASTC_5x5_Format = ht),
          (e.RGBA_ASTC_6x5_Format = ut),
          (e.RGBA_ASTC_6x6_Format = dt),
          (e.RGBA_ASTC_8x5_Format = pt),
          (e.RGBA_ASTC_8x6_Format = ft),
          (e.RGBA_ASTC_8x8_Format = mt),
          (e.RGBA_BPTC_Format = St),
          (e.RGBA_ETC2_EAC_Format = ot),
          (e.RGBA_PVRTC_2BPPV1_Format = rt),
          (e.RGBA_PVRTC_4BPPV1_Format = it),
          (e.RGBA_S3TC_DXT1_Format = Q),
          (e.RGBA_S3TC_DXT3_Format = $),
          (e.RGBA_S3TC_DXT5_Format = tt),
          (e.RGB_BPTC_SIGNED_Format = bt),
          (e.RGB_BPTC_UNSIGNED_Format = Et),
          (e.RGB_ETC1_Format = st),
          (e.RGB_ETC2_Format = at),
          (e.RGB_PVRTC_2BPPV1_Format = nt),
          (e.RGB_PVRTC_4BPPV1_Format = et),
          (e.RGB_S3TC_DXT1_Format = J),
          (e.RGFormat = 1030),
          (e.RGIntegerFormat = K),
          (e.RawShaderMaterial = $c),
          (e.Ray = vn),
          (e.Raycaster = class {
            constructor(t, e, n = 0, i = 1 / 0) {
              (this.ray = new vn(t, e)),
                (this.near = n),
                (this.far = i),
                (this.camera = null),
                (this.layers = new Ln()),
                (this.params = {
                  Mesh: {},
                  Line: { threshold: 1 },
                  LOD: {},
                  Points: { threshold: 1 },
                  Sprite: {},
                });
            }
            set(t, e) {
              this.ray.set(t, e);
            }
            setFromCamera(t, e) {
              e.isPerspectiveCamera
                ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                  this.ray.direction
                    .set(t.x, t.y, 0.5)
                    .unproject(e)
                    .sub(this.ray.origin)
                    .normalize(),
                  (this.camera = e))
                : e.isOrthographicCamera
                ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                  this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                  (this.camera = e))
                : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
            }
            intersectObject(t, e = !0, n = []) {
              return Bu(t, this, n, e), n.sort(Ou), n;
            }
            intersectObjects(t, e = !0, n = []) {
              for (let i = 0, r = t.length; i < r; i++) Bu(t[i], this, n, e);
              return n.sort(Ou), n;
            }
          }),
          (e.Rec709Primaries = Wt),
          (e.RectAreaLight = Qh),
          (e.RedFormat = 1028),
          (e.RedIntegerFormat = Y),
          (e.ReinhardToneMapping = f),
          (e.RenderTarget = Be),
          (e.RepeatWrapping = w),
          (e.ReplaceStencilOp = 7681),
          (e.ReverseSubtractEquation = 102),
          (e.RingGeometry = kc),
          (e.SIGNED_RED_GREEN_RGTC2_Format = wt),
          (e.SIGNED_RED_RGTC1_Format = Tt),
          (e.SRGBColorSpace = Ft),
          (e.SRGBTransfer = Vt),
          (e.Scene = to),
          (e.ShaderChunk = vr),
          (e.ShaderLib = yr),
          (e.ShaderMaterial = er),
          (e.ShadowMaterial = Qc),
          (e.Shape = hc),
          (e.ShapeGeometry = Vc),
          (e.ShapePath = class {
            constructor() {
              (this.type = "ShapePath"),
                (this.color = new oi()),
                (this.subPaths = []),
                (this.currentPath = null);
            }
            moveTo(t, e) {
              return (
                (this.currentPath = new Jl()),
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(t, e),
                this
              );
            }
            lineTo(t, e) {
              return this.currentPath.lineTo(t, e), this;
            }
            quadraticCurveTo(t, e, n, i) {
              return this.currentPath.quadraticCurveTo(t, e, n, i), this;
            }
            bezierCurveTo(t, e, n, i, r, s) {
              return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this;
            }
            splineThru(t) {
              return this.currentPath.splineThru(t), this;
            }
            toShapes(t) {
              function e(t, e) {
                const n = e.length;
                let i = !1;
                for (let r = n - 1, s = 0; s < n; r = s++) {
                  let n = e[r],
                    a = e[s],
                    o = a.x - n.x,
                    l = a.y - n.y;
                  if (Math.abs(l) > Number.EPSILON) {
                    if (
                      (l < 0 && ((n = e[s]), (o = -o), (a = e[r]), (l = -l)),
                      t.y < n.y || t.y > a.y)
                    )
                      continue;
                    if (t.y === n.y) {
                      if (t.x === n.x) return !0;
                    } else {
                      const e = l * (t.x - n.x) - o * (t.y - n.y);
                      if (0 === e) return !0;
                      if (e < 0) continue;
                      i = !i;
                    }
                  } else {
                    if (t.y !== n.y) continue;
                    if ((a.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= a.x)) return !0;
                  }
                }
                return i;
              }
              const n = Dc.isClockWise,
                i = this.subPaths;
              if (0 === i.length) return [];
              let r, s, a;
              const o = [];
              if (1 === i.length)
                return (s = i[0]), (a = new hc()), (a.curves = s.curves), o.push(a), o;
              let l = !n(i[0].getPoints());
              l = t ? !l : l;
              const c = [],
                h = [];
              let u,
                d,
                p = [],
                f = 0;
              (h[f] = void 0), (p[f] = []);
              for (let e = 0, a = i.length; e < a; e++)
                (s = i[e]),
                  (u = s.getPoints()),
                  (r = n(u)),
                  (r = t ? !r : r),
                  r
                    ? (!l && h[f] && f++,
                      (h[f] = { s: new hc(), p: u }),
                      (h[f].s.curves = s.curves),
                      l && f++,
                      (p[f] = []))
                    : p[f].push({ h: s, p: u[0] });
              if (!h[0])
                return (function (t) {
                  const e = [];
                  for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n],
                      r = new hc();
                    (r.curves = i.curves), e.push(r);
                  }
                  return e;
                })(i);
              if (h.length > 1) {
                let t = !1,
                  n = 0;
                for (let t = 0, e = h.length; t < e; t++) c[t] = [];
                for (let i = 0, r = h.length; i < r; i++) {
                  const r = p[i];
                  for (let s = 0; s < r.length; s++) {
                    const a = r[s];
                    let o = !0;
                    for (let r = 0; r < h.length; r++)
                      e(a.p, h[r].p) && (i !== r && n++, o ? ((o = !1), c[r].push(a)) : (t = !0));
                    o && c[i].push(a);
                  }
                }
                n > 0 && !1 === t && (p = c);
              }
              for (let t = 0, e = h.length; t < e; t++) {
                (a = h[t].s), o.push(a), (d = p[t]);
                for (let t = 0, e = d.length; t < e; t++) a.holes.push(d[t].h);
              }
              return o;
            }
          }),
          (e.ShapeUtils = Dc),
          (e.ShortType = 1011),
          (e.Skeleton = Fo),
          (e.SkeletonHelper = class extends yl {
            constructor(t) {
              const e = Xu(t),
                n = new Li(),
                i = [],
                r = [],
                s = new oi(0, 0, 1),
                a = new oi(0, 1, 0);
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                n.parent &&
                  n.parent.isBone &&
                  (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
              }
              n.setAttribute("position", new Si(i, 3)),
                n.setAttribute("color", new Si(r, 3)),
                super(
                  n,
                  new ul({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0,
                  })
                ),
                (this.isSkeletonHelper = !0),
                (this.type = "SkeletonHelper"),
                (this.root = t),
                (this.bones = e),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1);
            }
            updateMatrixWorld(t) {
              const e = this.bones,
                n = this.geometry,
                i = n.getAttribute("position");
              Wu.copy(this.root.matrixWorld).invert();
              for (let t = 0, n = 0; t < e.length; t++) {
                const r = e[t];
                r.parent &&
                  r.parent.isBone &&
                  (Vu.multiplyMatrices(Wu, r.matrixWorld),
                  ku.setFromMatrixPosition(Vu),
                  i.setXYZ(n, ku.x, ku.y, ku.z),
                  Vu.multiplyMatrices(Wu, r.parent.matrixWorld),
                  ku.setFromMatrixPosition(Vu),
                  i.setXYZ(n + 1, ku.x, ku.y, ku.z),
                  (n += 2));
              }
              (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(t);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (e.SkinnedMesh = Uo),
          (e.Source = Ie),
          (e.Sphere = hn),
          (e.SphereGeometry = Wc),
          (e.Spherical = class {
            constructor(t = 1, e = 0, n = 0) {
              return (this.radius = t), (this.phi = e), (this.theta = n), this;
            }
            set(t, e, n) {
              return (this.radius = t), (this.phi = e), (this.theta = n), this;
            }
            copy(t) {
              return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this;
            }
            makeSafe() {
              const t = 1e-6;
              return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
            }
            setFromVector3(t) {
              return this.setFromCartesianCoords(t.x, t.y, t.z);
            }
            setFromCartesianCoords(t, e, n) {
              return (
                (this.radius = Math.sqrt(t * t + e * e + n * n)),
                0 === this.radius
                  ? ((this.theta = 0), (this.phi = 0))
                  : ((this.theta = Math.atan2(t, n)),
                    (this.phi = Math.acos(re(e / this.radius, -1, 1)))),
                this
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }),
          (e.SphericalHarmonics3 = $h),
          (e.SplineCurve = Yl),
          (e.SpotLight = Vh),
          (e.SpotLightHelper = class extends Wn {
            constructor(t, e) {
              super(),
                (this.light = t),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = e),
                (this.type = "SpotLightHelper");
              const n = new Li(),
                i = [
                  0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,
                  0, -1, 1,
                ];
              for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                const r = (t / n) * Math.PI * 2,
                  s = (e / n) * Math.PI * 2;
                i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1);
              }
              n.setAttribute("position", new Si(i, 3));
              const r = new ul({ fog: !1, toneMapped: !1 });
              (this.cone = new yl(n, r)), this.add(this.cone), this.update();
            }
            dispose() {
              this.cone.geometry.dispose(), this.cone.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
              const t = this.light.distance ? this.light.distance : 1e3,
                e = t * Math.tan(this.light.angle);
              this.cone.scale.set(e, e, t),
                Gu.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(Gu),
                void 0 !== this.color
                  ? this.cone.material.color.set(this.color)
                  : this.cone.material.color.copy(this.light.color);
            }
          }),
          (e.Sprite = xo),
          (e.SpriteMaterial = ro),
          (e.SrcAlphaFactor = o),
          (e.SrcAlphaSaturateFactor = 210),
          (e.SrcColorFactor = 202),
          (e.StaticCopyUsage = 35046),
          (e.StaticDrawUsage = qt),
          (e.StaticReadUsage = 35045),
          (e.StereoCamera = class {
            constructor() {
              (this.type = "StereoCamera"),
                (this.aspect = 1),
                (this.eyeSep = 0.064),
                (this.cameraL = new ir()),
                this.cameraL.layers.enable(1),
                (this.cameraL.matrixAutoUpdate = !1),
                (this.cameraR = new ir()),
                this.cameraR.layers.enable(2),
                (this.cameraR.matrixAutoUpdate = !1),
                (this._cache = {
                  focus: null,
                  fov: null,
                  aspect: null,
                  near: null,
                  far: null,
                  zoom: null,
                  eyeSep: null,
                });
            }
            update(t) {
              const e = this._cache;
              if (
                e.focus !== t.focus ||
                e.fov !== t.fov ||
                e.aspect !== t.aspect * this.aspect ||
                e.near !== t.near ||
                e.far !== t.far ||
                e.zoom !== t.zoom ||
                e.eyeSep !== this.eyeSep
              ) {
                (e.focus = t.focus),
                  (e.fov = t.fov),
                  (e.aspect = t.aspect * this.aspect),
                  (e.near = t.near),
                  (e.far = t.far),
                  (e.zoom = t.zoom),
                  (e.eyeSep = this.eyeSep),
                  du.copy(t.projectionMatrix);
                const n = e.eyeSep / 2,
                  i = (n * e.near) / e.focus,
                  r = (e.near * Math.tan(ee * e.fov * 0.5)) / e.zoom;
                let s, a;
                (uu.elements[12] = -n),
                  (hu.elements[12] = n),
                  (s = -r * e.aspect + i),
                  (a = r * e.aspect + i),
                  (du.elements[0] = (2 * e.near) / (a - s)),
                  (du.elements[8] = (a + s) / (a - s)),
                  this.cameraL.projectionMatrix.copy(du),
                  (s = -r * e.aspect - i),
                  (a = r * e.aspect - i),
                  (du.elements[0] = (2 * e.near) / (a - s)),
                  (du.elements[8] = (a + s) / (a - s)),
                  this.cameraR.projectionMatrix.copy(du);
              }
              this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(uu),
                this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(hu);
            }
          }),
          (e.StreamCopyUsage = 35042),
          (e.StreamDrawUsage = 35040),
          (e.StreamReadUsage = 35041),
          (e.StringKeyframeTrack = Eh),
          (e.SubtractEquation = 101),
          (e.SubtractiveBlending = 3),
          (e.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }),
          (e.TangentSpaceNormalMap = 0),
          (e.TetrahedronGeometry = Xc),
          (e.Texture = De),
          (e.TextureLoader = class extends Ph {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = new De(),
                s = new Dh(this.manager);
              return (
                s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(
                  t,
                  function (t) {
                    (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
                  },
                  n,
                  i
                ),
                r
              );
            }
          }),
          (e.TorusGeometry = jc),
          (e.TorusKnotGeometry = qc),
          (e.Triangle = ni),
          (e.TriangleFanDrawMode = 2),
          (e.TriangleStripDrawMode = 1),
          (e.TrianglesDrawMode = 0),
          (e.TubeGeometry = Yc),
          (e.TwoPassDoubleSide = 2),
          (e.UVMapping = M),
          (e.Uint16BufferAttribute = yi),
          (e.Uint32BufferAttribute = Mi),
          (e.Uint8BufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Uint8Array(t), e, n);
            }
          }),
          (e.Uint8ClampedBufferAttribute = class extends xi {
            constructor(t, e, n) {
              super(new Uint8ClampedArray(t), e, n);
            }
          }),
          (e.Uniform = Nu),
          (e.UniformsGroup = class extends Qt {
            constructor() {
              super(),
                (this.isUniformsGroup = !0),
                Object.defineProperty(this, "id", { value: Du++ }),
                (this.name = ""),
                (this.usage = qt),
                (this.uniforms = []);
            }
            add(t) {
              return this.uniforms.push(t), this;
            }
            remove(t) {
              const e = this.uniforms.indexOf(t);
              return -1 !== e && this.uniforms.splice(e, 1), this;
            }
            setName(t) {
              return (this.name = t), this;
            }
            setUsage(t) {
              return (this.usage = t), this;
            }
            dispose() {
              return this.dispatchEvent({ type: "dispose" }), this;
            }
            copy(t) {
              (this.name = t.name), (this.usage = t.usage);
              const e = t.uniforms;
              this.uniforms.length = 0;
              for (let t = 0, n = e.length; t < n; t++) {
                const n = Array.isArray(e[t]) ? e[t] : [e[t]];
                for (let t = 0; t < n.length; t++) this.uniforms.push(n[t].clone());
              }
              return this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }),
          (e.UniformsLib = xr),
          (e.UniformsUtils = tr),
          (e.UnsignedByteType = O),
          (e.UnsignedInt248Type = W),
          (e.UnsignedIntType = z),
          (e.UnsignedShort4444Type = k),
          (e.UnsignedShort5551Type = V),
          (e.UnsignedShortType = B),
          (e.VSMShadowMap = s),
          (e.Vector2 = de),
          (e.Vector3 = ke),
          (e.Vector4 = Oe),
          (e.VectorKeyframeTrack = Th),
          (e.VideoTexture = class extends De {
            constructor(t, e, n, i, r, s, a, o, l) {
              super(t, e, n, i, r, s, a, o, l),
                (this.isVideoTexture = !0),
                (this.minFilter = void 0 !== s ? s : U),
                (this.magFilter = void 0 !== r ? r : U),
                (this.generateMipmaps = !1);
              const c = this;
              "requestVideoFrameCallback" in t &&
                t.requestVideoFrameCallback(function e() {
                  (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
                });
            }
            clone() {
              return new this.constructor(this.image).copy(this);
            }
            update() {
              const t = this.image;
              !1 == "requestVideoFrameCallback" in t &&
                t.readyState >= t.HAVE_CURRENT_DATA &&
                (this.needsUpdate = !0);
            }
          }),
          (e.WebGL1Renderer = Ja),
          (e.WebGL3DRenderTarget = class extends Fe {
            constructor(t = 1, e = 1, n = 1, i = {}) {
              super(t, e, i),
                (this.isWebGL3DRenderTarget = !0),
                (this.depth = n),
                (this.texture = new He(null, t, e, n)),
                (this.texture.isRenderTargetTexture = !0);
            }
          }),
          (e.WebGLArrayRenderTarget = class extends Fe {
            constructor(t = 1, e = 1, n = 1, i = {}) {
              super(t, e, i),
                (this.isWebGLArrayRenderTarget = !0),
                (this.depth = n),
                (this.texture = new ze(null, t, e, n)),
                (this.texture.isRenderTargetTexture = !0);
            }
          }),
          (e.WebGLCoordinateSystem = Zt),
          (e.WebGLCubeRenderTarget = or),
          (e.WebGLMultipleRenderTargets = class extends Fe {
            constructor(t = 1, e = 1, n = 1, i = {}) {
              super(t, e, i), (this.isWebGLMultipleRenderTargets = !0);
              const r = this.texture;
              this.texture = [];
              for (let t = 0; t < n; t++)
                (this.texture[t] = r.clone()), (this.texture[t].isRenderTargetTexture = !0);
            }
            setSize(t, e, n = 1) {
              if (this.width !== t || this.height !== e || this.depth !== n) {
                (this.width = t), (this.height = e), (this.depth = n);
                for (let i = 0, r = this.texture.length; i < r; i++)
                  (this.texture[i].image.width = t),
                    (this.texture[i].image.height = e),
                    (this.texture[i].image.depth = n);
                this.dispose();
              }
              this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
            }
            copy(t) {
              this.dispose(),
                (this.width = t.width),
                (this.height = t.height),
                (this.depth = t.depth),
                this.scissor.copy(t.scissor),
                (this.scissorTest = t.scissorTest),
                this.viewport.copy(t.viewport),
                (this.depthBuffer = t.depthBuffer),
                (this.stencilBuffer = t.stencilBuffer),
                null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
                (this.texture.length = 0);
              for (let e = 0, n = t.texture.length; e < n; e++)
                (this.texture[e] = t.texture[e].clone()),
                  (this.texture[e].isRenderTargetTexture = !0);
              return this;
            }
          }),
          (e.WebGLRenderTarget = Fe),
          (e.WebGLRenderer = Za),
          (e.WebGLUtils = ka),
          (e.WebGPUCoordinateSystem = Jt),
          (e.WireframeGeometry = Kc),
          (e.WrapAroundEnding = Ut),
          (e.ZeroCurvatureEnding = Pt),
          (e.ZeroFactor = 200),
          (e.ZeroSlopeEnding = It),
          (e.ZeroStencilOp = 0),
          (e._SRGBAFormat = Kt),
          (e.createCanvasElement = xe),
          (e.sRGBEncoding = Ot);
      },
      477: (t, e, n) => {
        n.d(e, {
          AnimationClip: () => yo,
          AnimationMixer: () => il,
          Bone: () => ba,
          Box3: () => ce,
          BufferAttribute: () => In,
          BufferGeometry: () => Vn,
          ClampToEdgeWrapping: () => T,
          Color: () => Tn,
          ColorManagement: () => Wt,
          DirectionalLight: () => Wo,
          DoubleSide: () => l,
          FileLoader: () => Ro,
          FrontSide: () => o,
          Group: () => ia,
          ImageBitmapLoader: () => jo,
          InstancedBufferAttribute: () => Ra,
          InstancedMesh: () => Oa,
          InterleavedBuffer: () => ha,
          InterleavedBufferAttribute: () => da,
          Interpolant: () => oo,
          InterpolateDiscrete: () => q,
          InterpolateLinear: () => Y,
          Line: () => Va,
          LineBasicMaterial: () => Ba,
          LineLoop: () => qa,
          LineSegments: () => ja,
          LinearFilter: () => L,
          LinearMipmapLinearFilter: () => I,
          LinearMipmapNearestFilter: () => P,
          LinearSRGBColorSpace: () => st,
          Loader: () => To,
          LoaderUtils: () => Xo,
          Material: () => Rn,
          MathUtils: () => Pt,
          Matrix4: () => Oe,
          Mesh: () => oi,
          MeshBasicMaterial: () => Cn,
          MeshPhysicalMaterial: () => no,
          MeshStandardMaterial: () => eo,
          MirroredRepeatWrapping: () => A,
          NearestFilter: () => w,
          NearestMipmapLinearFilter: () => C,
          NearestMipmapNearestFilter: () => R,
          NumberKeyframeTrack: () => mo,
          Object3D: () => ln,
          OrthographicCamera: () => Gi,
          PerspectiveCamera: () => gi,
          PointLight: () => ko,
          Points: () => $a,
          PointsMaterial: () => Ya,
          PropertyBinding: () => tl,
          Quaternion: () => se,
          QuaternionKeyframeTrack: () => _o,
          RepeatWrapping: () => E,
          SRGBColorSpace: () => rt,
          Skeleton: () => wa,
          SkinnedMesh: () => Sa,
          Sphere: () => we,
          SpotLight: () => Bo,
          Texture: () => $t,
          TextureLoader: () => Lo,
          TriangleFanDrawMode: () => et,
          TriangleStripDrawMode: () => tt,
          TrianglesDrawMode: () => $,
          Vector2: () => It,
          Vector3: () => ae,
          VectorKeyframeTrack: () => xo,
        });
        const i = "160",
          r = 1,
          s = 2,
          a = 3,
          o = 0,
          l = 2,
          c = 100,
          h = 0,
          u = 1,
          d = 2,
          p = 0,
          f = 1,
          m = 2,
          g = 3,
          _ = 4,
          v = 5,
          x = 6,
          y = "attached",
          M = 301,
          S = 302,
          b = 306,
          E = 1e3,
          T = 1001,
          A = 1002,
          w = 1003,
          R = 1004,
          C = 1005,
          L = 1006,
          P = 1007,
          I = 1008,
          U = 1009,
          N = 1012,
          D = 1014,
          O = 1015,
          B = 1016,
          F = 1020,
          z = 1023,
          H = 1026,
          G = 1027,
          k = 33776,
          V = 33777,
          W = 33778,
          X = 33779,
          j = 36492,
          q = 2300,
          Y = 2301,
          K = 2302,
          Z = 2400,
          J = 2401,
          Q = 2402,
          $ = 0,
          tt = 1,
          et = 2,
          nt = 3001,
          it = "",
          rt = "srgb",
          st = "srgb-linear",
          at = "display-p3",
          ot = "display-p3-linear",
          lt = "linear",
          ct = "srgb",
          ht = "rec709",
          ut = "p3",
          dt = 7680,
          pt = 35044,
          ft = "300 es",
          mt = 1035,
          gt = 2e3,
          _t = 2001;
        class vt {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
              t.target = null;
            }
          }
        }
        const xt = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ];
        let yt = 1234567;
        const Mt = Math.PI / 180,
          St = 180 / Math.PI;
        function bt() {
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0;
          return (
            xt[255 & t] +
            xt[(t >> 8) & 255] +
            xt[(t >> 16) & 255] +
            xt[(t >> 24) & 255] +
            "-" +
            xt[255 & e] +
            xt[(e >> 8) & 255] +
            "-" +
            xt[((e >> 16) & 15) | 64] +
            xt[(e >> 24) & 255] +
            "-" +
            xt[(63 & n) | 128] +
            xt[(n >> 8) & 255] +
            "-" +
            xt[(n >> 16) & 255] +
            xt[(n >> 24) & 255] +
            xt[255 & i] +
            xt[(i >> 8) & 255] +
            xt[(i >> 16) & 255] +
            xt[(i >> 24) & 255]
          ).toLowerCase();
        }
        function Et(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function Tt(t, e) {
          return ((t % e) + e) % e;
        }
        function At(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function wt(t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        }
        function Rt(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        function Ct(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return t / 4294967295;
            case Uint16Array:
              return t / 65535;
            case Uint8Array:
              return t / 255;
            case Int32Array:
              return Math.max(t / 2147483647, -1);
            case Int16Array:
              return Math.max(t / 32767, -1);
            case Int8Array:
              return Math.max(t / 127, -1);
            default:
              throw new Error("Invalid component type.");
          }
        }
        function Lt(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return Math.round(4294967295 * t);
            case Uint16Array:
              return Math.round(65535 * t);
            case Uint8Array:
              return Math.round(255 * t);
            case Int32Array:
              return Math.round(2147483647 * t);
            case Int16Array:
              return Math.round(32767 * t);
            case Int8Array:
              return Math.round(127 * t);
            default:
              throw new Error("Invalid component type.");
          }
        }
        const Pt = {
          DEG2RAD: Mt,
          RAD2DEG: St,
          generateUUID: bt,
          clamp: Et,
          euclideanModulo: Tt,
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e);
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0;
          },
          lerp: At,
          damp: function (t, e, n, i) {
            return At(t, e, 1 - Math.exp(-n * i));
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(Tt(t, 2 * e) - e);
          },
          smoothstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          seededRandom: function (t) {
            void 0 !== t && (yt = t);
            let e = (yt += 1831565813);
            return (
              (e = Math.imul(e ^ (e >>> 15), 1 | e)),
              (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
              ((e ^ (e >>> 14)) >>> 0) / 4294967296
            );
          },
          degToRad: function (t) {
            return t * Mt;
          },
          radToDeg: function (t) {
            return t * St;
          },
          isPowerOfTwo: wt,
          ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
          },
          floorPowerOfTwo: Rt,
          setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const s = Math.cos,
              a = Math.sin,
              o = s(n / 2),
              l = a(n / 2),
              c = s((e + i) / 2),
              h = a((e + i) / 2),
              u = s((e - i) / 2),
              d = a((e - i) / 2),
              p = s((i - e) / 2),
              f = a((i - e) / 2);
            switch (r) {
              case "XYX":
                t.set(o * h, l * u, l * d, o * c);
                break;
              case "YZY":
                t.set(l * d, o * h, l * u, o * c);
                break;
              case "ZXZ":
                t.set(l * u, l * d, o * h, o * c);
                break;
              case "XZX":
                t.set(o * h, l * f, l * p, o * c);
                break;
              case "YXY":
                t.set(l * p, o * h, l * f, o * c);
                break;
              case "ZYZ":
                t.set(l * f, l * p, o * h, o * c);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    r
                );
            }
          },
          normalize: Lt,
          denormalize: Ct,
        };
        class It {
          constructor(t = 0, e = 0) {
            (It.prototype.isVector2 = !0), (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6]), (this.y = i[1] * e + i[4] * n + i[7]), this
            );
          }
          min(t) {
            return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
          }
          max(t) {
            return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
          }
          floor() {
            return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
          }
          ceil() {
            return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
          }
          round() {
            return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
          }
          roundToZero() {
            return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(Et(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
          }
          lerpVectors(t, e, n) {
            return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this;
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e) {
            return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              s = this.y - t.y;
            return (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this;
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y;
          }
        }
        class Ut {
          constructor(t, e, n, i, r, s, a, o, l) {
            (Ut.prototype.isMatrix3 = !0),
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              void 0 !== t && this.set(t, e, n, i, r, s, a, o, l);
          }
          set(t, e, n, i, r, s, a, o, l) {
            const c = this.elements;
            return (
              (c[0] = t),
              (c[1] = i),
              (c[2] = a),
              (c[3] = e),
              (c[4] = r),
              (c[5] = o),
              (c[6] = n),
              (c[7] = s),
              (c[8] = l),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              a = n[3],
              o = n[6],
              l = n[1],
              c = n[4],
              h = n[7],
              u = n[2],
              d = n[5],
              p = n[8],
              f = i[0],
              m = i[3],
              g = i[6],
              _ = i[1],
              v = i[4],
              x = i[7],
              y = i[2],
              M = i[5],
              S = i[8];
            return (
              (r[0] = s * f + a * _ + o * y),
              (r[3] = s * m + a * v + o * M),
              (r[6] = s * g + a * x + o * S),
              (r[1] = l * f + c * _ + h * y),
              (r[4] = l * m + c * v + h * M),
              (r[7] = l * g + c * x + h * S),
              (r[2] = u * f + d * _ + p * y),
              (r[5] = u * m + d * v + p * M),
              (r[8] = u * g + d * x + p * S),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8];
            return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o;
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8],
              h = c * s - a * l,
              u = a * o - c * r,
              d = l * r - s * o,
              p = e * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return (
              (t[0] = h * f),
              (t[1] = (i * l - c * n) * f),
              (t[2] = (a * n - i * s) * f),
              (t[3] = u * f),
              (t[4] = (c * e - i * o) * f),
              (t[5] = (i * r - a * e) * f),
              (t[6] = d * f),
              (t[7] = (n * o - l * e) * f),
              (t[8] = (s * e - n * r) * f),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, i, r, s, a) {
            const o = Math.cos(r),
              l = Math.sin(r);
            return (
              this.set(
                n * o,
                n * l,
                -n * (o * s + l * a) + s + t,
                -i * l,
                i * o,
                -i * (-l * s + o * a) + a + e,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(t, e) {
            return this.premultiply(Nt.makeScale(t, e)), this;
          }
          rotate(t) {
            return this.premultiply(Nt.makeRotation(-t)), this;
          }
          translate(t, e) {
            return this.premultiply(Nt.makeTranslation(t, e)), this;
          }
          makeTranslation(t, e) {
            return (
              t.isVector2
                ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
                : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
              this
            );
          }
          makeRotation(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
          }
          makeScale(t, e) {
            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        const Nt = new Ut();
        function Dt(t) {
          for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
          return !1;
        }
        function Ot(t) {
          return document.createElementNS("http://www.w3.org/1999/xhtml", t);
        }
        function Bt() {
          const t = Ot("canvas");
          return (t.style.display = "block"), t;
        }
        Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array;
        const Ft = {};
        function zt(t) {
          t in Ft || ((Ft[t] = !0), console.warn(t));
        }
        const Ht = new Ut().set(
            0.8224621,
            0.177538,
            0,
            0.0331941,
            0.9668058,
            0,
            0.0170827,
            0.0723974,
            0.9105199
          ),
          Gt = new Ut().set(
            1.2249401,
            -0.2249404,
            0,
            -0.0420569,
            1.0420571,
            0,
            -0.0196376,
            -0.0786361,
            1.0982735
          ),
          kt = {
            [st]: { transfer: lt, primaries: ht, toReference: (t) => t, fromReference: (t) => t },
            [rt]: {
              transfer: ct,
              primaries: ht,
              toReference: (t) => t.convertSRGBToLinear(),
              fromReference: (t) => t.convertLinearToSRGB(),
            },
            [ot]: {
              transfer: lt,
              primaries: ut,
              toReference: (t) => t.applyMatrix3(Gt),
              fromReference: (t) => t.applyMatrix3(Ht),
            },
            [at]: {
              transfer: ct,
              primaries: ut,
              toReference: (t) => t.convertSRGBToLinear().applyMatrix3(Gt),
              fromReference: (t) => t.applyMatrix3(Ht).convertLinearToSRGB(),
            },
          },
          Vt = new Set([st, ot]),
          Wt = {
            enabled: !0,
            _workingColorSpace: st,
            get workingColorSpace() {
              return this._workingColorSpace;
            },
            set workingColorSpace(t) {
              if (!Vt.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
              this._workingColorSpace = t;
            },
            convert: function (t, e, n) {
              if (!1 === this.enabled || e === n || !e || !n) return t;
              const i = kt[e].toReference;
              return (0, kt[n].fromReference)(i(t));
            },
            fromWorkingColorSpace: function (t, e) {
              return this.convert(t, this._workingColorSpace, e);
            },
            toWorkingColorSpace: function (t, e) {
              return this.convert(t, e, this._workingColorSpace);
            },
            getPrimaries: function (t) {
              return kt[t].primaries;
            },
            getTransfer: function (t) {
              return t === it ? lt : kt[t].transfer;
            },
          };
        function Xt(t) {
          return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function jt(t) {
          return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        let qt;
        class Yt {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === qt && (qt = Ot("canvas")), (qt.width = t.width), (qt.height = t.height);
              const n = qt.getContext("2d");
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = qt);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  t
                ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
          static sRGBToLinear(t) {
            if (
              ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const e = Ot("canvas");
              (e.width = t.width), (e.height = t.height);
              const n = e.getContext("2d");
              n.drawImage(t, 0, 0, t.width, t.height);
              const i = n.getImageData(0, 0, t.width, t.height),
                r = i.data;
              for (let t = 0; t < r.length; t++) r[t] = 255 * Xt(r[t] / 255);
              return n.putImageData(i, 0, 0), e;
            }
            if (t.data) {
              const e = t.data.slice(0);
              for (let t = 0; t < e.length; t++)
                e instanceof Uint8Array || e instanceof Uint8ClampedArray
                  ? (e[t] = Math.floor(255 * Xt(e[t] / 255)))
                  : (e[t] = Xt(e[t]));
              return { data: e, width: t.width, height: t.height };
            }
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              t
            );
          }
        }
        let Kt = 0;
        class Zt {
          constructor(t = null) {
            (this.isSource = !0),
              Object.defineProperty(this, "id", { value: Kt++ }),
              (this.uuid = bt()),
              (this.data = t),
              (this.version = 0);
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
            const n = { uuid: this.uuid, url: "" },
              i = this.data;
            if (null !== i) {
              let t;
              if (Array.isArray(i)) {
                t = [];
                for (let e = 0, n = i.length; e < n; e++)
                  i[e].isDataTexture ? t.push(Jt(i[e].image)) : t.push(Jt(i[e]));
              } else t = Jt(i);
              n.url = t;
            }
            return e || (t.images[this.uuid] = n), n;
          }
        }
        function Jt(t) {
          return ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ? Yt.getDataURL(t)
            : t.data
            ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
            : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
        }
        let Qt = 0;
        class $t extends vt {
          constructor(
            t = $t.DEFAULT_IMAGE,
            e = $t.DEFAULT_MAPPING,
            n = T,
            i = T,
            r = L,
            s = I,
            a = 1023,
            o = 1009,
            l = $t.DEFAULT_ANISOTROPY,
            c = ""
          ) {
            super(),
              (this.isTexture = !0),
              Object.defineProperty(this, "id", { value: Qt++ }),
              (this.uuid = bt()),
              (this.name = ""),
              (this.source = new Zt(t)),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.channel = 0),
              (this.wrapS = n),
              (this.wrapT = i),
              (this.magFilter = r),
              (this.minFilter = s),
              (this.anisotropy = l),
              (this.format = a),
              (this.internalFormat = null),
              (this.type = o),
              (this.offset = new It(0, 0)),
              (this.repeat = new It(1, 1)),
              (this.center = new It(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new Ut()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              "string" == typeof c
                ? (this.colorSpace = c)
                : (zt("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                  (this.colorSpace = c === nt ? rt : it)),
              (this.userData = {}),
              (this.version = 0),
              (this.onUpdate = null),
              (this.isRenderTargetTexture = !1),
              (this.needsPMREMUpdate = !1);
          }
          get image() {
            return this.source.data;
          }
          set image(t = null) {
            this.source.data = t;
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.source = t.source),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.channel = t.channel),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.colorSpace = t.colorSpace),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              (this.needsUpdate = !0),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            const n = {
              metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(t).uuid,
              mapping: this.mapping,
              channel: this.channel,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              internalFormat: this.internalFormat,
              type: this.type,
              colorSpace: this.colorSpace,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              generateMipmaps: this.generateMipmaps,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            return (
              Object.keys(this.userData).length > 0 && (n.userData = this.userData),
              e || (t.textures[this.uuid] = n),
              n
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(t) {
            if (300 !== this.mapping) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case E:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case T:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case A:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case E:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case T:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case A:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && (this.version++, (this.source.needsUpdate = !0));
          }
          get encoding() {
            return (
              zt("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
              this.colorSpace === rt ? nt : 3e3
            );
          }
          set encoding(t) {
            zt("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
              (this.colorSpace = t === nt ? rt : it);
          }
        }
        ($t.DEFAULT_IMAGE = null), ($t.DEFAULT_MAPPING = 300), ($t.DEFAULT_ANISOTROPY = 1);
        class te {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (te.prototype.isVector4 = !0), (this.x = t), (this.y = e), (this.z = n), (this.w = i);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              s = t.elements;
            return (
              (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
              (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
              (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
              (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const s = 0.01,
              a = 0.1,
              o = t.elements,
              l = o[0],
              c = o[4],
              h = o[8],
              u = o[1],
              d = o[5],
              p = o[9],
              f = o[2],
              m = o[6],
              g = o[10];
            if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
              if (
                Math.abs(c + u) < a &&
                Math.abs(h + f) < a &&
                Math.abs(p + m) < a &&
                Math.abs(l + d + g - 3) < a
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (l + 1) / 2,
                o = (d + 1) / 2,
                _ = (g + 1) / 2,
                v = (c + u) / 4,
                x = (h + f) / 4,
                y = (p + m) / 4;
              return (
                t > o && t > _
                  ? t < s
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(t)), (i = v / n), (r = x / n))
                  : o > _
                  ? o < s
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(o)), (n = v / i), (r = y / i))
                  : _ < s
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(_)), (n = x / r), (i = y / r)),
                this.set(n, i, r, e),
                this
              );
            }
            let _ = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
            return (
              Math.abs(_) < 0.001 && (_ = 1),
              (this.x = (m - p) / _),
              (this.y = (h - f) / _),
              (this.z = (u - c) / _),
              (this.w = Math.acos((l + d + g - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)),
              (this.y = Math.trunc(this.y)),
              (this.z = Math.trunc(this.z)),
              (this.w = Math.trunc(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
          }
        }
        class ee extends vt {
          constructor(t = 1, e = 1, n = {}) {
            super(),
              (this.isRenderTarget = !0),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new te(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new te(0, 0, t, e));
            const i = { width: t, height: e, depth: 1 };
            void 0 !== n.encoding &&
              (zt(
                "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
              ),
              (n.colorSpace = n.encoding === nt ? rt : it)),
              (n = Object.assign(
                {
                  generateMipmaps: !1,
                  internalFormat: null,
                  minFilter: L,
                  depthBuffer: !0,
                  stencilBuffer: !1,
                  depthTexture: null,
                  samples: 0,
                },
                n
              )),
              (this.texture = new $t(
                i,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.colorSpace
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.flipY = !1),
              (this.texture.generateMipmaps = n.generateMipmaps),
              (this.texture.internalFormat = n.internalFormat),
              (this.depthBuffer = n.depthBuffer),
              (this.stencilBuffer = n.stencilBuffer),
              (this.depthTexture = n.depthTexture),
              (this.samples = n.samples);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.scissor.copy(t.scissor),
              (this.scissorTest = t.scissorTest),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.texture.isRenderTargetTexture = !0);
            const e = Object.assign({}, t.texture.image);
            return (
              (this.texture.source = new Zt(e)),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
              (this.samples = t.samples),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        class ne extends ee {
          constructor(t = 1, e = 1, n = {}) {
            super(t, e, n), (this.isWebGLRenderTarget = !0);
          }
        }
        class ie extends $t {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.isDataArrayTexture = !0),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = w),
              (this.minFilter = w),
              (this.wrapR = T),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        class re extends $t {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.isData3DTexture = !0),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = w),
              (this.minFilter = w),
              (this.wrapR = T),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        class se {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this.isQuaternion = !0), (this._x = t), (this._y = e), (this._z = n), (this._w = i);
          }
          static slerpFlat(t, e, n, i, r, s, a) {
            let o = n[i + 0],
              l = n[i + 1],
              c = n[i + 2],
              h = n[i + 3];
            const u = r[s + 0],
              d = r[s + 1],
              p = r[s + 2],
              f = r[s + 3];
            if (0 === a) return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h);
            if (1 === a) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f);
            if (h !== f || o !== u || l !== d || c !== p) {
              let t = 1 - a;
              const e = o * u + l * d + c * p + h * f,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e;
              if (i > Number.EPSILON) {
                const r = Math.sqrt(i),
                  s = Math.atan2(r, e * n);
                (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
              }
              const r = a * n;
              if (
                ((o = o * t + u * r),
                (l = l * t + d * r),
                (c = c * t + p * r),
                (h = h * t + f * r),
                t === 1 - a)
              ) {
                const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                (o *= t), (l *= t), (c *= t), (h *= t);
              }
            }
            (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
          }
          static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const a = n[i],
              o = n[i + 1],
              l = n[i + 2],
              c = n[i + 3],
              h = r[s],
              u = r[s + 1],
              d = r[s + 2],
              p = r[s + 3];
            return (
              (t[e] = a * p + c * h + o * d - l * u),
              (t[e + 1] = o * p + c * u + l * h - a * d),
              (t[e + 2] = l * p + c * d + a * u - o * h),
              (t[e + 3] = c * p - a * h - o * u - l * d),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e = !0) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._order,
              a = Math.cos,
              o = Math.sin,
              l = a(n / 2),
              c = a(i / 2),
              h = a(r / 2),
              u = o(n / 2),
              d = o(i / 2),
              p = o(r / 2);
            switch (s) {
              case "XYZ":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "YXZ":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              case "ZXY":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "ZYX":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              case "YZX":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "XZY":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
                );
            }
            return !0 === e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              i = Math.sin(n);
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              i = e[4],
              r = e[8],
              s = e[1],
              a = e[5],
              o = e[9],
              l = e[2],
              c = e[6],
              h = e[10],
              u = n + a + h;
            if (u > 0) {
              const t = 0.5 / Math.sqrt(u + 1);
              (this._w = 0.25 / t),
                (this._x = (c - o) * t),
                (this._y = (r - l) * t),
                (this._z = (s - i) * t);
            } else if (n > a && n > h) {
              const t = 2 * Math.sqrt(1 + n - a - h);
              (this._w = (c - o) / t),
                (this._x = 0.25 * t),
                (this._y = (i + s) / t),
                (this._z = (r + l) / t);
            } else if (a > h) {
              const t = 2 * Math.sqrt(1 + a - n - h);
              (this._w = (r - l) / t),
                (this._x = (i + s) / t),
                (this._y = 0.25 * t),
                (this._z = (o + c) / t);
            } else {
              const t = 2 * Math.sqrt(1 + h - n - a);
              (this._w = (s - i) / t),
                (this._x = (r + l) / t),
                (this._y = (o + c) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
                    : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(Et(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this
            );
          }
          dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
          }
          lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
          }
          length() {
            return Math.sqrt(
              this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t) {
            return this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._w,
              a = e._x,
              o = e._y,
              l = e._z,
              c = e._w;
            return (
              (this._x = n * c + s * a + i * l - r * o),
              (this._y = i * c + s * o + r * a - n * l),
              (this._z = r * c + s * l + n * o - i * a),
              (this._w = s * c - n * a - i * o - r * l),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              i = this._y,
              r = this._z,
              s = this._w;
            let a = s * t._w + n * t._x + i * t._y + r * t._z;
            if (
              (a < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (a = -a))
                : this.copy(t),
              a >= 1)
            )
              return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * s + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * i + e * this._y),
                (this._z = t * r + e * this._z),
                this.normalize(),
                this
              );
            }
            const l = Math.sqrt(o),
              c = Math.atan2(l, a),
              h = Math.sin((1 - e) * c) / l,
              u = Math.sin(e * c) / l;
            return (
              (this._w = s * h + this._w * u),
              (this._x = n * h + this._x * u),
              (this._y = i * h + this._y * u),
              (this._z = r * h + this._z * u),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            return this.copy(t).slerp(e, n);
          }
          random() {
            const t = Math.random(),
              e = Math.sqrt(1 - t),
              n = Math.sqrt(t),
              i = 2 * Math.PI * Math.random(),
              r = 2 * Math.PI * Math.random();
            return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i));
          }
          equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this._onChangeCallback(),
              this
            );
          }
          toJSON() {
            return this.toArray();
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
          }
        }
        class ae {
          constructor(t = 0, e = 0, n = 0) {
            (ae.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
          }
          set(t, e, n) {
            return void 0 === n && (n = this.z), (this.x = t), (this.y = e), (this.z = n), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
          }
          applyEuler(t) {
            return this.applyQuaternion(le.setFromEuler(t));
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(le.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              a = t.z,
              o = t.w,
              l = 2 * (s * i - a * n),
              c = 2 * (a * e - r * i),
              h = 2 * (r * n - s * e);
            return (
              (this.x = e + o * l + s * h - a * c),
              (this.y = n + o * c + a * l - r * h),
              (this.z = i + o * h + r * c - s * l),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)),
              (this.y = Math.trunc(this.y)),
              (this.z = Math.trunc(this.z)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t) {
            return this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = e.x,
              a = e.y,
              o = e.z;
            return (
              (this.x = i * o - r * a), (this.y = r * s - n * o), (this.z = n * a - i * s), this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return oe.copy(this).projectOnVector(t), this.sub(oe);
          }
          reflect(t) {
            return this.sub(oe.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(Et(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z;
            return e * e + n * n + i * i;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return (
              (this.x = i * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = i * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this;
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = i), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          setFromEuler(t) {
            return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
          }
          setFromColor(t) {
            return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e) {
            return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this;
          }
          random() {
            return (
              (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this
            );
          }
          randomDirection() {
            const t = 2 * (Math.random() - 0.5),
              e = Math.random() * Math.PI * 2,
              n = Math.sqrt(1 - t ** 2);
            return (this.x = n * Math.cos(e)), (this.y = n * Math.sin(e)), (this.z = t), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
          }
        }
        const oe = new ae(),
          le = new se();
        class ce {
          constructor(t = new ae(1 / 0, 1 / 0, 1 / 0), e = new ae(-1 / 0, -1 / 0, -1 / 0)) {
            (this.isBox3 = !0), (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(ue.fromArray(t, e));
            return this;
          }
          setFromBufferAttribute(t) {
            this.makeEmpty();
            for (let e = 0, n = t.count; e < n; e++)
              this.expandByPoint(ue.fromBufferAttribute(t, e));
            return this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = ue.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t, e = !1) {
            return this.makeEmpty(), this.expandByObject(t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
          }
          getCenter(t) {
            return this.isEmpty()
              ? t.set(0, 0, 0)
              : t.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t, e = !1) {
            t.updateWorldMatrix(!1, !1);
            const n = t.geometry;
            if (void 0 !== n) {
              const i = n.getAttribute("position");
              if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
                for (let e = 0, n = i.count; e < n; e++)
                  !0 === t.isMesh ? t.getVertexPosition(e, ue) : ue.fromBufferAttribute(i, e),
                    ue.applyMatrix4(t.matrixWorld),
                    this.expandByPoint(ue);
              else
                void 0 !== t.boundingBox
                  ? (null === t.boundingBox && t.computeBoundingBox(), de.copy(t.boundingBox))
                  : (null === n.boundingBox && n.computeBoundingBox(), de.copy(n.boundingBox)),
                  de.applyMatrix4(t.matrixWorld),
                  this.union(de);
            }
            const i = t.children;
            for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return e.set(
              (t.x - this.min.x) / (this.max.x - this.min.x),
              (t.y - this.min.y) / (this.max.y - this.min.y),
              (t.z - this.min.z) / (this.max.z - this.min.z)
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, ue), ue.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(xe),
              ye.subVectors(this.max, xe),
              pe.subVectors(t.a, xe),
              fe.subVectors(t.b, xe),
              me.subVectors(t.c, xe),
              ge.subVectors(fe, pe),
              _e.subVectors(me, fe),
              ve.subVectors(pe, me);
            let e = [
              0,
              -ge.z,
              ge.y,
              0,
              -_e.z,
              _e.y,
              0,
              -ve.z,
              ve.y,
              ge.z,
              0,
              -ge.x,
              _e.z,
              0,
              -_e.x,
              ve.z,
              0,
              -ve.x,
              -ge.y,
              ge.x,
              0,
              -_e.y,
              _e.x,
              0,
              -ve.y,
              ve.x,
              0,
            ];
            return (
              !!be(e, pe, fe, me, ye) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!be(e, pe, fe, me, ye) &&
                (Me.crossVectors(ge, _e), (e = [Me.x, Me.y, Me.z]), be(e, pe, fe, me, ye)))
            );
          }
          clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max);
          }
          distanceToPoint(t) {
            return this.clampPoint(t, ue).distanceTo(t);
          }
          getBoundingSphere(t) {
            return (
              this.isEmpty()
                ? t.makeEmpty()
                : (this.getCenter(t.center), (t.radius = 0.5 * this.getSize(ue).length())),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (he[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                he[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                he[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                he[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                he[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                he[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                he[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                he[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(he)),
              this
            );
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        const he = [new ae(), new ae(), new ae(), new ae(), new ae(), new ae(), new ae(), new ae()],
          ue = new ae(),
          de = new ce(),
          pe = new ae(),
          fe = new ae(),
          me = new ae(),
          ge = new ae(),
          _e = new ae(),
          ve = new ae(),
          xe = new ae(),
          ye = new ae(),
          Me = new ae(),
          Se = new ae();
        function be(t, e, n, i, r) {
          for (let s = 0, a = t.length - 3; s <= a; s += 3) {
            Se.fromArray(t, s);
            const a = r.x * Math.abs(Se.x) + r.y * Math.abs(Se.y) + r.z * Math.abs(Se.z),
              o = e.dot(Se),
              l = n.dot(Se),
              c = i.dot(Se);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
          }
          return !0;
        }
        const Ee = new ce(),
          Te = new ae(),
          Ae = new ae();
        class we {
          constructor(t = new ae(), e = -1) {
            (this.isSphere = !0), (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : Ee.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
            return (this.radius = Math.sqrt(i)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius;
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return this.isEmpty()
              ? (t.makeEmpty(), t)
              : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
            Te.subVectors(t, this.center);
            const e = Te.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.addScaledVector(Te, n / t), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return t.isEmpty()
              ? this
              : this.isEmpty()
              ? (this.copy(t), this)
              : (!0 === this.center.equals(t.center)
                  ? (this.radius = Math.max(this.radius, t.radius))
                  : (Ae.subVectors(t.center, this.center).setLength(t.radius),
                    this.expandByPoint(Te.copy(t.center).add(Ae)),
                    this.expandByPoint(Te.copy(t.center).sub(Ae))),
                this);
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const Re = new ae(),
          Ce = new ae(),
          Le = new ae(),
          Pe = new ae(),
          Ie = new ae(),
          Ue = new ae(),
          Ne = new ae();
        class De {
          constructor(t = new ae(), e = new ae(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
          }
          at(t, e) {
            return e.copy(this.origin).addScaledVector(this.direction, t);
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, Re)), this;
          }
          closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.origin).addScaledVector(this.direction, n);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = Re.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (Re.copy(this.origin).addScaledVector(this.direction, e), Re.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, i) {
            Ce.copy(t).add(e).multiplyScalar(0.5),
              Le.copy(e).sub(t).normalize(),
              Pe.copy(this.origin).sub(Ce);
            const r = 0.5 * t.distanceTo(e),
              s = -this.direction.dot(Le),
              a = Pe.dot(this.direction),
              o = -Pe.dot(Le),
              l = Pe.lengthSq(),
              c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0)
              if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
                if (u >= -p)
                  if (u <= p) {
                    const t = 1 / c;
                    (h *= t), (u *= t), (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
                  } else
                    (u = r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                else (u = -r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
              else
                u <= -p
                  ? ((h = Math.max(0, -(-s * r + a))),
                    (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                    (d = -h * h + u * (u + 2 * o) + l))
                  : u <= p
                  ? ((h = 0), (u = Math.min(Math.max(-r, -o), r)), (d = u * (u + 2 * o) + l))
                  : ((h = Math.max(0, -(s * r + a))),
                    (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
                    (d = -h * h + u * (u + 2 * o) + l));
            else
              (u = s > 0 ? -r : r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
            return (
              n && n.copy(this.origin).addScaledVector(this.direction, h),
              i && i.copy(Ce).addScaledVector(Le, u),
              d
            );
          }
          intersectSphere(t, e) {
            Re.subVectors(t.center, this.origin);
            const n = Re.dot(this.direction),
              i = Re.dot(Re) - n * n,
              r = t.radius * t.radius;
            if (i > r) return null;
            const s = Math.sqrt(r - i),
              a = n - s,
              o = n + s;
            return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, i, r, s, a, o;
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              h = 1 / this.direction.z,
              u = this.origin;
            return (
              l >= 0
                ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
                : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
              c >= 0
                ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
                : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
              n > s || r > i
                ? null
                : ((r > n || isNaN(n)) && (n = r),
                  (s < i || isNaN(i)) && (i = s),
                  h >= 0
                    ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
                    : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
                  n > o || a > i
                    ? null
                    : ((a > n || n != n) && (n = a),
                      (o < i || i != i) && (i = o),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, Re);
          }
          intersectTriangle(t, e, n, i, r) {
            Ie.subVectors(e, t), Ue.subVectors(n, t), Ne.crossVectors(Ie, Ue);
            let s,
              a = this.direction.dot(Ne);
            if (a > 0) {
              if (i) return null;
              s = 1;
            } else {
              if (!(a < 0)) return null;
              (s = -1), (a = -a);
            }
            Pe.subVectors(this.origin, t);
            const o = s * this.direction.dot(Ue.crossVectors(Pe, Ue));
            if (o < 0) return null;
            const l = s * this.direction.dot(Ie.cross(Pe));
            if (l < 0) return null;
            if (o + l > a) return null;
            const c = -s * Pe.dot(Ne);
            return c < 0 ? null : this.at(c / a, r);
          }
          applyMatrix4(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
          }
          equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class Oe {
          constructor(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            (Oe.prototype.isMatrix4 = !0),
              (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              void 0 !== t && this.set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m);
          }
          set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = s),
              (g[9] = a),
              (g[13] = o),
              (g[2] = l),
              (g[6] = c),
              (g[10] = h),
              (g[14] = u),
              (g[3] = d),
              (g[7] = p),
              (g[11] = f),
              (g[15] = m),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
          }
          clone() {
            return new Oe().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              i = 1 / Be.setFromMatrixColumn(t, 0).length(),
              r = 1 / Be.setFromMatrixColumn(t, 1).length(),
              s = 1 / Be.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * i),
              (e[1] = n[1] * i),
              (e[2] = n[2] * i),
              (e[3] = 0),
              (e[4] = n[4] * r),
              (e[5] = n[5] * r),
              (e[6] = n[6] * r),
              (e[7] = 0),
              (e[8] = n[8] * s),
              (e[9] = n[9] * s),
              (e[10] = n[10] * s),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              s = Math.cos(n),
              a = Math.sin(n),
              o = Math.cos(i),
              l = Math.sin(i),
              c = Math.cos(r),
              h = Math.sin(r);
            if ("XYZ" === t.order) {
              const t = s * c,
                n = s * h,
                i = a * c,
                r = a * h;
              (e[0] = o * c),
                (e[4] = -o * h),
                (e[8] = l),
                (e[1] = n + i * l),
                (e[5] = t - r * l),
                (e[9] = -a * o),
                (e[2] = r - t * l),
                (e[6] = i + n * l),
                (e[10] = s * o);
            } else if ("YXZ" === t.order) {
              const t = o * c,
                n = o * h,
                i = l * c,
                r = l * h;
              (e[0] = t + r * a),
                (e[4] = i * a - n),
                (e[8] = s * l),
                (e[1] = s * h),
                (e[5] = s * c),
                (e[9] = -a),
                (e[2] = n * a - i),
                (e[6] = r + t * a),
                (e[10] = s * o);
            } else if ("ZXY" === t.order) {
              const t = o * c,
                n = o * h,
                i = l * c,
                r = l * h;
              (e[0] = t - r * a),
                (e[4] = -s * h),
                (e[8] = i + n * a),
                (e[1] = n + i * a),
                (e[5] = s * c),
                (e[9] = r - t * a),
                (e[2] = -s * l),
                (e[6] = a),
                (e[10] = s * o);
            } else if ("ZYX" === t.order) {
              const t = s * c,
                n = s * h,
                i = a * c,
                r = a * h;
              (e[0] = o * c),
                (e[4] = i * l - n),
                (e[8] = t * l + r),
                (e[1] = o * h),
                (e[5] = r * l + t),
                (e[9] = n * l - i),
                (e[2] = -l),
                (e[6] = a * o),
                (e[10] = s * o);
            } else if ("YZX" === t.order) {
              const t = s * o,
                n = s * l,
                i = a * o,
                r = a * l;
              (e[0] = o * c),
                (e[4] = r - t * h),
                (e[8] = i * h + n),
                (e[1] = h),
                (e[5] = s * c),
                (e[9] = -a * c),
                (e[2] = -l * c),
                (e[6] = n * h + i),
                (e[10] = t - r * h);
            } else if ("XZY" === t.order) {
              const t = s * o,
                n = s * l,
                i = a * o,
                r = a * l;
              (e[0] = o * c),
                (e[4] = -h),
                (e[8] = l * c),
                (e[1] = t * h + r),
                (e[5] = s * c),
                (e[9] = n * h - i),
                (e[2] = i * h - n),
                (e[6] = a * c),
                (e[10] = r * h + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(ze, t, He);
          }
          lookAt(t, e, n) {
            const i = this.elements;
            return (
              Ve.subVectors(t, e),
              0 === Ve.lengthSq() && (Ve.z = 1),
              Ve.normalize(),
              Ge.crossVectors(n, Ve),
              0 === Ge.lengthSq() &&
                (1 === Math.abs(n.z) ? (Ve.x += 1e-4) : (Ve.z += 1e-4),
                Ve.normalize(),
                Ge.crossVectors(n, Ve)),
              Ge.normalize(),
              ke.crossVectors(Ve, Ge),
              (i[0] = Ge.x),
              (i[4] = ke.x),
              (i[8] = Ve.x),
              (i[1] = Ge.y),
              (i[5] = ke.y),
              (i[9] = Ve.y),
              (i[2] = Ge.z),
              (i[6] = ke.z),
              (i[10] = Ve.z),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              a = n[4],
              o = n[8],
              l = n[12],
              c = n[1],
              h = n[5],
              u = n[9],
              d = n[13],
              p = n[2],
              f = n[6],
              m = n[10],
              g = n[14],
              _ = n[3],
              v = n[7],
              x = n[11],
              y = n[15],
              M = i[0],
              S = i[4],
              b = i[8],
              E = i[12],
              T = i[1],
              A = i[5],
              w = i[9],
              R = i[13],
              C = i[2],
              L = i[6],
              P = i[10],
              I = i[14],
              U = i[3],
              N = i[7],
              D = i[11],
              O = i[15];
            return (
              (r[0] = s * M + a * T + o * C + l * U),
              (r[4] = s * S + a * A + o * L + l * N),
              (r[8] = s * b + a * w + o * P + l * D),
              (r[12] = s * E + a * R + o * I + l * O),
              (r[1] = c * M + h * T + u * C + d * U),
              (r[5] = c * S + h * A + u * L + d * N),
              (r[9] = c * b + h * w + u * P + d * D),
              (r[13] = c * E + h * R + u * I + d * O),
              (r[2] = p * M + f * T + m * C + g * U),
              (r[6] = p * S + f * A + m * L + g * N),
              (r[10] = p * b + f * w + m * P + g * D),
              (r[14] = p * E + f * R + m * I + g * O),
              (r[3] = _ * M + v * T + x * C + y * U),
              (r[7] = _ * S + v * A + x * L + y * N),
              (r[11] = _ * b + v * w + x * P + y * D),
              (r[15] = _ * E + v * R + x * I + y * O),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              s = t[1],
              a = t[5],
              o = t[9],
              l = t[13],
              c = t[2],
              h = t[6],
              u = t[10],
              d = t[14];
            return (
              t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) +
              t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) +
              t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) +
              t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const i = this.elements;
            return (
              t.isVector3
                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                : ((i[12] = t), (i[13] = e), (i[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8],
              h = t[9],
              u = t[10],
              d = t[11],
              p = t[12],
              f = t[13],
              m = t[14],
              g = t[15],
              _ = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
              v = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
              x = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
              y = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
              M = e * _ + n * v + i * x + r * y;
            if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const S = 1 / M;
            return (
              (t[0] = _ * S),
              (t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * S),
              (t[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * S),
              (t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * S),
              (t[4] = v * S),
              (t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * S),
              (t[6] = (p * o * r - s * m * r - p * i * l + e * m * l + s * i * g - e * o * g) * S),
              (t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * S),
              (t[8] = x * S),
              (t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * S),
              (t[10] = (s * f * r - p * a * r + p * n * l - e * f * l - s * n * g + e * a * g) * S),
              (t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * S),
              (t[12] = y * S),
              (t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * S),
              (t[14] = (p * a * i - s * f * i - p * n * o + e * f * o + s * n * m - e * a * m) * S),
              (t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * S),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z;
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i));
          }
          makeTranslation(t, e, n) {
            return (
              t.isVector3
                ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
                : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
              this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              s = t.x,
              a = t.y,
              o = t.z,
              l = r * s,
              c = r * a;
            return (
              this.set(
                l * s + n,
                l * a - i * o,
                l * o + i * a,
                0,
                l * a + i * o,
                c * a + n,
                c * o - i * s,
                0,
                l * o - i * a,
                c * o + i * s,
                r * o * o + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
          }
          makeShear(t, e, n, i, r, s) {
            return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
          }
          compose(t, e, n) {
            const i = this.elements,
              r = e._x,
              s = e._y,
              a = e._z,
              o = e._w,
              l = r + r,
              c = s + s,
              h = a + a,
              u = r * l,
              d = r * c,
              p = r * h,
              f = s * c,
              m = s * h,
              g = a * h,
              _ = o * l,
              v = o * c,
              x = o * h,
              y = n.x,
              M = n.y,
              S = n.z;
            return (
              (i[0] = (1 - (f + g)) * y),
              (i[1] = (d + x) * y),
              (i[2] = (p - v) * y),
              (i[3] = 0),
              (i[4] = (d - x) * M),
              (i[5] = (1 - (u + g)) * M),
              (i[6] = (m + _) * M),
              (i[7] = 0),
              (i[8] = (p + v) * S),
              (i[9] = (m - _) * S),
              (i[10] = (1 - (u + f)) * S),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const i = this.elements;
            let r = Be.set(i[0], i[1], i[2]).length();
            const s = Be.set(i[4], i[5], i[6]).length(),
              a = Be.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
              (t.x = i[12]),
              (t.y = i[13]),
              (t.z = i[14]),
              Fe.copy(this);
            const o = 1 / r,
              l = 1 / s,
              c = 1 / a;
            return (
              (Fe.elements[0] *= o),
              (Fe.elements[1] *= o),
              (Fe.elements[2] *= o),
              (Fe.elements[4] *= l),
              (Fe.elements[5] *= l),
              (Fe.elements[6] *= l),
              (Fe.elements[8] *= c),
              (Fe.elements[9] *= c),
              (Fe.elements[10] *= c),
              e.setFromRotationMatrix(Fe),
              (n.x = r),
              (n.y = s),
              (n.z = a),
              this
            );
          }
          makePerspective(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
              l = (2 * r) / (e - t),
              c = (2 * r) / (n - i),
              h = (e + t) / (e - t),
              u = (n + i) / (n - i);
            let d, p;
            if (a === gt) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
            else {
              if (a !== _t)
                throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
              (d = -s / (s - r)), (p = (-s * r) / (s - r));
            }
            return (
              (o[0] = l),
              (o[4] = 0),
              (o[8] = h),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = c),
              (o[9] = u),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = d),
              (o[14] = p),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
              l = 1 / (e - t),
              c = 1 / (n - i),
              h = 1 / (s - r),
              u = (e + t) * l,
              d = (n + i) * c;
            let p, f;
            if (a === gt) (p = (s + r) * h), (f = -2 * h);
            else {
              if (a !== _t)
                throw new Error(
                  "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
                );
              (p = r * h), (f = -1 * h);
            }
            return (
              (o[0] = 2 * l),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -u),
              (o[1] = 0),
              (o[5] = 2 * c),
              (o[9] = 0),
              (o[13] = -d),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = f),
              (o[14] = -p),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        const Be = new ae(),
          Fe = new Oe(),
          ze = new ae(0, 0, 0),
          He = new ae(1, 1, 1),
          Ge = new ae(),
          ke = new ae(),
          Ve = new ae(),
          We = new Oe(),
          Xe = new se();
        class je {
          constructor(t = 0, e = 0, n = 0, i = je.DEFAULT_ORDER) {
            (this.isEuler = !0), (this._x = t), (this._y = e), (this._z = n), (this._order = i);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, i = this._order) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e = this._order, n = !0) {
            const i = t.elements,
              r = i[0],
              s = i[4],
              a = i[8],
              o = i[1],
              l = i[5],
              c = i[9],
              h = i[2],
              u = i[6],
              d = i[10];
            switch (e) {
              case "XYZ":
                (this._y = Math.asin(Et(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                    : ((this._x = Math.atan2(u, l)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-Et(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                    : ((this._y = Math.atan2(-h, r)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(Et(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
                    : ((this._y = 0), (this._z = Math.atan2(o, r)));
                break;
              case "ZYX":
                (this._y = Math.asin(-Et(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
                    : ((this._x = 0), (this._z = Math.atan2(-s, l)));
                break;
              case "YZX":
                (this._z = Math.asin(Et(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
                    : ((this._x = 0), (this._y = Math.atan2(a, d)));
                break;
              case "XZY":
                (this._z = Math.asin(-Et(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
                    : ((this._x = Math.atan2(-c, d)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e
                );
            }
            return (this._order = e), !0 === n && this._onChangeCallback(), this;
          }
          setFromQuaternion(t, e, n) {
            return We.makeRotationFromQuaternion(t), this.setFromRotationMatrix(We, e, n);
          }
          setFromVector3(t, e = this._order) {
            return this.set(t.x, t.y, t.z, e);
          }
          reorder(t) {
            return Xe.setFromEuler(this), this.setFromQuaternion(Xe, t);
          }
          equals(t) {
            return (
              t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        }
        je.DEFAULT_ORDER = "XYZ";
        class qe {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = ((1 << t) | 0) >>> 0;
          }
          enable(t) {
            this.mask |= (1 << t) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0;
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return 0 != (this.mask & t.mask);
          }
          isEnabled(t) {
            return 0 != (this.mask & ((1 << t) | 0));
          }
        }
        let Ye = 0;
        const Ke = new ae(),
          Ze = new se(),
          Je = new Oe(),
          Qe = new ae(),
          $e = new ae(),
          tn = new ae(),
          en = new se(),
          nn = new ae(1, 0, 0),
          rn = new ae(0, 1, 0),
          sn = new ae(0, 0, 1),
          an = { type: "added" },
          on = { type: "removed" };
        class ln extends vt {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", { value: Ye++ }),
              (this.uuid = bt()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = ln.DEFAULT_UP.clone());
            const t = new ae(),
              e = new je(),
              n = new se(),
              i = new ae(1, 1, 1);
            e._onChange(function () {
              n.setFromEuler(e, !1);
            }),
              n._onChange(function () {
                e.setFromQuaternion(n, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: e },
                quaternion: { configurable: !0, enumerable: !0, value: n },
                scale: { configurable: !0, enumerable: !0, value: i },
                modelViewMatrix: { value: new Oe() },
                normalMatrix: { value: new Ut() },
              }),
              (this.matrix = new Oe()),
              (this.matrixWorld = new Oe()),
              (this.matrixAutoUpdate = ln.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldAutoUpdate = ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.layers = new qe()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeShadow() {}
          onAfterShadow() {}
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, e) {
            return Ze.setFromAxisAngle(t, e), this.quaternion.multiply(Ze), this;
          }
          rotateOnWorldAxis(t, e) {
            return Ze.setFromAxisAngle(t, e), this.quaternion.premultiply(Ze), this;
          }
          rotateX(t) {
            return this.rotateOnAxis(nn, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(rn, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(sn, t);
          }
          translateOnAxis(t, e) {
            return (
              Ke.copy(t).applyQuaternion(this.quaternion),
              this.position.add(Ke.multiplyScalar(e)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(nn, t);
          }
          translateY(t) {
            return this.translateOnAxis(rn, t);
          }
          translateZ(t) {
            return this.translateOnAxis(sn, t);
          }
          localToWorld(t) {
            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
          }
          worldToLocal(t) {
            return (
              this.updateWorldMatrix(!0, !1), t.applyMatrix4(Je.copy(this.matrixWorld).invert())
            );
          }
          lookAt(t, e, n) {
            t.isVector3 ? Qe.copy(t) : Qe.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
              $e.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? Je.lookAt($e, Qe, this.up)
                : Je.lookAt(Qe, $e, this.up),
              this.quaternion.setFromRotationMatrix(Je),
              i &&
                (Je.extractRotation(i.matrixWorld),
                Ze.setFromRotationMatrix(Je),
                this.quaternion.premultiply(Ze.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(an))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
              return this;
            }
            const e = this.children.indexOf(t);
            return (
              -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(on)), this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            return this.remove(...this.children);
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              Je.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1), Je.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(Je),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
              const i = this.children[n].getObjectByProperty(t, e);
              if (void 0 !== i) return i;
            }
          }
          getObjectsByProperty(t, e, n = []) {
            this[t] === e && n.push(this);
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) i[r].getObjectsByProperty(t, e, n);
            return n;
          }
          getWorldPosition(t) {
            return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
          }
          getWorldQuaternion(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($e, t, tn), t;
          }
          getWorldScale(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($e, en, t), t;
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
          }
          traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              (!0 !== i.matrixWorldAutoUpdate && !0 !== t) || i.updateMatrixWorld(t);
            }
          }
          updateWorldMatrix(t, e) {
            const n = this.parent;
            if (
              (!0 === t &&
                null !== n &&
                !0 === n.matrixWorldAutoUpdate &&
                n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
              !0 === e)
            ) {
              const t = this.children;
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }));
            const i = {};
            function r(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((i.uuid = this.uuid),
              (i.type = this.type),
              "" !== this.name && (i.name = this.name),
              !0 === this.castShadow && (i.castShadow = !0),
              !0 === this.receiveShadow && (i.receiveShadow = !0),
              !1 === this.visible && (i.visible = !1),
              !1 === this.frustumCulled && (i.frustumCulled = !1),
              0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 && (i.userData = this.userData),
              (i.layers = this.layers.mask),
              (i.matrix = this.matrix.toArray()),
              (i.up = this.up.toArray()),
              !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((i.type = "InstancedMesh"),
                (i.count = this.count),
                (i.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
              this.isBatchedMesh &&
                ((i.type = "BatchedMesh"),
                (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
                (i.sortObjects = this.sortObjects),
                (i.drawRanges = this._drawRanges),
                (i.reservedRanges = this._reservedRanges),
                (i.visibility = this._visibility),
                (i.active = this._active),
                (i.bounds = this._bounds.map((t) => ({
                  boxInitialized: t.boxInitialized,
                  boxMin: t.box.min.toArray(),
                  boxMax: t.box.max.toArray(),
                  sphereInitialized: t.sphereInitialized,
                  sphereRadius: t.sphere.radius,
                  sphereCenter: t.sphere.center.toArray(),
                }))),
                (i.maxGeometryCount = this._maxGeometryCount),
                (i.maxVertexCount = this._maxVertexCount),
                (i.maxIndexCount = this._maxIndexCount),
                (i.geometryInitialized = this._geometryInitialized),
                (i.geometryCount = this._geometryCount),
                (i.matricesTexture = this._matricesTexture.toJSON(t)),
                null !== this.boundingSphere &&
                  (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius,
                  }),
                null !== this.boundingBox &&
                  (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray(),
                  })),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (i.background = this.background.toJSON())
                  : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (i.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              i.geometry = r(t.geometries, this.geometry);
              const e = this.geometry.parameters;
              if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    r(t.shapes, i);
                  }
                else r(t.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((i.bindMode = this.bindMode),
                (i.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, i = this.material.length; n < i; n++)
                  e.push(r(t.materials, this.material[n]));
                i.material = e;
              } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
              i.children = [];
              for (let e = 0; e < this.children.length; e++)
                i.children.push(this.children[e].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              i.animations = [];
              for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                i.animations.push(r(t.animations, n));
              }
            }
            if (e) {
              const e = s(t.geometries),
                i = s(t.materials),
                r = s(t.textures),
                a = s(t.images),
                o = s(t.shapes),
                l = s(t.skeletons),
                c = s(t.animations),
                h = s(t.nodes);
              e.length > 0 && (n.geometries = e),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                a.length > 0 && (n.images = a),
                o.length > 0 && (n.shapes = o),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c),
                h.length > 0 && (n.nodes = h);
            }
            return (n.object = i), n;
            function s(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, e = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.animations = t.animations.slice()),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === e)
            )
              for (let e = 0; e < t.children.length; e++) {
                const n = t.children[e];
                this.add(n.clone());
              }
            return this;
          }
        }
        (ln.DEFAULT_UP = new ae(0, 1, 0)),
          (ln.DEFAULT_MATRIX_AUTO_UPDATE = !0),
          (ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
        const cn = new ae(),
          hn = new ae(),
          un = new ae(),
          dn = new ae(),
          pn = new ae(),
          fn = new ae(),
          mn = new ae(),
          gn = new ae(),
          _n = new ae(),
          vn = new ae();
        let xn = !1;
        class yn {
          constructor(t = new ae(), e = new ae(), n = new ae()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, i) {
            i.subVectors(n, e), cn.subVectors(t, e), i.cross(cn);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, i, r) {
            cn.subVectors(i, e), hn.subVectors(n, e), un.subVectors(t, e);
            const s = cn.dot(cn),
              a = cn.dot(hn),
              o = cn.dot(un),
              l = hn.dot(hn),
              c = hn.dot(un),
              h = s * l - a * a;
            if (0 === h) return r.set(0, 0, 0), null;
            const u = 1 / h,
              d = (l * o - a * c) * u,
              p = (s * c - a * o) * u;
            return r.set(1 - d - p, p, d);
          }
          static containsPoint(t, e, n, i) {
            return (
              null !== this.getBarycoord(t, e, n, i, dn) &&
              dn.x >= 0 &&
              dn.y >= 0 &&
              dn.x + dn.y <= 1
            );
          }
          static getUV(t, e, n, i, r, s, a, o) {
            return (
              !1 === xn &&
                (console.warn(
                  "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
                ),
                (xn = !0)),
              this.getInterpolation(t, e, n, i, r, s, a, o)
            );
          }
          static getInterpolation(t, e, n, i, r, s, a, o) {
            return null === this.getBarycoord(t, e, n, i, dn)
              ? ((o.x = 0), (o.y = 0), "z" in o && (o.z = 0), "w" in o && (o.w = 0), null)
              : (o.setScalar(0),
                o.addScaledVector(r, dn.x),
                o.addScaledVector(s, dn.y),
                o.addScaledVector(a, dn.z),
                o);
          }
          static isFrontFacing(t, e, n, i) {
            return cn.subVectors(n, e), hn.subVectors(t, e), cn.cross(hn).dot(i) < 0;
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
          }
          setFromAttributeAndIndices(t, e, n, i) {
            return (
              this.a.fromBufferAttribute(t, e),
              this.b.fromBufferAttribute(t, n),
              this.c.fromBufferAttribute(t, i),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              cn.subVectors(this.c, this.b),
              hn.subVectors(this.a, this.b),
              0.5 * cn.cross(hn).length()
            );
          }
          getMidpoint(t) {
            return t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          }
          getNormal(t) {
            return yn.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c);
          }
          getBarycoord(t, e) {
            return yn.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, i, r) {
            return (
              !1 === xn &&
                (console.warn(
                  "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
                ),
                (xn = !0)),
              yn.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            );
          }
          getInterpolation(t, e, n, i, r) {
            return yn.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
          }
          containsPoint(t) {
            return yn.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return yn.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            const n = this.a,
              i = this.b,
              r = this.c;
            let s, a;
            pn.subVectors(i, n), fn.subVectors(r, n), gn.subVectors(t, n);
            const o = pn.dot(gn),
              l = fn.dot(gn);
            if (o <= 0 && l <= 0) return e.copy(n);
            _n.subVectors(t, i);
            const c = pn.dot(_n),
              h = fn.dot(_n);
            if (c >= 0 && h <= c) return e.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0)
              return (s = o / (o - c)), e.copy(n).addScaledVector(pn, s);
            vn.subVectors(t, r);
            const d = pn.dot(vn),
              p = fn.dot(vn);
            if (p >= 0 && d <= p) return e.copy(r);
            const f = d * l - o * p;
            if (f <= 0 && l >= 0 && p <= 0)
              return (a = l / (l - p)), e.copy(n).addScaledVector(fn, a);
            const m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0)
              return (
                mn.subVectors(r, i),
                (a = (h - c) / (h - c + (d - p))),
                e.copy(i).addScaledVector(mn, a)
              );
            const g = 1 / (m + f + u);
            return (
              (s = f * g), (a = u * g), e.copy(n).addScaledVector(pn, s).addScaledVector(fn, a)
            );
          }
          equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
          }
        }
        const Mn = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074,
          },
          Sn = { h: 0, s: 0, l: 0 },
          bn = { h: 0, s: 0, l: 0 };
        function En(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        class Tn {
          constructor(t, e, n) {
            return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(t, e, n);
          }
          set(t, e, n) {
            if (void 0 === e && void 0 === n) {
              const e = t;
              e && e.isColor
                ? this.copy(e)
                : "number" == typeof e
                ? this.setHex(e)
                : "string" == typeof e && this.setStyle(e);
            } else this.setRGB(t, e, n);
            return this;
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t, e = rt) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              Wt.toWorkingColorSpace(this, e),
              this
            );
          }
          setRGB(t, e, n, i = Wt.workingColorSpace) {
            return (this.r = t), (this.g = e), (this.b = n), Wt.toWorkingColorSpace(this, i), this;
          }
          setHSL(t, e, n, i = Wt.workingColorSpace) {
            if (((t = Tt(t, 1)), (e = Et(e, 0, 1)), (n = Et(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n;
            else {
              const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                r = 2 * n - i;
              (this.r = En(r, i, t + 1 / 3)),
                (this.g = En(r, i, t)),
                (this.b = En(r, i, t - 1 / 3));
            }
            return Wt.toWorkingColorSpace(this, i), this;
          }
          setStyle(t, e = rt) {
            function n(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
            }
            let i;
            if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
              let r;
              const s = i[1],
                a = i[2];
              switch (s) {
                case "rgb":
                case "rgba":
                  if ((r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
                    return (
                      n(r[4]),
                      this.setRGB(
                        Math.min(255, parseInt(r[1], 10)) / 255,
                        Math.min(255, parseInt(r[2], 10)) / 255,
                        Math.min(255, parseInt(r[3], 10)) / 255,
                        e
                      )
                    );
                  if (
                    (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                  )
                    return (
                      n(r[4]),
                      this.setRGB(
                        Math.min(100, parseInt(r[1], 10)) / 100,
                        Math.min(100, parseInt(r[2], 10)) / 100,
                        Math.min(100, parseInt(r[3], 10)) / 100,
                        e
                      )
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (r =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        a
                      ))
                  )
                    return (
                      n(r[4]),
                      this.setHSL(
                        parseFloat(r[1]) / 360,
                        parseFloat(r[2]) / 100,
                        parseFloat(r[3]) / 100,
                        e
                      )
                    );
                  break;
                default:
                  console.warn("THREE.Color: Unknown color model " + t);
              }
            } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const n = i[1],
                r = n.length;
              if (3 === r)
                return this.setRGB(
                  parseInt(n.charAt(0), 16) / 15,
                  parseInt(n.charAt(1), 16) / 15,
                  parseInt(n.charAt(2), 16) / 15,
                  e
                );
              if (6 === r) return this.setHex(parseInt(n, 16), e);
              console.warn("THREE.Color: Invalid hex color " + t);
            } else if (t && t.length > 0) return this.setColorName(t, e);
            return this;
          }
          setColorName(t, e = rt) {
            const n = Mn[t.toLowerCase()];
            return (
              void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copySRGBToLinear(t) {
            return (this.r = Xt(t.r)), (this.g = Xt(t.g)), (this.b = Xt(t.b)), this;
          }
          copyLinearToSRGB(t) {
            return (this.r = jt(t.r)), (this.g = jt(t.g)), (this.b = jt(t.b)), this;
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex(t = rt) {
            return (
              Wt.fromWorkingColorSpace(An.copy(this), t),
              65536 * Math.round(Et(255 * An.r, 0, 255)) +
                256 * Math.round(Et(255 * An.g, 0, 255)) +
                Math.round(Et(255 * An.b, 0, 255))
            );
          }
          getHexString(t = rt) {
            return ("000000" + this.getHex(t).toString(16)).slice(-6);
          }
          getHSL(t, e = Wt.workingColorSpace) {
            Wt.fromWorkingColorSpace(An.copy(this), e);
            const n = An.r,
              i = An.g,
              r = An.b,
              s = Math.max(n, i, r),
              a = Math.min(n, i, r);
            let o, l;
            const c = (a + s) / 2;
            if (a === s) (o = 0), (l = 0);
            else {
              const t = s - a;
              switch (((l = c <= 0.5 ? t / (s + a) : t / (2 - s - a)), s)) {
                case n:
                  o = (i - r) / t + (i < r ? 6 : 0);
                  break;
                case i:
                  o = (r - n) / t + 2;
                  break;
                case r:
                  o = (n - i) / t + 4;
              }
              o /= 6;
            }
            return (t.h = o), (t.s = l), (t.l = c), t;
          }
          getRGB(t, e = Wt.workingColorSpace) {
            return (
              Wt.fromWorkingColorSpace(An.copy(this), e),
              (t.r = An.r),
              (t.g = An.g),
              (t.b = An.b),
              t
            );
          }
          getStyle(t = rt) {
            Wt.fromWorkingColorSpace(An.copy(this), t);
            const e = An.r,
              n = An.g,
              i = An.b;
            return t !== rt
              ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
              : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`;
          }
          offsetHSL(t, e, n) {
            return this.getHSL(Sn), this.setHSL(Sn.h + t, Sn.s + e, Sn.l + n);
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(Sn), t.getHSL(bn);
            const n = At(Sn.h, bn.h, e),
              i = At(Sn.s, bn.s, e),
              r = At(Sn.l, bn.l, e);
            return this.setHSL(n, i, r), this;
          }
          setFromVector3(t) {
            return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
          }
          applyMatrix3(t) {
            const e = this.r,
              n = this.g,
              i = this.b,
              r = t.elements;
            return (
              (this.r = r[0] * e + r[3] * n + r[6] * i),
              (this.g = r[1] * e + r[4] * n + r[7] * i),
              (this.b = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this;
          }
          toJSON() {
            return this.getHex();
          }
          *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
          }
        }
        const An = new Tn();
        Tn.NAMES = Mn;
        let wn = 0;
        class Rn extends vt {
          constructor() {
            super(),
              (this.isMaterial = !0),
              Object.defineProperty(this, "id", { value: wn++ }),
              (this.uuid = bt()),
              (this.name = ""),
              (this.type = "Material"),
              (this.blending = 1),
              (this.side = o),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.transparent = !1),
              (this.alphaHash = !1),
              (this.blendSrc = 204),
              (this.blendDst = 205),
              (this.blendEquation = c),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.blendColor = new Tn(0, 0, 0)),
              (this.blendAlpha = 0),
              (this.depthFunc = 3),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = 519),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = dt),
              (this.stencilZFail = dt),
              (this.stencilZPass = dt),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.forceSinglePass = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0),
              (this._alphaTest = 0);
          }
          get alphaTest() {
            return this._alphaTest;
          }
          set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                  continue;
                }
                const i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
              }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = { textures: {}, images: {} });
            const n = {
              metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" },
            };
            function i(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              "" !== this.name && (n.name = this.name),
              this.color && this.color.isColor && (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              void 0 !== this.sheen && (n.sheen = this.sheen),
              this.sheenColor &&
                this.sheenColor.isColor &&
                (n.sheenColor = this.sheenColor.getHex()),
              void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
              this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
              this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
              void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
              this.specularColor &&
                this.specularColor.isColor &&
                (n.specularColor = this.specularColor.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              void 0 !== this.iridescence && (n.iridescence = this.iridescence),
              void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
              void 0 !== this.iridescenceThicknessRange &&
                (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
              this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
              this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
              void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
              void 0 !== this.anisotropyRotation &&
                (n.anisotropyRotation = this.anisotropyRotation),
              this.anisotropyMap &&
                this.anisotropyMap.isTexture &&
                (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
              this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
              this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
              this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                void 0 !== this.combine && (n.combine = this.combine)),
              void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.transmission && (n.transmission = this.transmission),
              this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
              void 0 !== this.thickness && (n.thickness = this.thickness),
              this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
              void 0 !== this.attenuationDistance &&
                this.attenuationDistance !== 1 / 0 &&
                (n.attenuationDistance = this.attenuationDistance),
              void 0 !== this.attenuationColor &&
                (n.attenuationColor = this.attenuationColor.getHex()),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (n.blending = this.blending),
              this.side !== o && (n.side = this.side),
              !0 === this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              !0 === this.transparent && (n.transparent = !0),
              204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
              205 !== this.blendDst && (n.blendDst = this.blendDst),
              this.blendEquation !== c && (n.blendEquation = this.blendEquation),
              null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
              null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
              null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
              this.blendColor &&
                this.blendColor.isColor &&
                (n.blendColor = this.blendColor.getHex()),
              0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
              3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
              !1 === this.depthTest && (n.depthTest = this.depthTest),
              !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
              !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
              255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
              519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
              0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
              255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
              this.stencilFail !== dt && (n.stencilFail = this.stencilFail),
              this.stencilZFail !== dt && (n.stencilZFail = this.stencilZFail),
              this.stencilZPass !== dt && (n.stencilZPass = this.stencilZPass),
              !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
              void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
              void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaHash && (n.alphaHash = !0),
              !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
              !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
              !0 === this.forceSinglePass && (n.forceSinglePass = !0),
              !0 === this.wireframe && (n.wireframe = !0),
              this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.flatShading && (n.flatShading = !0),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              !1 === this.fog && (n.fog = !1),
              Object.keys(this.userData).length > 0 && (n.userData = this.userData),
              e)
            ) {
              const e = i(t.textures),
                r = i(t.images);
              e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
            }
            return n;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.name = t.name),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              this.blendColor.copy(t.blendColor),
              (this.blendAlpha = t.blendAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaHash = t.alphaHash),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.forceSinglePass = t.forceSinglePass),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        class Cn extends Rn {
          constructor(t) {
            super(),
              (this.isMeshBasicMaterial = !0),
              (this.type = "MeshBasicMaterial"),
              (this.color = new Tn(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = h),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        const Ln = new ae(),
          Pn = new It();
        class In {
          constructor(t, e, n = !1) {
            if (Array.isArray(t))
              throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            (this.isBufferAttribute = !0),
              (this.name = ""),
              (this.array = t),
              (this.itemSize = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.normalized = n),
              (this.usage = pt),
              (this._updateRange = { offset: 0, count: -1 }),
              (this.updateRanges = []),
              (this.gpuType = O),
              (this.version = 0);
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          get updateRange() {
            return (
              console.warn(
                "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
              ),
              this._updateRange
            );
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          addUpdateRange(t, e) {
            this.updateRanges.push({ start: t, count: e });
          }
          clearUpdateRanges() {
            this.updateRanges.length = 0;
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.usage = t.usage),
              (this.gpuType = t.gpuType),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this;
          }
          copyArray(t) {
            return this.array.set(t), this;
          }
          applyMatrix3(t) {
            if (2 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                Pn.fromBufferAttribute(this, e), Pn.applyMatrix3(t), this.setXY(e, Pn.x, Pn.y);
            else if (3 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                Ln.fromBufferAttribute(this, e),
                  Ln.applyMatrix3(t),
                  this.setXYZ(e, Ln.x, Ln.y, Ln.z);
            return this;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
              Ln.fromBufferAttribute(this, e), Ln.applyMatrix4(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              Ln.fromBufferAttribute(this, e),
                Ln.applyNormalMatrix(t),
                this.setXYZ(e, Ln.x, Ln.y, Ln.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              Ln.fromBufferAttribute(this, e),
                Ln.transformDirection(t),
                this.setXYZ(e, Ln.x, Ln.y, Ln.z);
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          getComponent(t, e) {
            let n = this.array[t * this.itemSize + e];
            return this.normalized && (n = Ct(n, this.array)), n;
          }
          setComponent(t, e, n) {
            return (
              this.normalized && (n = Lt(n, this.array)),
              (this.array[t * this.itemSize + e] = n),
              this
            );
          }
          getX(t) {
            let e = this.array[t * this.itemSize];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          setX(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)), (this.array[t * this.itemSize] = e), this
            );
          }
          getY(t) {
            let e = this.array[t * this.itemSize + 1];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          setY(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.array[t * this.itemSize + 1] = e),
              this
            );
          }
          getZ(t) {
            let e = this.array[t * this.itemSize + 2];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          setZ(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.array[t * this.itemSize + 2] = e),
              this
            );
          }
          getW(t) {
            let e = this.array[t * this.itemSize + 3];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          setW(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.array[t * this.itemSize + 3] = e),
              this
            );
          }
          setXY(t, e, n) {
            return (
              (t *= this.itemSize),
              this.normalized && ((e = Lt(e, this.array)), (n = Lt(n, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = Lt(e, this.array)), (n = Lt(n, this.array)), (i = Lt(i, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = Lt(e, this.array)),
                (n = Lt(n, this.array)),
                (i = Lt(i, this.array)),
                (r = Lt(r, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              (this.array[t + 3] = r),
              this
            );
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            const t = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.from(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (t.name = this.name),
              this.usage !== pt && (t.usage = this.usage),
              t
            );
          }
        }
        class Un extends In {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        class Nn extends In {
          constructor(t, e, n) {
            super(new Uint32Array(t), e, n);
          }
        }
        class Dn extends In {
          constructor(t, e, n) {
            super(new Float32Array(t), e, n);
          }
        }
        let On = 0;
        const Bn = new Oe(),
          Fn = new ln(),
          zn = new ae(),
          Hn = new ce(),
          Gn = new ce(),
          kn = new ae();
        class Vn extends vt {
          constructor() {
            super(),
              (this.isBufferGeometry = !0),
              Object.defineProperty(this, "id", { value: On++ }),
              (this.uuid = bt()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(t) {
            return (
              Array.isArray(t) ? (this.index = new (Dt(t) ? Nn : Un)(t, 1)) : (this.index = t), this
            );
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          setAttribute(t, e) {
            return (this.attributes[t] = e), this;
          }
          deleteAttribute(t) {
            return delete this.attributes[t], this;
          }
          hasAttribute(t) {
            return void 0 !== this.attributes[t];
          }
          addGroup(t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          }
          applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new Ut().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const i = this.attributes.tangent;
            return (
              void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(t) {
            return Bn.makeRotationFromQuaternion(t), this.applyMatrix4(Bn), this;
          }
          rotateX(t) {
            return Bn.makeRotationX(t), this.applyMatrix4(Bn), this;
          }
          rotateY(t) {
            return Bn.makeRotationY(t), this.applyMatrix4(Bn), this;
          }
          rotateZ(t) {
            return Bn.makeRotationZ(t), this.applyMatrix4(Bn), this;
          }
          translate(t, e, n) {
            return Bn.makeTranslation(t, e, n), this.applyMatrix4(Bn), this;
          }
          scale(t, e, n) {
            return Bn.makeScale(t, e, n), this.applyMatrix4(Bn), this;
          }
          lookAt(t) {
            return Fn.lookAt(t), Fn.updateMatrix(), this.applyMatrix4(Fn.matrix), this;
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(zn).negate(),
              this.translate(zn.x, zn.y, zn.z),
              this
            );
          }
          setFromPoints(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              e.push(i.x, i.y, i.z || 0);
            }
            return this.setAttribute("position", new Dn(e, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new ce());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(
                  new ae(-1 / 0, -1 / 0, -1 / 0),
                  new ae(1 / 0, 1 / 0, 1 / 0)
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Hn.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (kn.addVectors(this.boundingBox.min, Hn.min),
                        this.boundingBox.expandByPoint(kn),
                        kn.addVectors(this.boundingBox.max, Hn.max),
                        this.boundingBox.expandByPoint(kn))
                      : (this.boundingBox.expandByPoint(Hn.min),
                        this.boundingBox.expandByPoint(Hn.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new we());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new ae(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((Hn.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Gn.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (kn.addVectors(Hn.min, Gn.min),
                        Hn.expandByPoint(kn),
                        kn.addVectors(Hn.max, Gn.max),
                        Hn.expandByPoint(kn))
                      : (Hn.expandByPoint(Gn.min), Hn.expandByPoint(Gn.max));
                }
              Hn.getCenter(n);
              let i = 0;
              for (let e = 0, r = t.count; e < r; e++)
                kn.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(kn)));
              if (e)
                for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r],
                    a = this.morphTargetsRelative;
                  for (let e = 0, r = s.count; e < r; e++)
                    kn.fromBufferAttribute(s, e),
                      a && (zn.fromBufferAttribute(t, e), kn.add(zn)),
                      (i = Math.max(i, n.distanceToSquared(kn)));
                }
              (this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          }
          computeTangents() {
            const t = this.index,
              e = this.attributes;
            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
              return void console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
            const n = t.array,
              i = e.position.array,
              r = e.normal.array,
              s = e.uv.array,
              a = i.length / 3;
            !1 === this.hasAttribute("tangent") &&
              this.setAttribute("tangent", new In(new Float32Array(4 * a), 4));
            const o = this.getAttribute("tangent").array,
              l = [],
              c = [];
            for (let t = 0; t < a; t++) (l[t] = new ae()), (c[t] = new ae());
            const h = new ae(),
              u = new ae(),
              d = new ae(),
              p = new It(),
              f = new It(),
              m = new It(),
              g = new ae(),
              _ = new ae();
            function v(t, e, n) {
              h.fromArray(i, 3 * t),
                u.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(s, 2 * t),
                f.fromArray(s, 2 * e),
                m.fromArray(s, 2 * n),
                u.sub(h),
                d.sub(h),
                f.sub(p),
                m.sub(p);
              const r = 1 / (f.x * m.y - m.x * f.y);
              isFinite(r) &&
                (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                _.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(_),
                c[e].add(_),
                c[n].add(_));
            }
            let x = this.groups;
            0 === x.length && (x = [{ start: 0, count: n.length }]);
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3) v(n[t + 0], n[t + 1], n[t + 2]);
            }
            const y = new ae(),
              M = new ae(),
              S = new ae(),
              b = new ae();
            function E(t) {
              S.fromArray(r, 3 * t), b.copy(S);
              const e = l[t];
              y.copy(e), y.sub(S.multiplyScalar(S.dot(e))).normalize(), M.crossVectors(b, e);
              const n = M.dot(c[t]) < 0 ? -1 : 1;
              (o[4 * t] = y.x), (o[4 * t + 1] = y.y), (o[4 * t + 2] = y.z), (o[4 * t + 3] = n);
            }
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3) E(n[t + 0]), E(n[t + 1]), E(n[t + 2]);
            }
          }
          computeVertexNormals() {
            const t = this.index,
              e = this.getAttribute("position");
            if (void 0 !== e) {
              let n = this.getAttribute("normal");
              if (void 0 === n)
                (n = new In(new Float32Array(3 * e.count), 3)), this.setAttribute("normal", n);
              else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const i = new ae(),
                r = new ae(),
                s = new ae(),
                a = new ae(),
                o = new ae(),
                l = new ae(),
                c = new ae(),
                h = new ae();
              if (t)
                for (let u = 0, d = t.count; u < d; u += 3) {
                  const d = t.getX(u + 0),
                    p = t.getX(u + 1),
                    f = t.getX(u + 2);
                  i.fromBufferAttribute(e, d),
                    r.fromBufferAttribute(e, p),
                    s.fromBufferAttribute(e, f),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    a.fromBufferAttribute(n, d),
                    o.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, f),
                    a.add(c),
                    o.add(c),
                    l.add(c),
                    n.setXYZ(d, a.x, a.y, a.z),
                    n.setXYZ(p, o.x, o.y, o.z),
                    n.setXYZ(f, l.x, l.y, l.z);
                }
              else
                for (let t = 0, a = e.count; t < a; t += 3)
                  i.fromBufferAttribute(e, t + 0),
                    r.fromBufferAttribute(e, t + 1),
                    s.fromBufferAttribute(e, t + 2),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          }
          normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              kn.fromBufferAttribute(t, e), kn.normalize(), t.setXYZ(e, kn.x, kn.y, kn.z);
          }
          toNonIndexed() {
            function t(t, e) {
              const n = t.array,
                i = t.itemSize,
                r = t.normalized,
                s = new n.constructor(e.length * i);
              let a = 0,
                o = 0;
              for (let r = 0, l = e.length; r < l; r++) {
                a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                for (let t = 0; t < i; t++) s[o++] = n[a++];
              }
              return new In(s, i, r);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            const e = new Vn(),
              n = this.index.array,
              i = this.attributes;
            for (const r in i) {
              const s = t(i[r], n);
              e.setAttribute(r, s);
            }
            const r = this.morphAttributes;
            for (const i in r) {
              const s = [],
                a = r[i];
              for (let e = 0, i = a.length; e < i; e++) {
                const i = t(a[e], n);
                s.push(i);
              }
              e.morphAttributes[i] = s;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, n = s.length; t < n; t++) {
              const n = s[t];
              e.addGroup(n.start, n.count, n.materialIndex);
            }
            return e;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              "" !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 && (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = { attributes: {} };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const e in n) {
              const i = n[e];
              t.data.attributes[e] = i.toJSON(t.data);
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                s = [];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                s.push(i.toJSON(t.data));
              }
              s.length > 0 && ((i[e] = s), (r = !0));
            }
            r &&
              ((t.data.morphAttributes = i),
              (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return (
              null !== a &&
                (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }),
              t
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
              const n = i[t];
              this.setAttribute(t, n.clone(e));
            }
            const r = t.morphAttributes;
            for (const t in r) {
              const n = [],
                i = r[t];
              for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
              this.morphAttributes[t] = n;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t];
              this.addGroup(e.start, e.count, e.materialIndex);
            }
            const a = t.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = t.boundingSphere;
            return (
              null !== o && (this.boundingSphere = o.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        const Wn = new Oe(),
          Xn = new De(),
          jn = new we(),
          qn = new ae(),
          Yn = new ae(),
          Kn = new ae(),
          Zn = new ae(),
          Jn = new ae(),
          Qn = new ae(),
          $n = new It(),
          ti = new It(),
          ei = new It(),
          ni = new ae(),
          ii = new ae(),
          ri = new ae(),
          si = new ae(),
          ai = new ae();
        class oi extends ln {
          constructor(t = new Vn(), e = new Cn()) {
            super(),
              (this.isMesh = !0),
              (this.type = "Mesh"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
              (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
          getVertexPosition(t, e) {
            const n = this.geometry,
              i = n.attributes.position,
              r = n.morphAttributes.position,
              s = n.morphTargetsRelative;
            e.fromBufferAttribute(i, t);
            const a = this.morphTargetInfluences;
            if (r && a) {
              Qn.set(0, 0, 0);
              for (let n = 0, i = r.length; n < i; n++) {
                const i = a[n],
                  o = r[n];
                0 !== i &&
                  (Jn.fromBufferAttribute(o, t),
                  s ? Qn.addScaledVector(Jn, i) : Qn.addScaledVector(Jn.sub(e), i));
              }
              e.add(Qn);
            }
            return e;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.material,
              r = this.matrixWorld;
            if (void 0 !== i) {
              if (
                (null === n.boundingSphere && n.computeBoundingSphere(),
                jn.copy(n.boundingSphere),
                jn.applyMatrix4(r),
                Xn.copy(t.ray).recast(t.near),
                !1 === jn.containsPoint(Xn.origin))
              ) {
                if (null === Xn.intersectSphere(jn, qn)) return;
                if (Xn.origin.distanceToSquared(qn) > (t.far - t.near) ** 2) return;
              }
              Wn.copy(r).invert(),
                Xn.copy(t.ray).applyMatrix4(Wn),
                (null !== n.boundingBox && !1 === Xn.intersectsBox(n.boundingBox)) ||
                  this._computeIntersections(t, e, Xn);
            }
          }
          _computeIntersections(t, e, n) {
            let i;
            const r = this.geometry,
              s = this.material,
              a = r.index,
              o = r.attributes.position,
              l = r.attributes.uv,
              c = r.attributes.uv1,
              h = r.attributes.normal,
              u = r.groups,
              d = r.drawRange;
            if (null !== a)
              if (Array.isArray(s))
                for (let r = 0, o = u.length; r < o; r++) {
                  const o = u[r],
                    p = s[o.materialIndex];
                  for (
                    let r = Math.max(o.start, d.start),
                      s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count));
                    r < s;
                    r += 3
                  )
                    (i = li(this, p, t, n, l, c, h, a.getX(r), a.getX(r + 1), a.getX(r + 2))),
                      i &&
                        ((i.faceIndex = Math.floor(r / 3)),
                        (i.face.materialIndex = o.materialIndex),
                        e.push(i));
                }
              else
                for (
                  let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count);
                  r < o;
                  r += 3
                )
                  (i = li(this, s, t, n, l, c, h, a.getX(r), a.getX(r + 1), a.getX(r + 2))),
                    i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
            else if (void 0 !== o)
              if (Array.isArray(s))
                for (let r = 0, a = u.length; r < a; r++) {
                  const a = u[r],
                    p = s[a.materialIndex];
                  for (
                    let r = Math.max(a.start, d.start),
                      s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count));
                    r < s;
                    r += 3
                  )
                    (i = li(this, p, t, n, l, c, h, r, r + 1, r + 2)),
                      i &&
                        ((i.faceIndex = Math.floor(r / 3)),
                        (i.face.materialIndex = a.materialIndex),
                        e.push(i));
                }
              else
                for (
                  let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count);
                  r < a;
                  r += 3
                )
                  (i = li(this, s, t, n, l, c, h, r, r + 1, r + 2)),
                    i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
          }
        }
        function li(t, e, n, i, r, s, a, l, c, h) {
          t.getVertexPosition(l, Yn), t.getVertexPosition(c, Kn), t.getVertexPosition(h, Zn);
          const u = (function (t, e, n, i, r, s, a, l) {
            let c;
            if (
              ((c =
                1 === e.side
                  ? i.intersectTriangle(a, s, r, !0, l)
                  : i.intersectTriangle(r, s, a, e.side === o, l)),
              null === c)
            )
              return null;
            ai.copy(l), ai.applyMatrix4(t.matrixWorld);
            const h = n.ray.origin.distanceTo(ai);
            return h < n.near || h > n.far ? null : { distance: h, point: ai.clone(), object: t };
          })(t, e, n, i, Yn, Kn, Zn, si);
          if (u) {
            r &&
              ($n.fromBufferAttribute(r, l),
              ti.fromBufferAttribute(r, c),
              ei.fromBufferAttribute(r, h),
              (u.uv = yn.getInterpolation(si, Yn, Kn, Zn, $n, ti, ei, new It()))),
              s &&
                ($n.fromBufferAttribute(s, l),
                ti.fromBufferAttribute(s, c),
                ei.fromBufferAttribute(s, h),
                (u.uv1 = yn.getInterpolation(si, Yn, Kn, Zn, $n, ti, ei, new It())),
                (u.uv2 = u.uv1)),
              a &&
                (ni.fromBufferAttribute(a, l),
                ii.fromBufferAttribute(a, c),
                ri.fromBufferAttribute(a, h),
                (u.normal = yn.getInterpolation(si, Yn, Kn, Zn, ni, ii, ri, new ae())),
                u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
            const t = { a: l, b: c, c: h, normal: new ae(), materialIndex: 0 };
            yn.getNormal(Yn, Kn, Zn, t.normal), (u.face = t);
          }
          return u;
        }
        class ci extends Vn {
          constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
            super(),
              (this.type = "BoxGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s,
              });
            const a = this;
            (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
            const o = [],
              l = [],
              c = [],
              h = [];
            let u = 0,
              d = 0;
            function p(t, e, n, i, r, s, p, f, m, g, _) {
              const v = s / m,
                x = p / g,
                y = s / 2,
                M = p / 2,
                S = f / 2,
                b = m + 1,
                E = g + 1;
              let T = 0,
                A = 0;
              const w = new ae();
              for (let s = 0; s < E; s++) {
                const a = s * x - M;
                for (let o = 0; o < b; o++) {
                  const u = o * v - y;
                  (w[t] = u * i),
                    (w[e] = a * r),
                    (w[n] = S),
                    l.push(w.x, w.y, w.z),
                    (w[t] = 0),
                    (w[e] = 0),
                    (w[n] = f > 0 ? 1 : -1),
                    c.push(w.x, w.y, w.z),
                    h.push(o / m),
                    h.push(1 - s / g),
                    (T += 1);
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < m; e++) {
                  const n = u + e + b * t,
                    i = u + e + b * (t + 1),
                    r = u + (e + 1) + b * (t + 1),
                    s = u + (e + 1) + b * t;
                  o.push(n, i, s), o.push(i, r, s), (A += 6);
                }
              a.addGroup(d, A, _), (d += A), (u += T);
            }
            p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
              p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
              p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
              p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
              p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
              p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
              this.setIndex(o),
              this.setAttribute("position", new Dn(l, 3)),
              this.setAttribute("normal", new Dn(c, 3)),
              this.setAttribute("uv", new Dn(h, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new ci(
              t.width,
              t.height,
              t.depth,
              t.widthSegments,
              t.heightSegments,
              t.depthSegments
            );
          }
        }
        function hi(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
              const r = t[n][i];
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? r.isRenderTargetTexture
                  ? (console.warn(
                      "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                    ),
                    (e[n][i] = null))
                  : (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r);
            }
          }
          return e;
        }
        function ui(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const i = hi(t[n]);
            for (const t in i) e[t] = i[t];
          }
          return e;
        }
        function di(t) {
          return null === t.getRenderTarget() ? t.outputColorSpace : Wt.workingColorSpace;
        }
        const pi = { clone: hi, merge: ui };
        class fi extends Rn {
          constructor(t) {
            super(),
              (this.isShaderMaterial = !0),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.uniformsGroups = []),
              (this.vertexShader =
                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
              (this.fragmentShader =
                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.forceSinglePass = !0),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
                clipCullDistance: !1,
              }),
              (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== t && this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = hi(t.uniforms)),
              (this.uniformsGroups = (function (t) {
                const e = [];
                for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                return e;
              })(t.uniformsGroups)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.fog = t.fog),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const n in this.uniforms) {
              const i = this.uniforms[n].value;
              i && i.isTexture
                ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
                : i && i.isColor
                ? (e.uniforms[n] = { type: "c", value: i.getHex() })
                : i && i.isVector2
                ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
                : i && i.isVector3
                ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
                : i && i.isVector4
                ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
                : i && i.isMatrix3
                ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
                : i && i.isMatrix4
                ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
                : (e.uniforms[n] = { value: i });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader),
              (e.lights = this.lights),
              (e.clipping = this.clipping);
            const n = {};
            for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }
        }
        class mi extends ln {
          constructor() {
            super(),
              (this.isCamera = !0),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new Oe()),
              (this.projectionMatrix = new Oe()),
              (this.projectionMatrixInverse = new Oe()),
              (this.coordinateSystem = gt);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              (this.coordinateSystem = t.coordinateSystem),
              this
            );
          }
          getWorldDirection(t) {
            return super.getWorldDirection(t).negate();
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class gi extends mi {
          constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
            super(),
              (this.isPerspectiveCamera = !0),
              (this.type = "PerspectiveCamera"),
              (this.fov = t),
              (this.zoom = 1),
              (this.near = n),
              (this.far = i),
              (this.focus = 10),
              (this.aspect = e),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          }
          setFocalLength(t) {
            const e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * St * Math.atan(e)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            const t = Math.tan(0.5 * Mt * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          }
          getEffectiveFOV() {
            return 2 * St * Math.atan(Math.tan(0.5 * Mt * this.fov) / this.zoom);
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(t, e, n, i, r, s) {
            (this.aspect = t / e),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = this.near;
            let e = (t * Math.tan(0.5 * Mt * this.fov)) / this.zoom,
              n = 2 * e,
              i = this.aspect * n,
              r = -0.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
              const t = s.fullWidth,
                a = s.fullHeight;
              (r += (s.offsetX * i) / t),
                (e -= (s.offsetY * n) / a),
                (i *= s.width / t),
                (n *= s.height / a);
            }
            const a = this.filmOffset;
            0 !== a && (r += (t * a) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                r,
                r + i,
                e,
                e - n,
                t,
                this.far,
                this.coordinateSystem
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view && (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          }
        }
        const _i = -90;
        class vi extends ln {
          constructor(t, e, n) {
            super(),
              (this.type = "CubeCamera"),
              (this.renderTarget = n),
              (this.coordinateSystem = null),
              (this.activeMipmapLevel = 0);
            const i = new gi(_i, 1, t, e);
            (i.layers = this.layers), this.add(i);
            const r = new gi(_i, 1, t, e);
            (r.layers = this.layers), this.add(r);
            const s = new gi(_i, 1, t, e);
            (s.layers = this.layers), this.add(s);
            const a = new gi(_i, 1, t, e);
            (a.layers = this.layers), this.add(a);
            const o = new gi(_i, 1, t, e);
            (o.layers = this.layers), this.add(o);
            const l = new gi(_i, 1, t, e);
            (l.layers = this.layers), this.add(l);
          }
          updateCoordinateSystem() {
            const t = this.coordinateSystem,
              e = this.children.concat(),
              [n, i, r, s, a, o] = e;
            for (const t of e) this.remove(t);
            if (t === gt)
              n.up.set(0, 1, 0),
                n.lookAt(1, 0, 0),
                i.up.set(0, 1, 0),
                i.lookAt(-1, 0, 0),
                r.up.set(0, 0, -1),
                r.lookAt(0, 1, 0),
                s.up.set(0, 0, 1),
                s.lookAt(0, -1, 0),
                a.up.set(0, 1, 0),
                a.lookAt(0, 0, 1),
                o.up.set(0, 1, 0),
                o.lookAt(0, 0, -1);
            else {
              if (t !== _t)
                throw new Error(
                  "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t
                );
              n.up.set(0, -1, 0),
                n.lookAt(-1, 0, 0),
                i.up.set(0, -1, 0),
                i.lookAt(1, 0, 0),
                r.up.set(0, 0, 1),
                r.lookAt(0, 1, 0),
                s.up.set(0, 0, -1),
                s.lookAt(0, -1, 0),
                a.up.set(0, -1, 0),
                a.lookAt(0, 0, 1),
                o.up.set(0, -1, 0),
                o.lookAt(0, 0, -1);
            }
            for (const t of e) this.add(t), t.updateMatrixWorld();
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const { renderTarget: n, activeMipmapLevel: i } = this;
            this.coordinateSystem !== t.coordinateSystem &&
              ((this.coordinateSystem = t.coordinateSystem), this.updateCoordinateSystem());
            const [r, s, a, o, l, c] = this.children,
              h = t.getRenderTarget(),
              u = t.getActiveCubeFace(),
              d = t.getActiveMipmapLevel(),
              p = t.xr.enabled;
            t.xr.enabled = !1;
            const f = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0, i),
              t.render(e, r),
              t.setRenderTarget(n, 1, i),
              t.render(e, s),
              t.setRenderTarget(n, 2, i),
              t.render(e, a),
              t.setRenderTarget(n, 3, i),
              t.render(e, o),
              t.setRenderTarget(n, 4, i),
              t.render(e, l),
              (n.texture.generateMipmaps = f),
              t.setRenderTarget(n, 5, i),
              t.render(e, c),
              t.setRenderTarget(h, u, d),
              (t.xr.enabled = p),
              (n.texture.needsPMREMUpdate = !0);
          }
        }
        class xi extends $t {
          constructor(t, e, n, i, r, s, a, o, l, c) {
            super((t = void 0 !== t ? t : []), (e = void 0 !== e ? e : M), n, i, r, s, a, o, l, c),
              (this.isCubeTexture = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        class yi extends ne {
          constructor(t = 1, e = {}) {
            super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
            const n = { width: t, height: t, depth: 1 },
              i = [n, n, n, n, n, n];
            void 0 !== e.encoding &&
              (zt(
                "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
              ),
              (e.colorSpace = e.encoding === nt ? rt : it)),
              (this.texture = new xi(
                i,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.colorSpace
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : L);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.colorSpace = e.colorSpace),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = { tEquirect: { value: null } },
              i =
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              r =
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
              s = new ci(5, 5, 5),
              a = new fi({
                name: "CubemapFromEquirect",
                uniforms: hi(n),
                vertexShader: i,
                fragmentShader: r,
                side: 1,
                blending: 0,
              });
            a.uniforms.tEquirect.value = e;
            const o = new oi(s, a),
              l = e.minFilter;
            return (
              e.minFilter === I && (e.minFilter = L),
              new vi(1, 10, this).update(t, o),
              (e.minFilter = l),
              o.geometry.dispose(),
              o.material.dispose(),
              this
            );
          }
          clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r);
          }
        }
        const Mi = new ae(),
          Si = new ae(),
          bi = new Ut();
        class Ei {
          constructor(t = new ae(1, 0, 0), e = 0) {
            (this.isPlane = !0), (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
          }
          setFromCoplanarPoints(t, e, n) {
            const i = Mi.subVectors(n, e).cross(Si.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this;
          }
          copy(t) {
            return this.normal.copy(t.normal), (this.constant = t.constant), this;
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
          }
          intersectLine(t, e) {
            const n = t.delta(Mi),
              i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant);
          }
          applyMatrix4(t, e) {
            const n = e || bi.getNormalMatrix(t),
              i = this.coplanarPoint(Mi).applyMatrix4(t),
              r = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -i.dot(r)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const Ti = new we(),
          Ai = new ae();
        class wi {
          constructor(
            t = new Ei(),
            e = new Ei(),
            n = new Ei(),
            i = new Ei(),
            r = new Ei(),
            s = new Ei()
          ) {
            this.planes = [t, e, n, i, r, s];
          }
          set(t, e, n, i, r, s) {
            const a = this.planes;
            return (
              a[0].copy(t),
              a[1].copy(e),
              a[2].copy(n),
              a[3].copy(i),
              a[4].copy(r),
              a[5].copy(s),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t, e = 2e3) {
            const n = this.planes,
              i = t.elements,
              r = i[0],
              s = i[1],
              a = i[2],
              o = i[3],
              l = i[4],
              c = i[5],
              h = i[6],
              u = i[7],
              d = i[8],
              p = i[9],
              f = i[10],
              m = i[11],
              g = i[12],
              _ = i[13],
              v = i[14],
              x = i[15];
            if (
              (n[0].setComponents(o - r, u - l, m - d, x - g).normalize(),
              n[1].setComponents(o + r, u + l, m + d, x + g).normalize(),
              n[2].setComponents(o + s, u + c, m + p, x + _).normalize(),
              n[3].setComponents(o - s, u - c, m - p, x - _).normalize(),
              n[4].setComponents(o - a, u - h, m - f, x - v).normalize(),
              e === gt)
            )
              n[5].setComponents(o + a, u + h, m + f, x + v).normalize();
            else {
              if (e !== _t)
                throw new Error(
                  "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e
                );
              n[5].setComponents(a, h, f, v).normalize();
            }
            return this;
          }
          intersectsObject(t) {
            if (void 0 !== t.boundingSphere)
              null === t.boundingSphere && t.computeBoundingSphere(),
                Ti.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
            else {
              const e = t.geometry;
              null === e.boundingSphere && e.computeBoundingSphere(),
                Ti.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
            }
            return this.intersectsSphere(Ti);
          }
          intersectsSprite(t) {
            return (
              Ti.center.set(0, 0, 0),
              (Ti.radius = 0.7071067811865476),
              Ti.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Ti)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              i = -t.radius;
            for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1;
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const i = e[n];
              if (
                ((Ai.x = i.normal.x > 0 ? t.max.x : t.min.x),
                (Ai.y = i.normal.y > 0 ? t.max.y : t.min.y),
                (Ai.z = i.normal.z > 0 ? t.max.z : t.min.z),
                i.distanceToPoint(Ai) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function Ri() {
          let t = null,
            e = !1,
            n = null,
            i = null;
          function r(e, s) {
            n(e, s), (i = t.requestAnimationFrame(r));
          }
          return {
            start: function () {
              !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(i), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function Ci(t, e) {
          const n = e.isWebGL2,
            i = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = i.get(e);
              n && (t.deleteBuffer(n.buffer), i.delete(e));
            },
            update: function (e, r) {
              if (e.isGLBufferAttribute) {
                const t = i.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  i.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const s = i.get(e);
              if (void 0 === s)
                i.set(
                  e,
                  (function (e, i) {
                    const r = e.array,
                      s = e.usage,
                      a = r.byteLength,
                      o = t.createBuffer();
                    let l;
                    if (
                      (t.bindBuffer(i, o),
                      t.bufferData(i, r, s),
                      e.onUploadCallback(),
                      r instanceof Float32Array)
                    )
                      l = t.FLOAT;
                    else if (r instanceof Uint16Array)
                      if (e.isFloat16BufferAttribute) {
                        if (!n)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                        l = t.HALF_FLOAT;
                      } else l = t.UNSIGNED_SHORT;
                    else if (r instanceof Int16Array) l = t.SHORT;
                    else if (r instanceof Uint32Array) l = t.UNSIGNED_INT;
                    else if (r instanceof Int32Array) l = t.INT;
                    else if (r instanceof Int8Array) l = t.BYTE;
                    else if (r instanceof Uint8Array) l = t.UNSIGNED_BYTE;
                    else {
                      if (!(r instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " + r
                        );
                      l = t.UNSIGNED_BYTE;
                    }
                    return {
                      buffer: o,
                      type: l,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: e.version,
                      size: a,
                    };
                  })(e, r)
                );
              else if (s.version < e.version) {
                if (s.size !== e.array.byteLength)
                  throw new Error(
                    "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
                  );
                !(function (e, i, r) {
                  const s = i.array,
                    a = i._updateRange,
                    o = i.updateRanges;
                  if (
                    (t.bindBuffer(r, e),
                    -1 === a.count && 0 === o.length && t.bufferSubData(r, 0, s),
                    0 !== o.length)
                  ) {
                    for (let e = 0, i = o.length; e < i; e++) {
                      const i = o[e];
                      n
                        ? t.bufferSubData(r, i.start * s.BYTES_PER_ELEMENT, s, i.start, i.count)
                        : t.bufferSubData(
                            r,
                            i.start * s.BYTES_PER_ELEMENT,
                            s.subarray(i.start, i.start + i.count)
                          );
                    }
                    i.clearUpdateRanges();
                  }
                  -1 !== a.count &&
                    (n
                      ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count)
                      : t.bufferSubData(
                          r,
                          a.offset * s.BYTES_PER_ELEMENT,
                          s.subarray(a.offset, a.offset + a.count)
                        ),
                    (a.count = -1)),
                    i.onUploadCallback();
                })(s.buffer, e, r),
                  (s.version = e.version);
              }
            },
          };
        }
        class Li extends Vn {
          constructor(t = 1, e = 1, n = 1, i = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i });
            const r = t / 2,
              s = e / 2,
              a = Math.floor(n),
              o = Math.floor(i),
              l = a + 1,
              c = o + 1,
              h = t / a,
              u = e / o,
              d = [],
              p = [],
              f = [],
              m = [];
            for (let t = 0; t < c; t++) {
              const e = t * u - s;
              for (let n = 0; n < l; n++) {
                const i = n * h - r;
                p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - t / o);
              }
            }
            for (let t = 0; t < o; t++)
              for (let e = 0; e < a; e++) {
                const n = e + l * t,
                  i = e + l * (t + 1),
                  r = e + 1 + l * (t + 1),
                  s = e + 1 + l * t;
                d.push(n, i, s), d.push(i, r, s);
              }
            this.setIndex(d),
              this.setAttribute("position", new Dn(p, 3)),
              this.setAttribute("normal", new Dn(f, 3)),
              this.setAttribute("uv", new Dn(m, 2));
          }
          copy(t) {
            return super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this;
          }
          static fromJSON(t) {
            return new Li(t.width, t.height, t.widthSegments, t.heightSegments);
          }
        }
        const Pi = {
            alphahash_fragment:
              "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment:
              "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment:
              "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment:
              "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment:
              "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment:
              "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex:
              "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            batching_vertex:
              "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
            begin_vertex:
              "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex:
              "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs:
              "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment:
              "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment:
              "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common:
              "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment:
              "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex:
              "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment:
              "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
            envmap_fragment:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex:
              "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment:
              "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment:
              "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment:
              "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment:
              "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment:
              "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment:
              "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment:
              "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment:
              "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin:
              "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment:
              "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment:
              "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment:
              "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment:
              "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment:
              "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment:
              "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin:
              "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps:
              "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end:
              "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment:
              "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment:
              "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment:
              "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment:
              "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex:
              "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex:
              "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex:
              "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex:
              "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin:
              "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps:
              "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex:
              "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment:
              "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin:
              "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment:
              "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment:
              "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment:
              "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing:
              "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment:
              "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex:
              "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment:
              "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment:
              "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment:
              "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment:
              "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment:
              "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex:
              "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex:
              "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment:
              "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex:
              "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex:
              "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex:
              "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex:
              "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment:
              "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment:
              "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment:
              "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment:
              "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment:
              "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment:
              "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex:
              "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert:
              "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag:
              "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag:
              "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag:
              "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert:
              "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag:
              "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert:
              "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag:
              "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag:
              "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert:
              "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert:
              "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert:
              "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag:
              "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert:
              "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag:
              "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert:
              "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag:
              "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert:
              "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag:
              "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert:
              "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag:
              "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert:
              "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag:
              "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert:
              "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert:
              "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag:
              "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert:
              "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          },
          Ii = {
            common: {
              diffuse: { value: new Tn(16777215) },
              opacity: { value: 1 },
              map: { value: null },
              mapTransform: { value: new Ut() },
              alphaMap: { value: null },
              alphaMapTransform: { value: new Ut() },
              alphaTest: { value: 0 },
            },
            specularmap: {
              specularMap: { value: null },
              specularMapTransform: { value: new Ut() },
            },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              ior: { value: 1.5 },
              refractionRatio: { value: 0.98 },
            },
            aomap: {
              aoMap: { value: null },
              aoMapIntensity: { value: 1 },
              aoMapTransform: { value: new Ut() },
            },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 },
              lightMapTransform: { value: new Ut() },
            },
            bumpmap: {
              bumpMap: { value: null },
              bumpMapTransform: { value: new Ut() },
              bumpScale: { value: 1 },
            },
            normalmap: {
              normalMap: { value: null },
              normalMapTransform: { value: new Ut() },
              normalScale: { value: new It(1, 1) },
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementMapTransform: { value: new Ut() },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 },
            },
            emissivemap: {
              emissiveMap: { value: null },
              emissiveMapTransform: { value: new Ut() },
            },
            metalnessmap: {
              metalnessMap: { value: null },
              metalnessMapTransform: { value: new Ut() },
            },
            roughnessmap: {
              roughnessMap: { value: null },
              roughnessMapTransform: { value: new Ut() },
            },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new Tn(16777215) },
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: { value: [], properties: { direction: {}, color: {} } },
              directionalLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                },
              },
              spotLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              spotLightMap: { value: [] },
              spotShadowMap: { value: [] },
              spotLightMatrix: { value: [] },
              pointLights: {
                value: [],
                properties: { color: {}, position: {}, decay: {}, distance: {} },
              },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {},
                },
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
              },
              rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
              },
              ltc_1: { value: null },
              ltc_2: { value: null },
            },
            points: {
              diffuse: { value: new Tn(16777215) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              alphaMap: { value: null },
              alphaMapTransform: { value: new Ut() },
              alphaTest: { value: 0 },
              uvTransform: { value: new Ut() },
            },
            sprite: {
              diffuse: { value: new Tn(16777215) },
              opacity: { value: 1 },
              center: { value: new It(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              mapTransform: { value: new Ut() },
              alphaMap: { value: null },
              alphaMapTransform: { value: new Ut() },
              alphaTest: { value: 0 },
            },
          },
          Ui = {
            basic: {
              uniforms: ui([Ii.common, Ii.specularmap, Ii.envmap, Ii.aomap, Ii.lightmap, Ii.fog]),
              vertexShader: Pi.meshbasic_vert,
              fragmentShader: Pi.meshbasic_frag,
            },
            lambert: {
              uniforms: ui([
                Ii.common,
                Ii.specularmap,
                Ii.envmap,
                Ii.aomap,
                Ii.lightmap,
                Ii.emissivemap,
                Ii.bumpmap,
                Ii.normalmap,
                Ii.displacementmap,
                Ii.fog,
                Ii.lights,
                { emissive: { value: new Tn(0) } },
              ]),
              vertexShader: Pi.meshlambert_vert,
              fragmentShader: Pi.meshlambert_frag,
            },
            phong: {
              uniforms: ui([
                Ii.common,
                Ii.specularmap,
                Ii.envmap,
                Ii.aomap,
                Ii.lightmap,
                Ii.emissivemap,
                Ii.bumpmap,
                Ii.normalmap,
                Ii.displacementmap,
                Ii.fog,
                Ii.lights,
                {
                  emissive: { value: new Tn(0) },
                  specular: { value: new Tn(1118481) },
                  shininess: { value: 30 },
                },
              ]),
              vertexShader: Pi.meshphong_vert,
              fragmentShader: Pi.meshphong_frag,
            },
            standard: {
              uniforms: ui([
                Ii.common,
                Ii.envmap,
                Ii.aomap,
                Ii.lightmap,
                Ii.emissivemap,
                Ii.bumpmap,
                Ii.normalmap,
                Ii.displacementmap,
                Ii.roughnessmap,
                Ii.metalnessmap,
                Ii.fog,
                Ii.lights,
                {
                  emissive: { value: new Tn(0) },
                  roughness: { value: 1 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 },
                },
              ]),
              vertexShader: Pi.meshphysical_vert,
              fragmentShader: Pi.meshphysical_frag,
            },
            toon: {
              uniforms: ui([
                Ii.common,
                Ii.aomap,
                Ii.lightmap,
                Ii.emissivemap,
                Ii.bumpmap,
                Ii.normalmap,
                Ii.displacementmap,
                Ii.gradientmap,
                Ii.fog,
                Ii.lights,
                { emissive: { value: new Tn(0) } },
              ]),
              vertexShader: Pi.meshtoon_vert,
              fragmentShader: Pi.meshtoon_frag,
            },
            matcap: {
              uniforms: ui([
                Ii.common,
                Ii.bumpmap,
                Ii.normalmap,
                Ii.displacementmap,
                Ii.fog,
                { matcap: { value: null } },
              ]),
              vertexShader: Pi.meshmatcap_vert,
              fragmentShader: Pi.meshmatcap_frag,
            },
            points: {
              uniforms: ui([Ii.points, Ii.fog]),
              vertexShader: Pi.points_vert,
              fragmentShader: Pi.points_frag,
            },
            dashed: {
              uniforms: ui([
                Ii.common,
                Ii.fog,
                { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
              ]),
              vertexShader: Pi.linedashed_vert,
              fragmentShader: Pi.linedashed_frag,
            },
            depth: {
              uniforms: ui([Ii.common, Ii.displacementmap]),
              vertexShader: Pi.depth_vert,
              fragmentShader: Pi.depth_frag,
            },
            normal: {
              uniforms: ui([
                Ii.common,
                Ii.bumpmap,
                Ii.normalmap,
                Ii.displacementmap,
                { opacity: { value: 1 } },
              ]),
              vertexShader: Pi.meshnormal_vert,
              fragmentShader: Pi.meshnormal_frag,
            },
            sprite: {
              uniforms: ui([Ii.sprite, Ii.fog]),
              vertexShader: Pi.sprite_vert,
              fragmentShader: Pi.sprite_frag,
            },
            background: {
              uniforms: {
                uvTransform: { value: new Ut() },
                t2D: { value: null },
                backgroundIntensity: { value: 1 },
              },
              vertexShader: Pi.background_vert,
              fragmentShader: Pi.background_frag,
            },
            backgroundCube: {
              uniforms: {
                envMap: { value: null },
                flipEnvMap: { value: -1 },
                backgroundBlurriness: { value: 0 },
                backgroundIntensity: { value: 1 },
              },
              vertexShader: Pi.backgroundCube_vert,
              fragmentShader: Pi.backgroundCube_frag,
            },
            cube: {
              uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
              vertexShader: Pi.cube_vert,
              fragmentShader: Pi.cube_frag,
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: Pi.equirect_vert,
              fragmentShader: Pi.equirect_frag,
            },
            distanceRGBA: {
              uniforms: ui([
                Ii.common,
                Ii.displacementmap,
                {
                  referencePosition: { value: new ae() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1e3 },
                },
              ]),
              vertexShader: Pi.distanceRGBA_vert,
              fragmentShader: Pi.distanceRGBA_frag,
            },
            shadow: {
              uniforms: ui([
                Ii.lights,
                Ii.fog,
                { color: { value: new Tn(0) }, opacity: { value: 1 } },
              ]),
              vertexShader: Pi.shadow_vert,
              fragmentShader: Pi.shadow_frag,
            },
          };
        Ui.physical = {
          uniforms: ui([
            Ui.standard.uniforms,
            {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatMapTransform: { value: new Ut() },
              clearcoatNormalMap: { value: null },
              clearcoatNormalMapTransform: { value: new Ut() },
              clearcoatNormalScale: { value: new It(1, 1) },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatRoughnessMapTransform: { value: new Ut() },
              iridescence: { value: 0 },
              iridescenceMap: { value: null },
              iridescenceMapTransform: { value: new Ut() },
              iridescenceIOR: { value: 1.3 },
              iridescenceThicknessMinimum: { value: 100 },
              iridescenceThicknessMaximum: { value: 400 },
              iridescenceThicknessMap: { value: null },
              iridescenceThicknessMapTransform: { value: new Ut() },
              sheen: { value: 0 },
              sheenColor: { value: new Tn(0) },
              sheenColorMap: { value: null },
              sheenColorMapTransform: { value: new Ut() },
              sheenRoughness: { value: 1 },
              sheenRoughnessMap: { value: null },
              sheenRoughnessMapTransform: { value: new Ut() },
              transmission: { value: 0 },
              transmissionMap: { value: null },
              transmissionMapTransform: { value: new Ut() },
              transmissionSamplerSize: { value: new It() },
              transmissionSamplerMap: { value: null },
              thickness: { value: 0 },
              thicknessMap: { value: null },
              thicknessMapTransform: { value: new Ut() },
              attenuationDistance: { value: 0 },
              attenuationColor: { value: new Tn(0) },
              specularColor: { value: new Tn(1, 1, 1) },
              specularColorMap: { value: null },
              specularColorMapTransform: { value: new Ut() },
              specularIntensity: { value: 1 },
              specularIntensityMap: { value: null },
              specularIntensityMapTransform: { value: new Ut() },
              anisotropyVector: { value: new It() },
              anisotropyMap: { value: null },
              anisotropyMapTransform: { value: new Ut() },
            },
          ]),
          vertexShader: Pi.meshphysical_vert,
          fragmentShader: Pi.meshphysical_frag,
        };
        const Ni = { r: 0, b: 0, g: 0 };
        function Di(t, e, n, i, r, s, a) {
          const l = new Tn(0);
          let c,
            h,
            u = !0 === s ? 0 : 1,
            d = null,
            p = 0,
            f = null;
          function m(e, n) {
            e.getRGB(Ni, di(t)), i.buffers.color.setClear(Ni.r, Ni.g, Ni.b, n, a);
          }
          return {
            getClearColor: function () {
              return l;
            },
            setClearColor: function (t, e = 1) {
              l.set(t), (u = e), m(l, u);
            },
            getClearAlpha: function () {
              return u;
            },
            setClearAlpha: function (t) {
              (u = t), m(l, u);
            },
            render: function (s, g) {
              let _ = !1,
                v = !0 === g.isScene ? g.background : null;
              v && v.isTexture && (v = (g.backgroundBlurriness > 0 ? n : e).get(v)),
                null === v ? m(l, u) : v && v.isColor && (m(v, 1), (_ = !0));
              const x = t.xr.getEnvironmentBlendMode();
              "additive" === x
                ? i.buffers.color.setClear(0, 0, 0, 1, a)
                : "alpha-blend" === x && i.buffers.color.setClear(0, 0, 0, 0, a),
                (t.autoClear || _) &&
                  t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                v && (v.isCubeTexture || v.mapping === b)
                  ? (void 0 === h &&
                      ((h = new oi(
                        new ci(1, 1, 1),
                        new fi({
                          name: "BackgroundCubeMaterial",
                          uniforms: hi(Ui.backgroundCube.uniforms),
                          vertexShader: Ui.backgroundCube.vertexShader,
                          fragmentShader: Ui.backgroundCube.fragmentShader,
                          side: 1,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      h.geometry.deleteAttribute("normal"),
                      h.geometry.deleteAttribute("uv"),
                      (h.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(h.material, "envMap", {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      r.update(h)),
                    (h.material.uniforms.envMap.value = v),
                    (h.material.uniforms.flipEnvMap.value =
                      v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1),
                    (h.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness),
                    (h.material.uniforms.backgroundIntensity.value = g.backgroundIntensity),
                    (h.material.toneMapped = Wt.getTransfer(v.colorSpace) !== ct),
                    (d === v && p === v.version && f === t.toneMapping) ||
                      ((h.material.needsUpdate = !0),
                      (d = v),
                      (p = v.version),
                      (f = t.toneMapping)),
                    h.layers.enableAll(),
                    s.unshift(h, h.geometry, h.material, 0, 0, null))
                  : v &&
                    v.isTexture &&
                    (void 0 === c &&
                      ((c = new oi(
                        new Li(2, 2),
                        new fi({
                          name: "BackgroundMaterial",
                          uniforms: hi(Ui.background.uniforms),
                          vertexShader: Ui.background.vertexShader,
                          fragmentShader: Ui.background.fragmentShader,
                          side: o,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      c.geometry.deleteAttribute("normal"),
                      Object.defineProperty(c.material, "map", {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      r.update(c)),
                    (c.material.uniforms.t2D.value = v),
                    (c.material.uniforms.backgroundIntensity.value = g.backgroundIntensity),
                    (c.material.toneMapped = Wt.getTransfer(v.colorSpace) !== ct),
                    !0 === v.matrixAutoUpdate && v.updateMatrix(),
                    c.material.uniforms.uvTransform.value.copy(v.matrix),
                    (d === v && p === v.version && f === t.toneMapping) ||
                      ((c.material.needsUpdate = !0),
                      (d = v),
                      (p = v.version),
                      (f = t.toneMapping)),
                    c.layers.enableAll(),
                    s.unshift(c, c.geometry, c.material, 0, 0, null));
            },
          };
        }
        function Oi(t, e, n, i) {
          const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            a = i.isWebGL2 || null !== s,
            o = {},
            l = p(null);
          let c = l,
            h = !1;
          function u(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
          }
          function d(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
          }
          function p(t) {
            const e = [],
              n = [],
              i = [];
            for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: i,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function f() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function m(t) {
            g(t, 0);
          }
          function g(n, r) {
            const s = c.newAttributes,
              a = c.enabledAttributes,
              o = c.attributeDivisors;
            (s[n] = 1),
              0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
              o[n] !== r &&
                ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                  i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
                ](n, r),
                (o[n] = r));
          }
          function _() {
            const e = c.newAttributes,
              n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
              n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
          }
          function v(e, n, i, r, s, a, o) {
            !0 === o
              ? t.vertexAttribIPointer(e, n, i, s, a)
              : t.vertexAttribPointer(e, n, i, r, s, a);
          }
          function x() {
            y(), (h = !0), c !== l && ((c = l), u(c.object));
          }
          function y() {
            (l.geometry = null), (l.program = null), (l.wireframe = !1);
          }
          return {
            setup: function (r, l, d, x, y) {
              let M = !1;
              if (a) {
                const e = (function (e, n, r) {
                  const a = !0 === r.wireframe;
                  let l = o[e.id];
                  void 0 === l && ((l = {}), (o[e.id] = l));
                  let c = l[n.id];
                  void 0 === c && ((c = {}), (l[n.id] = c));
                  let h = c[a];
                  return (
                    void 0 === h &&
                      ((h = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES())),
                      (c[a] = h)),
                    h
                  );
                })(x, d, l);
                c !== e && ((c = e), u(c.object)),
                  (M = (function (t, e, n, i) {
                    const r = c.attributes,
                      s = e.attributes;
                    let a = 0;
                    const o = n.getAttributes();
                    for (const e in o)
                      if (o[e].location >= 0) {
                        const n = r[e];
                        let i = s[e];
                        if (
                          (void 0 === i &&
                            ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix),
                            "instanceColor" === e && t.instanceColor && (i = t.instanceColor)),
                          void 0 === n)
                        )
                          return !0;
                        if (n.attribute !== i) return !0;
                        if (i && n.data !== i.data) return !0;
                        a++;
                      }
                    return c.attributesNum !== a || c.index !== i;
                  })(r, x, d, y)),
                  M &&
                    (function (t, e, n, i) {
                      const r = {},
                        s = e.attributes;
                      let a = 0;
                      const o = n.getAttributes();
                      for (const e in o)
                        if (o[e].location >= 0) {
                          let n = s[e];
                          void 0 === n &&
                            ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix),
                            "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                          const i = {};
                          (i.attribute = n), n && n.data && (i.data = n.data), (r[e] = i), a++;
                        }
                      (c.attributes = r), (c.attributesNum = a), (c.index = i);
                    })(r, x, d, y);
              } else {
                const t = !0 === l.wireframe;
                (c.geometry === x.id && c.program === d.id && c.wireframe === t) ||
                  ((c.geometry = x.id), (c.program = d.id), (c.wireframe = t), (M = !0));
              }
              null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER),
                (M || h) &&
                  ((h = !1),
                  (function (r, s, a, o) {
                    if (
                      !1 === i.isWebGL2 &&
                      (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                      null === e.get("ANGLE_instanced_arrays")
                    )
                      return;
                    f();
                    const l = o.attributes,
                      c = a.getAttributes(),
                      h = s.defaultAttributeValues;
                    for (const e in c) {
                      const s = c[e];
                      if (s.location >= 0) {
                        let a = l[e];
                        if (
                          (void 0 === a &&
                            ("instanceMatrix" === e && r.instanceMatrix && (a = r.instanceMatrix),
                            "instanceColor" === e && r.instanceColor && (a = r.instanceColor)),
                          void 0 !== a)
                        ) {
                          const e = a.normalized,
                            l = a.itemSize,
                            c = n.get(a);
                          if (void 0 === c) continue;
                          const h = c.buffer,
                            u = c.type,
                            d = c.bytesPerElement,
                            p =
                              !0 === i.isWebGL2 &&
                              (u === t.INT || u === t.UNSIGNED_INT || 1013 === a.gpuType);
                          if (a.isInterleavedBufferAttribute) {
                            const n = a.data,
                              i = n.stride,
                              c = a.offset;
                            if (n.isInstancedInterleavedBuffer) {
                              for (let t = 0; t < s.locationSize; t++)
                                g(s.location + t, n.meshPerAttribute);
                              !0 !== r.isInstancedMesh &&
                                void 0 === o._maxInstanceCount &&
                                (o._maxInstanceCount = n.meshPerAttribute * n.count);
                            } else for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                            t.bindBuffer(t.ARRAY_BUFFER, h);
                            for (let t = 0; t < s.locationSize; t++)
                              v(
                                s.location + t,
                                l / s.locationSize,
                                u,
                                e,
                                i * d,
                                (c + (l / s.locationSize) * t) * d,
                                p
                              );
                          } else {
                            if (a.isInstancedBufferAttribute) {
                              for (let t = 0; t < s.locationSize; t++)
                                g(s.location + t, a.meshPerAttribute);
                              !0 !== r.isInstancedMesh &&
                                void 0 === o._maxInstanceCount &&
                                (o._maxInstanceCount = a.meshPerAttribute * a.count);
                            } else for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                            t.bindBuffer(t.ARRAY_BUFFER, h);
                            for (let t = 0; t < s.locationSize; t++)
                              v(
                                s.location + t,
                                l / s.locationSize,
                                u,
                                e,
                                l * d,
                                (l / s.locationSize) * t * d,
                                p
                              );
                          }
                        } else if (void 0 !== h) {
                          const n = h[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(s.location, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(s.location, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(s.location, n);
                                break;
                              default:
                                t.vertexAttrib1fv(s.location, n);
                            }
                        }
                      }
                    }
                    _();
                  })(r, l, d, x),
                  null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer));
            },
            reset: x,
            resetDefaultState: y,
            dispose: function () {
              x();
              for (const t in o) {
                const e = o[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) d(n[t].object), delete n[t];
                  delete e[t];
                }
                delete o[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === o[t.id]) return;
              const e = o[t.id];
              for (const t in e) {
                const n = e[t];
                for (const t in n) d(n[t].object), delete n[t];
                delete e[t];
              }
              delete o[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in o) {
                const n = o[e];
                if (void 0 === n[t.id]) continue;
                const i = n[t.id];
                for (const t in i) d(i[t].object), delete i[t];
                delete n[t.id];
              }
            },
            initAttributes: f,
            enableAttribute: m,
            disableUnusedAttributes: _,
          };
        }
        function Bi(t, e, n, i) {
          const r = i.isWebGL2;
          let s;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.render = function (e, i) {
              t.drawArrays(s, e, i), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, a, o) {
              if (0 === o) return;
              let l, c;
              if (r) (l = t), (c = "drawArraysInstanced");
              else if (
                ((l = e.get("ANGLE_instanced_arrays")),
                (c = "drawArraysInstancedANGLE"),
                null === l)
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              l[c](s, i, a, o), n.update(a, s, o);
            }),
            (this.renderMultiDraw = function (t, i, r) {
              if (0 === r) return;
              const a = e.get("WEBGL_multi_draw");
              if (null === a) for (let e = 0; e < r; e++) this.render(t[e], i[e]);
              else {
                a.multiDrawArraysWEBGL(s, t, 0, i, 0, r);
                let e = 0;
                for (let t = 0; t < r; t++) e += i[t];
                n.update(e, s, 1);
              }
            });
        }
        function Fi(t, e, n) {
          let i;
          function r(e) {
            if ("highp" === e) {
              if (
                t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 &&
                t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0
              )
                return "highp";
              e = "mediump";
            }
            return "mediump" === e &&
              t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 &&
              t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0
              ? "mediump"
              : "lowp";
          }
          const s =
            "undefined" != typeof WebGL2RenderingContext &&
            "WebGL2RenderingContext" === t.constructor.name;
          let a = void 0 !== n.precision ? n.precision : "highp";
          const o = r(a);
          o !== a &&
            (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            (a = o));
          const l = s || e.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            d = t.getParameter(t.MAX_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            g = t.getParameter(t.MAX_VARYING_VECTORS),
            _ = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            v = u > 0,
            x = s || e.has("OES_texture_float");
          return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function () {
              if (void 0 !== i) return i;
              if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else i = 0;
              return i;
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: _,
            vertexTextures: v,
            floatFragmentTextures: x,
            floatVertexTextures: v && x,
            maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
          };
        }
        function zi(t) {
          const e = this;
          let n = null,
            i = 0,
            r = !1,
            s = !1;
          const a = new Ei(),
            o = new Ut(),
            l = { value: null, needsUpdate: !1 };
          function c(t, n, i, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
              if (((c = l.value), !0 !== r || null === c)) {
                const e = i + 4 * s,
                  r = n.matrixWorldInverse;
                o.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                for (let e = 0, n = i; e !== s; ++e, n += 4)
                  a.copy(t[e]).applyMatrix4(r, o), a.normal.toArray(c, n), (c[n + 3] = a.constant);
              }
              (l.value = c), (l.needsUpdate = !0);
            }
            return (e.numPlanes = s), (e.numIntersection = 0), c;
          }
          (this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e) {
              const n = 0 !== t.length || e || 0 !== i || r;
              return (r = e), (i = t.length), n;
            }),
            (this.beginShadows = function () {
              (s = !0), c(null);
            }),
            (this.endShadows = function () {
              s = !1;
            }),
            (this.setGlobalState = function (t, e) {
              n = c(t, e, 0);
            }),
            (this.setState = function (a, o, h) {
              const u = a.clippingPlanes,
                d = a.clipIntersection,
                p = a.clipShadows,
                f = t.get(a);
              if (!r || null === u || 0 === u.length || (s && !p))
                s
                  ? c(null)
                  : (l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
                    (e.numPlanes = i),
                    (e.numIntersection = 0));
              else {
                const t = s ? 0 : i,
                  e = 4 * t;
                let r = f.clippingState || null;
                (l.value = r), (r = c(u, o, e, h));
                for (let t = 0; t !== e; ++t) r[t] = n[t];
                (f.clippingState = r),
                  (this.numIntersection = d ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function Hi(t) {
          let e = new WeakMap();
          function n(t, e) {
            return 303 === e ? (t.mapping = M) : 304 === e && (t.mapping = S), t;
          }
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping;
                if (303 === s || 304 === s) {
                  if (e.has(r)) return n(e.get(r).texture, r.mapping);
                  {
                    const s = r.image;
                    if (s && s.height > 0) {
                      const a = new yi(s.height / 2);
                      return (
                        a.fromEquirectangularTexture(t, r),
                        e.set(r, a),
                        r.addEventListener("dispose", i),
                        n(a.texture, r.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        class Gi extends mi {
          constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
            super(),
              (this.isOrthographicCamera = !0),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = i),
              (this.near = r),
              (this.far = s),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, i, r, s) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2;
            let r = n - t,
              s = n + t,
              a = i + e,
              o = i - e;
            if (null !== this.view && this.view.enabled) {
              const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (r += t * this.view.offsetX),
                (s = r + t * this.view.width),
                (a -= e * this.view.offsetY),
                (o = a - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              r,
              s,
              a,
              o,
              this.near,
              this.far,
              this.coordinateSystem
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view && (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        const ki = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          Vi = new Gi(),
          Wi = new Tn();
        let Xi = null,
          ji = 0,
          qi = 0;
        const Yi = (1 + Math.sqrt(5)) / 2,
          Ki = 1 / Yi,
          Zi = [
            new ae(1, 1, 1),
            new ae(-1, 1, 1),
            new ae(1, 1, -1),
            new ae(-1, 1, -1),
            new ae(0, Yi, Ki),
            new ae(0, Yi, -Ki),
            new ae(Ki, 0, Yi),
            new ae(-Ki, 0, Yi),
            new ae(Yi, Ki, 0),
            new ae(-Yi, Ki, 0),
          ];
        class Ji {
          constructor(t) {
            (this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._lodMax = 0),
              (this._cubeSize = 0),
              (this._lodPlanes = []),
              (this._sizeLods = []),
              (this._sigmas = []),
              (this._blurMaterial = null),
              (this._cubemapMaterial = null),
              (this._equirectMaterial = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(t, e = 0, n = 0.1, i = 100) {
            (Xi = this._renderer.getRenderTarget()),
              (ji = this._renderer.getActiveCubeFace()),
              (qi = this._renderer.getActiveMipmapLevel()),
              this._setSize(256);
            const r = this._allocateTargets();
            return (
              (r.depthBuffer = !0),
              this._sceneToCubeUV(t, n, i, r),
              e > 0 && this._blur(r, 0, 0, e),
              this._applyPMREM(r),
              this._cleanup(r),
              r
            );
          }
          fromEquirectangular(t, e = null) {
            return this._fromTexture(t, e);
          }
          fromCubemap(t, e = null) {
            return this._fromTexture(t, e);
          }
          compileCubemapShader() {
            null === this._cubemapMaterial &&
              ((this._cubemapMaterial = er()), this._compileMaterial(this._cubemapMaterial));
          }
          compileEquirectangularShader() {
            null === this._equirectMaterial &&
              ((this._equirectMaterial = tr()), this._compileMaterial(this._equirectMaterial));
          }
          dispose() {
            this._dispose(),
              null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
              null !== this._equirectMaterial && this._equirectMaterial.dispose();
          }
          _setSize(t) {
            (this._lodMax = Math.floor(Math.log2(t))), (this._cubeSize = Math.pow(2, this._lodMax));
          }
          _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
              null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
            for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
          }
          _cleanup(t) {
            this._renderer.setRenderTarget(Xi, ji, qi),
              (t.scissorTest = !1),
              $i(t, 0, 0, t.width, t.height);
          }
          _fromTexture(t, e) {
            t.mapping === M || t.mapping === S
              ? this._setSize(
                  0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width
                )
              : this._setSize(t.image.width / 4),
              (Xi = this._renderer.getRenderTarget()),
              (ji = this._renderer.getActiveCubeFace()),
              (qi = this._renderer.getActiveMipmapLevel());
            const n = e || this._allocateTargets();
            return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
          }
          _allocateTargets() {
            const t = 3 * Math.max(this._cubeSize, 112),
              e = 4 * this._cubeSize,
              n = {
                magFilter: L,
                minFilter: L,
                generateMipmaps: !1,
                type: B,
                format: z,
                colorSpace: st,
                depthBuffer: !1,
              },
              i = Qi(t, e, n);
            if (
              null === this._pingPongRenderTarget ||
              this._pingPongRenderTarget.width !== t ||
              this._pingPongRenderTarget.height !== e
            ) {
              null !== this._pingPongRenderTarget && this._dispose(),
                (this._pingPongRenderTarget = Qi(t, e, n));
              const { _lodMax: i } = this;
              ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
              } = (function (t) {
                const e = [],
                  n = [],
                  i = [];
                let r = t;
                const s = t - 4 + 1 + ki.length;
                for (let a = 0; a < s; a++) {
                  const s = Math.pow(2, r);
                  n.push(s);
                  let o = 1 / s;
                  a > t - 4 ? (o = ki[a - t + 4 - 1]) : 0 === a && (o = 0), i.push(o);
                  const l = 1 / (s - 2),
                    c = -l,
                    h = 1 + l,
                    u = [c, c, h, c, h, h, c, c, h, h, c, h],
                    d = 6,
                    p = 6,
                    f = 3,
                    m = 2,
                    g = 1,
                    _ = new Float32Array(f * p * d),
                    v = new Float32Array(m * p * d),
                    x = new Float32Array(g * p * d);
                  for (let t = 0; t < d; t++) {
                    const e = ((t % 3) * 2) / 3 - 1,
                      n = t > 2 ? 0 : -1,
                      i = [
                        e,
                        n,
                        0,
                        e + 2 / 3,
                        n,
                        0,
                        e + 2 / 3,
                        n + 1,
                        0,
                        e,
                        n,
                        0,
                        e + 2 / 3,
                        n + 1,
                        0,
                        e,
                        n + 1,
                        0,
                      ];
                    _.set(i, f * p * t), v.set(u, m * p * t);
                    const r = [t, t, t, t, t, t];
                    x.set(r, g * p * t);
                  }
                  const y = new Vn();
                  y.setAttribute("position", new In(_, f)),
                    y.setAttribute("uv", new In(v, m)),
                    y.setAttribute("faceIndex", new In(x, g)),
                    e.push(y),
                    r > 4 && r--;
                }
                return { lodPlanes: e, sizeLods: n, sigmas: i };
              })(i)),
                (this._blurMaterial = (function (t, e, n) {
                  const i = new Float32Array(20),
                    r = new ae(0, 1, 0);
                  return new fi({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: 20,
                      CUBEUV_TEXEL_WIDTH: 1 / e,
                      CUBEUV_TEXEL_HEIGHT: 1 / n,
                      CUBEUV_MAX_MIP: `${t}.0`,
                    },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: i },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: r },
                    },
                    vertexShader:
                      "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader:
                      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                })(i, t, e));
            }
            return i;
          }
          _compileMaterial(t) {
            const e = new oi(this._lodPlanes[0], t);
            this._renderer.compile(e, Vi);
          }
          _sceneToCubeUV(t, e, n, i) {
            const r = new gi(90, 1, e, n),
              s = [1, -1, 1, 1, 1, 1],
              a = [1, 1, 1, -1, -1, -1],
              o = this._renderer,
              l = o.autoClear,
              c = o.toneMapping;
            o.getClearColor(Wi), (o.toneMapping = p), (o.autoClear = !1);
            const h = new Cn({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }),
              u = new oi(new ci(), h);
            let d = !1;
            const f = t.background;
            f
              ? f.isColor && (h.color.copy(f), (t.background = null), (d = !0))
              : (h.color.copy(Wi), (d = !0));
            for (let e = 0; e < 6; e++) {
              const n = e % 3;
              0 === n
                ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
                : 1 === n
                ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
                : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e]));
              const l = this._cubeSize;
              $i(i, n * l, e > 2 ? l : 0, l, l),
                o.setRenderTarget(i),
                d && o.render(u, r),
                o.render(t, r);
            }
            u.geometry.dispose(),
              u.material.dispose(),
              (o.toneMapping = c),
              (o.autoClear = l),
              (t.background = f);
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer,
              i = t.mapping === M || t.mapping === S;
            i
              ? (null === this._cubemapMaterial && (this._cubemapMaterial = er()),
                (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  !1 === t.isRenderTargetTexture ? -1 : 1))
              : null === this._equirectMaterial && (this._equirectMaterial = tr());
            const r = i ? this._cubemapMaterial : this._equirectMaterial,
              s = new oi(this._lodPlanes[0], r);
            r.uniforms.envMap.value = t;
            const a = this._cubeSize;
            $i(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, Vi);
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < this._lodPlanes.length; e++) {
              const n = Math.sqrt(
                  this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]
                ),
                i = Zi[(e - 1) % Zi.length];
              this._blur(t, e - 1, e, n, i);
            }
            e.autoClear = n;
          }
          _blur(t, e, n, i, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(t, s, e, n, i, "latitudinal", r),
              this._halfBlur(s, t, n, n, i, "longitudinal", r);
          }
          _halfBlur(t, e, n, i, r, s, a) {
            const o = this._renderer,
              l = this._blurMaterial;
            "latitudinal" !== s &&
              "longitudinal" !== s &&
              console.error("blur direction must be either latitudinal or longitudinal!");
            const c = new oi(this._lodPlanes[i], l),
              h = l.uniforms,
              u = this._sizeLods[n] - 1,
              d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
              p = r / d,
              f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 &&
              console.warn(
                `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
              );
            const m = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
              const e = t / p,
                n = Math.exp((-e * e) / 2);
              m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
            }
            for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
            (h.envMap.value = t.texture),
              (h.samples.value = f),
              (h.weights.value = m),
              (h.latitudinal.value = "latitudinal" === s),
              a && (h.poleAxis.value = a);
            const { _lodMax: _ } = this;
            (h.dTheta.value = d), (h.mipInt.value = _ - n);
            const v = this._sizeLods[i];
            $i(e, 3 * v * (i > _ - 4 ? i - _ + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v),
              o.setRenderTarget(e),
              o.render(c, Vi);
          }
        }
        function Qi(t, e, n) {
          const i = new ne(t, e, n);
          return (
            (i.texture.mapping = b), (i.texture.name = "PMREM.cubeUv"), (i.scissorTest = !0), i
          );
        }
        function $i(t, e, n, i, r) {
          t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
        }
        function tr() {
          return new fi({
            name: "EquirectangularToCubeUV",
            uniforms: { envMap: { value: null } },
            vertexShader:
              "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function er() {
          return new fi({
            name: "CubemapToCubeUV",
            uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
            vertexShader:
              "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function nr(t) {
          let e = new WeakMap(),
            n = null;
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping,
                  a = 303 === s || 304 === s,
                  o = s === M || s === S;
                if (a || o) {
                  if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                    r.needsPMREMUpdate = !1;
                    let i = e.get(r);
                    return (
                      null === n && (n = new Ji(t)),
                      (i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                      e.set(r, i),
                      i.texture
                    );
                  }
                  if (e.has(r)) return e.get(r).texture;
                  {
                    const s = r.image;
                    if (
                      (a && s && s.height > 0) ||
                      (o &&
                        s &&
                        (function (t) {
                          let e = 0;
                          for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                          return 6 === e;
                        })(s))
                    ) {
                      null === n && (n = new Ji(t));
                      const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                      return e.set(r, s), r.addEventListener("dispose", i), s.texture;
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
            },
          };
        }
        function ir(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let i;
            switch (n) {
              case "WEBGL_depth_texture":
                i =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                i =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                i =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                i =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                i = t.getExtension(n);
            }
            return (e[n] = i), i;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"))
                : (n("WEBGL_depth_texture"),
                  n("OES_texture_float"),
                  n("OES_texture_half_float"),
                  n("OES_texture_half_float_linear"),
                  n("OES_standard_derivatives"),
                  n("OES_element_index_uint"),
                  n("OES_vertex_array_object"),
                  n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float"),
                n("WEBGL_multisampled_render_to_texture");
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                  console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                e
              );
            },
          };
        }
        function rr(t, e, n, i) {
          const r = {},
            s = new WeakMap();
          function a(t) {
            const o = t.target;
            null !== o.index && e.remove(o.index);
            for (const t in o.attributes) e.remove(o.attributes[t]);
            for (const t in o.morphAttributes) {
              const n = o.morphAttributes[t];
              for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
            }
            o.removeEventListener("dispose", a), delete r[o.id];
            const l = s.get(o);
            l && (e.remove(l), s.delete(o)),
              i.releaseStatesOfGeometry(o),
              !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
              n.memory.geometries--;
          }
          function o(t) {
            const n = [],
              i = t.index,
              r = t.attributes.position;
            let a = 0;
            if (null !== i) {
              const t = i.array;
              a = i.version;
              for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                  r = t[e + 1],
                  s = t[e + 2];
                n.push(i, r, r, s, s, i);
              }
            } else {
              if (void 0 === r) return;
              {
                const t = r.array;
                a = r.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                  const t = e + 0,
                    i = e + 1,
                    r = e + 2;
                  n.push(t, i, i, r, r, t);
                }
              }
            }
            const o = new (Dt(n) ? Nn : Un)(n, 1);
            o.version = a;
            const l = s.get(t);
            l && e.remove(l), s.set(t, o);
          }
          return {
            get: function (t, e) {
              return (
                !0 === r[e.id] ||
                  (e.addEventListener("dispose", a), (r[e.id] = !0), n.memory.geometries++),
                e
              );
            },
            update: function (n) {
              const i = n.attributes;
              for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
              const r = n.morphAttributes;
              for (const n in r) {
                const i = r[n];
                for (let n = 0, r = i.length; n < r; n++) e.update(i[n], t.ARRAY_BUFFER);
              }
            },
            getWireframeAttribute: function (t) {
              const e = s.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && o(t);
              } else o(t);
              return s.get(t);
            },
          };
        }
        function sr(t, e, n, i) {
          const r = i.isWebGL2;
          let s, a, o;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.setIndex = function (t) {
              (a = t.type), (o = t.bytesPerElement);
            }),
            (this.render = function (e, i) {
              t.drawElements(s, i, a, e * o), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, l, c) {
              if (0 === c) return;
              let h, u;
              if (r) (h = t), (u = "drawElementsInstanced");
              else if (
                ((h = e.get("ANGLE_instanced_arrays")),
                (u = "drawElementsInstancedANGLE"),
                null === h)
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              h[u](s, l, a, i * o, c), n.update(l, s, c);
            }),
            (this.renderMultiDraw = function (t, i, r) {
              if (0 === r) return;
              const l = e.get("WEBGL_multi_draw");
              if (null === l) for (let e = 0; e < r; e++) this.render(t[e] / o, i[e]);
              else {
                l.multiDrawElementsWEBGL(s, i, 0, a, t, 0, r);
                let e = 0;
                for (let t = 0; t < r; t++) e += i[t];
                n.update(e, s, 1);
              }
            });
        }
        function ar(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
            },
            update: function (n, i, r) {
              switch ((e.calls++, i)) {
                case t.TRIANGLES:
                  e.triangles += r * (n / 3);
                  break;
                case t.LINES:
                  e.lines += r * (n / 2);
                  break;
                case t.LINE_STRIP:
                  e.lines += r * (n - 1);
                  break;
                case t.LINE_LOOP:
                  e.lines += r * n;
                  break;
                case t.POINTS:
                  e.points += r * n;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", i);
              }
            },
          };
        }
        function or(t, e) {
          return t[0] - e[0];
        }
        function lr(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function cr(t, e, n) {
          const i = {},
            r = new Float32Array(8),
            s = new WeakMap(),
            a = new te(),
            o = [];
          for (let t = 0; t < 8; t++) o[t] = [t, 0];
          return {
            update: function (l, c, h) {
              const u = l.morphTargetInfluences;
              if (!0 === e.isWebGL2) {
                const d =
                    c.morphAttributes.position ||
                    c.morphAttributes.normal ||
                    c.morphAttributes.color,
                  p = void 0 !== d ? d.length : 0;
                let f = s.get(c);
                if (void 0 === f || f.count !== p) {
                  void 0 !== f && f.texture.dispose();
                  const _ = void 0 !== c.morphAttributes.position,
                    v = void 0 !== c.morphAttributes.normal,
                    x = void 0 !== c.morphAttributes.color,
                    y = c.morphAttributes.position || [],
                    M = c.morphAttributes.normal || [],
                    S = c.morphAttributes.color || [];
                  let b = 0;
                  !0 === _ && (b = 1), !0 === v && (b = 2), !0 === x && (b = 3);
                  let E = c.attributes.position.count * b,
                    T = 1;
                  E > e.maxTextureSize &&
                    ((T = Math.ceil(E / e.maxTextureSize)), (E = e.maxTextureSize));
                  const A = new Float32Array(E * T * 4 * p),
                    w = new ie(A, E, T, p);
                  (w.type = O), (w.needsUpdate = !0);
                  const R = 4 * b;
                  for (let L = 0; L < p; L++) {
                    const P = y[L],
                      I = M[L],
                      U = S[L],
                      N = E * T * 4 * L;
                    for (let D = 0; D < P.count; D++) {
                      const B = D * R;
                      !0 === _ &&
                        (a.fromBufferAttribute(P, D),
                        (A[N + B + 0] = a.x),
                        (A[N + B + 1] = a.y),
                        (A[N + B + 2] = a.z),
                        (A[N + B + 3] = 0)),
                        !0 === v &&
                          (a.fromBufferAttribute(I, D),
                          (A[N + B + 4] = a.x),
                          (A[N + B + 5] = a.y),
                          (A[N + B + 6] = a.z),
                          (A[N + B + 7] = 0)),
                        !0 === x &&
                          (a.fromBufferAttribute(U, D),
                          (A[N + B + 8] = a.x),
                          (A[N + B + 9] = a.y),
                          (A[N + B + 10] = a.z),
                          (A[N + B + 11] = 4 === U.itemSize ? a.w : 1));
                    }
                  }
                  function C() {
                    w.dispose(), s.delete(c), c.removeEventListener("dispose", C);
                  }
                  (f = { count: p, texture: w, size: new It(E, T) }),
                    s.set(c, f),
                    c.addEventListener("dispose", C);
                }
                let m = 0;
                for (let F = 0; F < u.length; F++) m += u[F];
                const g = c.morphTargetsRelative ? 1 : 1 - m;
                h.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
                  h.getUniforms().setValue(t, "morphTargetInfluences", u),
                  h.getUniforms().setValue(t, "morphTargetsTexture", f.texture, n),
                  h.getUniforms().setValue(t, "morphTargetsTextureSize", f.size);
              } else {
                const z = void 0 === u ? 0 : u.length;
                let H = i[c.id];
                if (void 0 === H || H.length !== z) {
                  H = [];
                  for (let X = 0; X < z; X++) H[X] = [X, 0];
                  i[c.id] = H;
                }
                for (let j = 0; j < z; j++) {
                  const q = H[j];
                  (q[0] = j), (q[1] = u[j]);
                }
                H.sort(lr);
                for (let Y = 0; Y < 8; Y++)
                  Y < z && H[Y][1]
                    ? ((o[Y][0] = H[Y][0]), (o[Y][1] = H[Y][1]))
                    : ((o[Y][0] = Number.MAX_SAFE_INTEGER), (o[Y][1] = 0));
                o.sort(or);
                const G = c.morphAttributes.position,
                  k = c.morphAttributes.normal;
                let V = 0;
                for (let K = 0; K < 8; K++) {
                  const Z = o[K],
                    J = Z[0],
                    Q = Z[1];
                  J !== Number.MAX_SAFE_INTEGER && Q
                    ? (G &&
                        c.getAttribute("morphTarget" + K) !== G[J] &&
                        c.setAttribute("morphTarget" + K, G[J]),
                      k &&
                        c.getAttribute("morphNormal" + K) !== k[J] &&
                        c.setAttribute("morphNormal" + K, k[J]),
                      (r[K] = Q),
                      (V += Q))
                    : (G &&
                        !0 === c.hasAttribute("morphTarget" + K) &&
                        c.deleteAttribute("morphTarget" + K),
                      k &&
                        !0 === c.hasAttribute("morphNormal" + K) &&
                        c.deleteAttribute("morphNormal" + K),
                      (r[K] = 0));
                }
                const W = c.morphTargetsRelative ? 1 : 1 - V;
                h.getUniforms().setValue(t, "morphTargetBaseInfluence", W),
                  h.getUniforms().setValue(t, "morphTargetInfluences", r);
              }
            },
          };
        }
        function hr(t, e, n, i) {
          let r = new WeakMap();
          function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (a) {
              const o = i.render.frame,
                l = a.geometry,
                c = e.get(a, l);
              if (
                (r.get(c) !== o && (e.update(c), r.set(c, o)),
                a.isInstancedMesh &&
                  (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s),
                  r.get(a) !== o &&
                    (n.update(a.instanceMatrix, t.ARRAY_BUFFER),
                    null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER),
                    r.set(a, o))),
                a.isSkinnedMesh)
              ) {
                const t = a.skeleton;
                r.get(t) !== o && (t.update(), r.set(t, o));
              }
              return c;
            },
            dispose: function () {
              r = new WeakMap();
            },
          };
        }
        class ur extends $t {
          constructor(t, e, n, i, r, s, a, o, l, c) {
            if ((c = void 0 !== c ? c : H) !== H && c !== G)
              throw new Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            void 0 === n && c === H && (n = D),
              void 0 === n && c === G && (n = F),
              super(null, i, r, s, a, o, c, n, l),
              (this.isDepthTexture = !0),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== a ? a : w),
              (this.minFilter = void 0 !== o ? o : w),
              (this.flipY = !1),
              (this.generateMipmaps = !1),
              (this.compareFunction = null);
          }
          copy(t) {
            return super.copy(t), (this.compareFunction = t.compareFunction), this;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e;
          }
        }
        const dr = new $t(),
          pr = new ur(1, 1);
        pr.compareFunction = 515;
        const fr = new ie(),
          mr = new re(),
          gr = new xi(),
          _r = [],
          vr = [],
          xr = new Float32Array(16),
          yr = new Float32Array(9),
          Mr = new Float32Array(4);
        function Sr(t, e, n) {
          const i = t[0];
          if (i <= 0 || i > 0) return t;
          const r = e * n;
          let s = _r[r];
          if ((void 0 === s && ((s = new Float32Array(r)), (_r[r] = s)), 0 !== e)) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
          }
          return s;
        }
        function br(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
          return !0;
        }
        function Er(t, e) {
          for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
        }
        function Tr(t, e) {
          let n = vr[e];
          void 0 === n && ((n = new Int32Array(e)), (vr[e] = n));
          for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
          return n;
        }
        function Ar(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function wr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (br(n, e)) return;
            t.uniform2fv(this.addr, e), Er(n, e);
          }
        }
        function Rr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b), (n[0] = e.r), (n[1] = e.g), (n[2] = e.b));
          else {
            if (br(n, e)) return;
            t.uniform3fv(this.addr, e), Er(n, e);
          }
        }
        function Cr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (br(n, e)) return;
            t.uniform4fv(this.addr, e), Er(n, e);
          }
        }
        function Lr(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (br(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), Er(n, e);
          } else {
            if (br(n, i)) return;
            Mr.set(i), t.uniformMatrix2fv(this.addr, !1, Mr), Er(n, i);
          }
        }
        function Pr(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (br(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), Er(n, e);
          } else {
            if (br(n, i)) return;
            yr.set(i), t.uniformMatrix3fv(this.addr, !1, yr), Er(n, i);
          }
        }
        function Ir(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (br(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), Er(n, e);
          } else {
            if (br(n, i)) return;
            xr.set(i), t.uniformMatrix4fv(this.addr, !1, xr), Er(n, i);
          }
        }
        function Ur(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function Nr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (br(n, e)) return;
            t.uniform2iv(this.addr, e), Er(n, e);
          }
        }
        function Dr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3i(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
          else {
            if (br(n, e)) return;
            t.uniform3iv(this.addr, e), Er(n, e);
          }
        }
        function Or(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (br(n, e)) return;
            t.uniform4iv(this.addr, e), Er(n, e);
          }
        }
        function Br(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function Fr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (br(n, e)) return;
            t.uniform2uiv(this.addr, e), Er(n, e);
          }
        }
        function zr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3ui(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
          else {
            if (br(n, e)) return;
            t.uniform3uiv(this.addr, e), Er(n, e);
          }
        }
        function Hr(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (br(n, e)) return;
            t.uniform4uiv(this.addr, e), Er(n, e);
          }
        }
        function Gr(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r));
          const s = this.type === t.SAMPLER_2D_SHADOW ? pr : dr;
          n.setTexture2D(e || s, r);
        }
        function kr(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture3D(e || mr, r);
        }
        function Vr(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTextureCube(e || gr, r);
        }
        function Wr(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture2DArray(e || fr, r);
        }
        function Xr(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function jr(t, e) {
          const n = Sr(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function qr(t, e) {
          const n = Sr(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function Yr(t, e) {
          const n = Sr(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function Kr(t, e) {
          const n = Sr(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function Zr(t, e) {
          const n = Sr(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function Jr(t, e) {
          const n = Sr(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function Qr(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function $r(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function ts(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function es(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function ns(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function is(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function rs(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function ss(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function as(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = Tr(n, r);
          br(i, s) || (t.uniform1iv(this.addr, s), Er(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || dr, s[t]);
        }
        function os(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = Tr(n, r);
          br(i, s) || (t.uniform1iv(this.addr, s), Er(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || mr, s[t]);
        }
        function ls(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = Tr(n, r);
          br(i, s) || (t.uniform1iv(this.addr, s), Er(i, s));
          for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || gr, s[t]);
        }
        function cs(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = Tr(n, r);
          br(i, s) || (t.uniform1iv(this.addr, s), Er(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || fr, s[t]);
        }
        class hs {
          constructor(t, e, n) {
            (this.id = t),
              (this.addr = n),
              (this.cache = []),
              (this.type = e.type),
              (this.setValue = (function (t) {
                switch (t) {
                  case 5126:
                    return Ar;
                  case 35664:
                    return wr;
                  case 35665:
                    return Rr;
                  case 35666:
                    return Cr;
                  case 35674:
                    return Lr;
                  case 35675:
                    return Pr;
                  case 35676:
                    return Ir;
                  case 5124:
                  case 35670:
                    return Ur;
                  case 35667:
                  case 35671:
                    return Nr;
                  case 35668:
                  case 35672:
                    return Dr;
                  case 35669:
                  case 35673:
                    return Or;
                  case 5125:
                    return Br;
                  case 36294:
                    return Fr;
                  case 36295:
                    return zr;
                  case 36296:
                    return Hr;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return Gr;
                  case 35679:
                  case 36299:
                  case 36307:
                    return kr;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return Vr;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Wr;
                }
              })(e.type));
          }
        }
        class us {
          constructor(t, e, n) {
            (this.id = t),
              (this.addr = n),
              (this.cache = []),
              (this.type = e.type),
              (this.size = e.size),
              (this.setValue = (function (t) {
                switch (t) {
                  case 5126:
                    return Xr;
                  case 35664:
                    return jr;
                  case 35665:
                    return qr;
                  case 35666:
                    return Yr;
                  case 35674:
                    return Kr;
                  case 35675:
                    return Zr;
                  case 35676:
                    return Jr;
                  case 5124:
                  case 35670:
                    return Qr;
                  case 35667:
                  case 35671:
                    return $r;
                  case 35668:
                  case 35672:
                    return ts;
                  case 35669:
                  case 35673:
                    return es;
                  case 5125:
                    return ns;
                  case 36294:
                    return is;
                  case 36295:
                    return rs;
                  case 36296:
                    return ss;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return as;
                  case 35679:
                  case 36299:
                  case 36307:
                    return os;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return ls;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return cs;
                }
              })(e.type));
          }
        }
        class ds {
          constructor(t) {
            (this.id = t), (this.seq = []), (this.map = {});
          }
          setValue(t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
              const s = i[r];
              s.setValue(t, e[s.id], n);
            }
          }
        }
        const ps = /(\w+)(\])?(\[|\.)?/g;
        function fs(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function ms(t, e, n) {
          const i = t.name,
            r = i.length;
          for (ps.lastIndex = 0; ; ) {
            const s = ps.exec(i),
              a = ps.lastIndex;
            let o = s[1];
            const l = "]" === s[2],
              c = s[3];
            if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
              fs(n, void 0 === c ? new hs(o, t, e) : new us(o, t, e));
              break;
            }
            {
              let t = n.map[o];
              void 0 === t && ((t = new ds(o)), fs(n, t)), (n = t);
            }
          }
        }
        class gs {
          constructor(t, e) {
            (this.seq = []), (this.map = {});
            const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
              const n = t.getActiveUniform(e, i);
              ms(n, t.getUniformLocation(e, n.name), this);
            }
          }
          setValue(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i);
          }
          setOptional(t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i);
          }
          static upload(t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
              const s = e[r],
                a = n[s.id];
              !1 !== a.needsUpdate && s.setValue(t, a.value, i);
            }
          }
          static seqWithValue(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
              const r = t[i];
              r.id in e && n.push(r);
            }
            return n;
          }
        }
        function _s(t, e, n) {
          const i = t.createShader(e);
          return t.shaderSource(i, n), t.compileShader(i), i;
        }
        const vs = 37297;
        let xs = 0;
        function ys(t, e, n) {
          const i = t.getShaderParameter(e, t.COMPILE_STATUS),
            r = t.getShaderInfoLog(e).trim();
          if (i && "" === r) return "";
          const s = /ERROR: 0:(\d+)/.exec(r);
          if (s) {
            const i = parseInt(s[1]);
            return (
              n.toUpperCase() +
              "\n\n" +
              r +
              "\n\n" +
              (function (t, e) {
                const n = t.split("\n"),
                  i = [],
                  r = Math.max(e - 6, 0),
                  s = Math.min(e + 6, n.length);
                for (let t = r; t < s; t++) {
                  const r = t + 1;
                  i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
                }
                return i.join("\n");
              })(t.getShaderSource(e), i)
            );
          }
          return r;
        }
        function Ms(t, e) {
          const n = (function (t) {
            const e = Wt.getPrimaries(Wt.workingColorSpace),
              n = Wt.getPrimaries(t);
            let i;
            switch (
              (e === n
                ? (i = "")
                : e === ut && n === ht
                ? (i = "LinearDisplayP3ToLinearSRGB")
                : e === ht && n === ut && (i = "LinearSRGBToLinearDisplayP3"),
              t)
            ) {
              case st:
              case ot:
                return [i, "LinearTransferOETF"];
              case rt:
              case at:
                return [i, "sRGBTransferOETF"];
              default:
                return (
                  console.warn("THREE.WebGLProgram: Unsupported color space:", t),
                  [i, "LinearTransferOETF"]
                );
            }
          })(e);
          return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
        }
        function Ss(t, e) {
          let n;
          switch (e) {
            case f:
              n = "Linear";
              break;
            case m:
              n = "Reinhard";
              break;
            case g:
              n = "OptimizedCineon";
              break;
            case _:
              n = "ACESFilmic";
              break;
            case x:
              n = "AgX";
              break;
            case v:
              n = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), (n = "Linear");
          }
          return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
        }
        function bs(t) {
          return "" !== t;
        }
        function Es(t, e) {
          const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
            .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function Ts(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
        }
        const As = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function ws(t) {
          return t.replace(As, Cs);
        }
        const Rs = new Map([
          ["encodings_fragment", "colorspace_fragment"],
          ["encodings_pars_fragment", "colorspace_pars_fragment"],
          ["output_fragment", "opaque_fragment"],
        ]);
        function Cs(t, e) {
          let n = Pi[e];
          if (void 0 === n) {
            const t = Rs.get(e);
            if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
            (n = Pi[t]),
              console.warn(
                'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
                e,
                t
              );
          }
          return ws(n);
        }
        const Ls =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function Ps(t) {
          return t.replace(Ls, Is);
        }
        function Is(t, e, n, i) {
          let r = "";
          for (let t = parseInt(e); t < parseInt(n); t++)
            r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
          return r;
        }
        function Us(t) {
          let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
          return (
            "highp" === t.precision
              ? (e += "\n#define HIGH_PRECISION")
              : "mediump" === t.precision
              ? (e += "\n#define MEDIUM_PRECISION")
              : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
          );
        }
        function Ns(t, e, n, i) {
          const o = t.getContext(),
            l = n.defines;
          let c = n.vertexShader,
            f = n.fragmentShader;
          const m = (function (t) {
              let e = "SHADOWMAP_TYPE_BASIC";
              return (
                t.shadowMapType === r
                  ? (e = "SHADOWMAP_TYPE_PCF")
                  : t.shadowMapType === s
                  ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                  : t.shadowMapType === a && (e = "SHADOWMAP_TYPE_VSM"),
                e
              );
            })(n),
            g = (function (t) {
              let e = "ENVMAP_TYPE_CUBE";
              if (t.envMap)
                switch (t.envMapMode) {
                  case M:
                  case S:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                  case b:
                    e = "ENVMAP_TYPE_CUBE_UV";
                }
              return e;
            })(n),
            _ = (function (t) {
              let e = "ENVMAP_MODE_REFLECTION";
              return t.envMap && t.envMapMode === S && (e = "ENVMAP_MODE_REFRACTION"), e;
            })(n),
            v = (function (t) {
              let e = "ENVMAP_BLENDING_NONE";
              if (t.envMap)
                switch (t.combine) {
                  case h:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                  case u:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                  case d:
                    e = "ENVMAP_BLENDING_ADD";
                }
              return e;
            })(n),
            x = (function (t) {
              const e = t.envMapCubeUVHeight;
              if (null === e) return null;
              const n = Math.log2(e) - 2,
                i = 1 / e;
              return {
                texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                texelHeight: i,
                maxMip: n,
              };
            })(n),
            y = n.isWebGL2
              ? ""
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUVHeight ||
                    t.bumpMap ||
                    t.normalMapTangentSpace ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    "physical" === t.shaderID
                      ? "#extension GL_OES_standard_derivatives : enable"
                      : "",
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? "#extension GL_EXT_frag_depth : enable"
                      : "",
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? "#extension GL_EXT_draw_buffers : require"
                      : "",
                    (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                    t.rendererExtensionShaderTextureLod
                      ? "#extension GL_EXT_shader_texture_lod : enable"
                      : "",
                  ]
                    .filter(bs)
                    .join("\n");
                })(n),
            E = (function (t) {
              return [
                t.extensionClipCullDistance
                  ? "#extension GL_ANGLE_clip_cull_distance : require"
                  : "",
              ]
                .filter(bs)
                .join("\n");
            })(n),
            T = (function (t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i);
              }
              return e.join("\n");
            })(l),
            A = o.createProgram();
          let w,
            R,
            C = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
          n.isRawShaderMaterial
            ? ((w = [
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                T,
              ]
                .filter(bs)
                .join("\n")),
              w.length > 0 && (w += "\n"),
              (R = [
                y,
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                T,
              ]
                .filter(bs)
                .join("\n")),
              R.length > 0 && (R += "\n"))
            : ((w = [
                Us(n),
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                T,
                n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
                n.batching ? "#define USE_BATCHING" : "",
                n.instancing ? "#define USE_INSTANCING" : "",
                n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + _ : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
                n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
                n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.anisotropy ? "#define USE_ANISOTROPY" : "",
                n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaHash ? "#define USE_ALPHAHASH" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                n.mapUv ? "#define MAP_UV " + n.mapUv : "",
                n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
                n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
                n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
                n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
                n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
                n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
                n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
                n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
                n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
                n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
                n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
                n.clearcoatNormalMapUv
                  ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
                  : "",
                n.clearcoatRoughnessMapUv
                  ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
                  : "",
                n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
                n.iridescenceThicknessMapUv
                  ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
                  : "",
                n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
                n.sheenRoughnessMapUv
                  ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
                  : "",
                n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
                n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
                n.specularIntensityMapUv
                  ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
                  : "",
                n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
                n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
                n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUv1s ? "#define USE_UV1" : "",
                n.vertexUv2s ? "#define USE_UV2" : "",
                n.vertexUv3s ? "#define USE_UV3" : "",
                n.pointsUvs ? "#define USE_POINTS_UV" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.skinning ? "#define USE_SKINNING" : "",
                n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "",
                n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
                n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                  : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                  : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + m : "",
                n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
                n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                "#ifdef USE_INSTANCING",
                "\tattribute mat4 instanceMatrix;",
                "#endif",
                "#ifdef USE_INSTANCING_COLOR",
                "\tattribute vec3 instanceColor;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_UV1",
                "\tattribute vec2 uv1;",
                "#endif",
                "#ifdef USE_UV2",
                "\tattribute vec2 uv2;",
                "#endif",
                "#ifdef USE_UV3",
                "\tattribute vec2 uv3;",
                "#endif",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#if defined( USE_COLOR_ALPHA )",
                "\tattribute vec4 color;",
                "#elif defined( USE_COLOR )",
                "\tattribute vec3 color;",
                "#endif",
                "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(bs)
                .join("\n")),
              (R = [
                y,
                Us(n),
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                T,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + g : "",
                n.envMap ? "#define " + _ : "",
                n.envMap ? "#define " + v : "",
                x ? "#define CUBEUV_TEXEL_WIDTH " + x.texelWidth : "",
                x ? "#define CUBEUV_TEXEL_HEIGHT " + x.texelHeight : "",
                x ? "#define CUBEUV_MAX_MIP " + x.maxMip + ".0" : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
                n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.anisotropy ? "#define USE_ANISOTROPY" : "",
                n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                n.clearcoat ? "#define USE_CLEARCOAT" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.iridescence ? "#define USE_IRIDESCENCE" : "",
                n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaTest ? "#define USE_ALPHATEST" : "",
                n.alphaHash ? "#define USE_ALPHAHASH" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
                n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUv1s ? "#define USE_UV1" : "",
                n.vertexUv2s ? "#define USE_UV2" : "",
                n.vertexUv3s ? "#define USE_UV3" : "",
                n.pointsUvs ? "#define USE_POINTS_UV" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + m : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
                n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                n.toneMapping !== p ? "#define TONE_MAPPING" : "",
                n.toneMapping !== p ? Pi.tonemapping_pars_fragment : "",
                n.toneMapping !== p ? Ss("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                n.opaque ? "#define OPAQUE" : "",
                Pi.colorspace_pars_fragment,
                Ms("linearToOutputTexel", n.outputColorSpace),
                n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
                "\n",
              ]
                .filter(bs)
                .join("\n"))),
            (c = ws(c)),
            (c = Es(c, n)),
            (c = Ts(c, n)),
            (f = ws(f)),
            (f = Es(f, n)),
            (f = Ts(f, n)),
            (c = Ps(c)),
            (f = Ps(f)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((C = "#version 300 es\n"),
              (w =
                [
                  E,
                  "precision mediump sampler2DArray;",
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                w),
              (R =
                [
                  "precision mediump sampler2DArray;",
                  "#define varying in",
                  n.glslVersion === ft ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
                  n.glslVersion === ft ? "" : "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                R));
          const L = C + w + c,
            P = C + R + f,
            I = _s(o, o.VERTEX_SHADER, L),
            U = _s(o, o.FRAGMENT_SHADER, P);
          function N(e) {
            if (t.debug.checkShaderErrors) {
              const n = o.getProgramInfoLog(A).trim(),
                i = o.getShaderInfoLog(I).trim(),
                r = o.getShaderInfoLog(U).trim();
              let s = !0,
                a = !0;
              if (!1 === o.getProgramParameter(A, o.LINK_STATUS))
                if (((s = !1), "function" == typeof t.debug.onShaderError))
                  t.debug.onShaderError(o, A, I, U);
                else {
                  const t = ys(o, I, "vertex"),
                    e = ys(o, U, "fragment");
                  console.error(
                    "THREE.WebGLProgram: Shader Error " +
                      o.getError() +
                      " - VALIDATE_STATUS " +
                      o.getProgramParameter(A, o.VALIDATE_STATUS) +
                      "\n\nProgram Info Log: " +
                      n +
                      "\n" +
                      t +
                      "\n" +
                      e
                  );
                }
              else
                "" !== n
                  ? console.warn("THREE.WebGLProgram: Program Info Log:", n)
                  : ("" !== i && "" !== r) || (a = !1);
              a &&
                (e.diagnostics = {
                  runnable: s,
                  programLog: n,
                  vertexShader: { log: i, prefix: w },
                  fragmentShader: { log: r, prefix: R },
                });
            }
            o.deleteShader(I),
              o.deleteShader(U),
              (D = new gs(o, A)),
              (O = (function (t, e) {
                const n = {},
                  i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                for (let r = 0; r < i; r++) {
                  const i = t.getActiveAttrib(e, r),
                    s = i.name;
                  let a = 1;
                  i.type === t.FLOAT_MAT2 && (a = 2),
                    i.type === t.FLOAT_MAT3 && (a = 3),
                    i.type === t.FLOAT_MAT4 && (a = 4),
                    (n[s] = { type: i.type, location: t.getAttribLocation(e, s), locationSize: a });
                }
                return n;
              })(o, A));
          }
          let D, O;
          o.attachShader(A, I),
            o.attachShader(A, U),
            void 0 !== n.index0AttributeName
              ? o.bindAttribLocation(A, 0, n.index0AttributeName)
              : !0 === n.morphTargets && o.bindAttribLocation(A, 0, "position"),
            o.linkProgram(A),
            (this.getUniforms = function () {
              return void 0 === D && N(this), D;
            }),
            (this.getAttributes = function () {
              return void 0 === O && N(this), O;
            });
          let B = !1 === n.rendererExtensionParallelShaderCompile;
          return (
            (this.isReady = function () {
              return !1 === B && (B = o.getProgramParameter(A, vs)), B;
            }),
            (this.destroy = function () {
              i.releaseStatesOfProgram(this), o.deleteProgram(A), (this.program = void 0);
            }),
            (this.type = n.shaderType),
            (this.name = n.shaderName),
            (this.id = xs++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = A),
            (this.vertexShader = I),
            (this.fragmentShader = U),
            this
          );
        }
        let Ds = 0;
        class Os {
          constructor() {
            (this.shaderCache = new Map()), (this.materialCache = new Map());
          }
          update(t) {
            const e = t.vertexShader,
              n = t.fragmentShader,
              i = this._getShaderStage(e),
              r = this._getShaderStage(n),
              s = this._getShaderCacheForMaterial(t);
            return (
              !1 === s.has(i) && (s.add(i), i.usedTimes++),
              !1 === s.has(r) && (s.add(r), r.usedTimes++),
              this
            );
          }
          remove(t) {
            const e = this.materialCache.get(t);
            for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
            return this.materialCache.delete(t), this;
          }
          getVertexShaderID(t) {
            return this._getShaderStage(t.vertexShader).id;
          }
          getFragmentShaderID(t) {
            return this._getShaderStage(t.fragmentShader).id;
          }
          dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
          }
          _getShaderCacheForMaterial(t) {
            const e = this.materialCache;
            let n = e.get(t);
            return void 0 === n && ((n = new Set()), e.set(t, n)), n;
          }
          _getShaderStage(t) {
            const e = this.shaderCache;
            let n = e.get(t);
            return void 0 === n && ((n = new Bs(t)), e.set(t, n)), n;
          }
        }
        class Bs {
          constructor(t) {
            (this.id = Ds++), (this.code = t), (this.usedTimes = 0);
          }
        }
        function Fs(t, e, n, i, r, s, a) {
          const o = new qe(),
            c = new Os(),
            h = [],
            u = r.isWebGL2,
            d = r.logarithmicDepthBuffer,
            f = r.vertexTextures;
          let m = r.precision;
          const g = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          };
          function _(t) {
            return 0 === t ? "uv" : `uv${t}`;
          }
          return {
            getParameters: function (s, o, h, v, x) {
              const y = v.fog,
                M = x.geometry,
                S = s.isMeshStandardMaterial ? v.environment : null,
                E = (s.isMeshStandardMaterial ? n : e).get(s.envMap || S),
                T = E && E.mapping === b ? E.image.height : null,
                A = g[s.type];
              null !== s.precision &&
                ((m = r.getMaxPrecision(s.precision)),
                m !== s.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    s.precision,
                    "not supported, using",
                    m,
                    "instead."
                  ));
              const w =
                  M.morphAttributes.position || M.morphAttributes.normal || M.morphAttributes.color,
                R = void 0 !== w ? w.length : 0;
              let C,
                L,
                P,
                I,
                U = 0;
              if (
                (void 0 !== M.morphAttributes.position && (U = 1),
                void 0 !== M.morphAttributes.normal && (U = 2),
                void 0 !== M.morphAttributes.color && (U = 3),
                A)
              ) {
                const t = Ui[A];
                (C = t.vertexShader), (L = t.fragmentShader);
              } else
                (C = s.vertexShader),
                  (L = s.fragmentShader),
                  c.update(s),
                  (P = c.getVertexShaderID(s)),
                  (I = c.getFragmentShaderID(s));
              const N = t.getRenderTarget(),
                D = !0 === x.isInstancedMesh,
                O = !0 === x.isBatchedMesh,
                B = !!s.map,
                F = !!s.matcap,
                z = !!E,
                H = !!s.aoMap,
                G = !!s.lightMap,
                k = !!s.bumpMap,
                V = !!s.normalMap,
                W = !!s.displacementMap,
                X = !!s.emissiveMap,
                j = !!s.metalnessMap,
                q = !!s.roughnessMap,
                Y = s.anisotropy > 0,
                K = s.clearcoat > 0,
                Z = s.iridescence > 0,
                J = s.sheen > 0,
                Q = s.transmission > 0,
                $ = Y && !!s.anisotropyMap,
                tt = K && !!s.clearcoatMap,
                et = K && !!s.clearcoatNormalMap,
                nt = K && !!s.clearcoatRoughnessMap,
                it = Z && !!s.iridescenceMap,
                rt = Z && !!s.iridescenceThicknessMap,
                at = J && !!s.sheenColorMap,
                ot = J && !!s.sheenRoughnessMap,
                lt = !!s.specularMap,
                ht = !!s.specularColorMap,
                ut = !!s.specularIntensityMap,
                dt = Q && !!s.transmissionMap,
                pt = Q && !!s.thicknessMap,
                ft = !!s.gradientMap,
                mt = !!s.alphaMap,
                gt = s.alphaTest > 0,
                _t = !!s.alphaHash,
                vt = !!s.extensions,
                xt = !!M.attributes.uv1,
                yt = !!M.attributes.uv2,
                Mt = !!M.attributes.uv3;
              let St = p;
              return (
                s.toneMapped && ((null !== N && !0 !== N.isXRRenderTarget) || (St = t.toneMapping)),
                {
                  isWebGL2: u,
                  shaderID: A,
                  shaderType: s.type,
                  shaderName: s.name,
                  vertexShader: C,
                  fragmentShader: L,
                  defines: s.defines,
                  customVertexShaderID: P,
                  customFragmentShaderID: I,
                  isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                  glslVersion: s.glslVersion,
                  precision: m,
                  batching: O,
                  instancing: D,
                  instancingColor: D && null !== x.instanceColor,
                  supportsVertexTextures: f,
                  outputColorSpace:
                    null === N
                      ? t.outputColorSpace
                      : !0 === N.isXRRenderTarget
                      ? N.texture.colorSpace
                      : st,
                  map: B,
                  matcap: F,
                  envMap: z,
                  envMapMode: z && E.mapping,
                  envMapCubeUVHeight: T,
                  aoMap: H,
                  lightMap: G,
                  bumpMap: k,
                  normalMap: V,
                  displacementMap: f && W,
                  emissiveMap: X,
                  normalMapObjectSpace: V && 1 === s.normalMapType,
                  normalMapTangentSpace: V && 0 === s.normalMapType,
                  metalnessMap: j,
                  roughnessMap: q,
                  anisotropy: Y,
                  anisotropyMap: $,
                  clearcoat: K,
                  clearcoatMap: tt,
                  clearcoatNormalMap: et,
                  clearcoatRoughnessMap: nt,
                  iridescence: Z,
                  iridescenceMap: it,
                  iridescenceThicknessMap: rt,
                  sheen: J,
                  sheenColorMap: at,
                  sheenRoughnessMap: ot,
                  specularMap: lt,
                  specularColorMap: ht,
                  specularIntensityMap: ut,
                  transmission: Q,
                  transmissionMap: dt,
                  thicknessMap: pt,
                  gradientMap: ft,
                  opaque: !1 === s.transparent && 1 === s.blending,
                  alphaMap: mt,
                  alphaTest: gt,
                  alphaHash: _t,
                  combine: s.combine,
                  mapUv: B && _(s.map.channel),
                  aoMapUv: H && _(s.aoMap.channel),
                  lightMapUv: G && _(s.lightMap.channel),
                  bumpMapUv: k && _(s.bumpMap.channel),
                  normalMapUv: V && _(s.normalMap.channel),
                  displacementMapUv: W && _(s.displacementMap.channel),
                  emissiveMapUv: X && _(s.emissiveMap.channel),
                  metalnessMapUv: j && _(s.metalnessMap.channel),
                  roughnessMapUv: q && _(s.roughnessMap.channel),
                  anisotropyMapUv: $ && _(s.anisotropyMap.channel),
                  clearcoatMapUv: tt && _(s.clearcoatMap.channel),
                  clearcoatNormalMapUv: et && _(s.clearcoatNormalMap.channel),
                  clearcoatRoughnessMapUv: nt && _(s.clearcoatRoughnessMap.channel),
                  iridescenceMapUv: it && _(s.iridescenceMap.channel),
                  iridescenceThicknessMapUv: rt && _(s.iridescenceThicknessMap.channel),
                  sheenColorMapUv: at && _(s.sheenColorMap.channel),
                  sheenRoughnessMapUv: ot && _(s.sheenRoughnessMap.channel),
                  specularMapUv: lt && _(s.specularMap.channel),
                  specularColorMapUv: ht && _(s.specularColorMap.channel),
                  specularIntensityMapUv: ut && _(s.specularIntensityMap.channel),
                  transmissionMapUv: dt && _(s.transmissionMap.channel),
                  thicknessMapUv: pt && _(s.thicknessMap.channel),
                  alphaMapUv: mt && _(s.alphaMap.channel),
                  vertexTangents: !!M.attributes.tangent && (V || Y),
                  vertexColors: s.vertexColors,
                  vertexAlphas:
                    !0 === s.vertexColors &&
                    !!M.attributes.color &&
                    4 === M.attributes.color.itemSize,
                  vertexUv1s: xt,
                  vertexUv2s: yt,
                  vertexUv3s: Mt,
                  pointsUvs: !0 === x.isPoints && !!M.attributes.uv && (B || mt),
                  fog: !!y,
                  useFog: !0 === s.fog,
                  fogExp2: y && y.isFogExp2,
                  flatShading: !0 === s.flatShading,
                  sizeAttenuation: !0 === s.sizeAttenuation,
                  logarithmicDepthBuffer: d,
                  skinning: !0 === x.isSkinnedMesh,
                  morphTargets: void 0 !== M.morphAttributes.position,
                  morphNormals: void 0 !== M.morphAttributes.normal,
                  morphColors: void 0 !== M.morphAttributes.color,
                  morphTargetsCount: R,
                  morphTextureStride: U,
                  numDirLights: o.directional.length,
                  numPointLights: o.point.length,
                  numSpotLights: o.spot.length,
                  numSpotLightMaps: o.spotLightMap.length,
                  numRectAreaLights: o.rectArea.length,
                  numHemiLights: o.hemi.length,
                  numDirLightShadows: o.directionalShadowMap.length,
                  numPointLightShadows: o.pointShadowMap.length,
                  numSpotLightShadows: o.spotShadowMap.length,
                  numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                  numLightProbes: o.numLightProbes,
                  numClippingPlanes: a.numPlanes,
                  numClipIntersection: a.numIntersection,
                  dithering: s.dithering,
                  shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
                  shadowMapType: t.shadowMap.type,
                  toneMapping: St,
                  useLegacyLights: t._useLegacyLights,
                  decodeVideoTexture:
                    B && !0 === s.map.isVideoTexture && Wt.getTransfer(s.map.colorSpace) === ct,
                  premultipliedAlpha: s.premultipliedAlpha,
                  doubleSided: s.side === l,
                  flipSided: 1 === s.side,
                  useDepthPacking: s.depthPacking >= 0,
                  depthPacking: s.depthPacking || 0,
                  index0AttributeName: s.index0AttributeName,
                  extensionDerivatives: vt && !0 === s.extensions.derivatives,
                  extensionFragDepth: vt && !0 === s.extensions.fragDepth,
                  extensionDrawBuffers: vt && !0 === s.extensions.drawBuffers,
                  extensionShaderTextureLOD: vt && !0 === s.extensions.shaderTextureLOD,
                  extensionClipCullDistance:
                    vt && s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                  rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                  rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                  rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
                  rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                  customProgramCacheKey: s.customProgramCacheKey(),
                }
              );
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              return (
                !1 === e.isRawShaderMaterial &&
                  ((function (t, e) {
                    t.push(e.precision),
                      t.push(e.outputColorSpace),
                      t.push(e.envMapMode),
                      t.push(e.envMapCubeUVHeight),
                      t.push(e.mapUv),
                      t.push(e.alphaMapUv),
                      t.push(e.lightMapUv),
                      t.push(e.aoMapUv),
                      t.push(e.bumpMapUv),
                      t.push(e.normalMapUv),
                      t.push(e.displacementMapUv),
                      t.push(e.emissiveMapUv),
                      t.push(e.metalnessMapUv),
                      t.push(e.roughnessMapUv),
                      t.push(e.anisotropyMapUv),
                      t.push(e.clearcoatMapUv),
                      t.push(e.clearcoatNormalMapUv),
                      t.push(e.clearcoatRoughnessMapUv),
                      t.push(e.iridescenceMapUv),
                      t.push(e.iridescenceThicknessMapUv),
                      t.push(e.sheenColorMapUv),
                      t.push(e.sheenRoughnessMapUv),
                      t.push(e.specularMapUv),
                      t.push(e.specularColorMapUv),
                      t.push(e.specularIntensityMapUv),
                      t.push(e.transmissionMapUv),
                      t.push(e.thicknessMapUv),
                      t.push(e.combine),
                      t.push(e.fogExp2),
                      t.push(e.sizeAttenuation),
                      t.push(e.morphTargetsCount),
                      t.push(e.morphAttributeCount),
                      t.push(e.numDirLights),
                      t.push(e.numPointLights),
                      t.push(e.numSpotLights),
                      t.push(e.numSpotLightMaps),
                      t.push(e.numHemiLights),
                      t.push(e.numRectAreaLights),
                      t.push(e.numDirLightShadows),
                      t.push(e.numPointLightShadows),
                      t.push(e.numSpotLightShadows),
                      t.push(e.numSpotLightShadowsWithMaps),
                      t.push(e.numLightProbes),
                      t.push(e.shadowMapType),
                      t.push(e.toneMapping),
                      t.push(e.numClippingPlanes),
                      t.push(e.numClipIntersection),
                      t.push(e.depthPacking);
                  })(n, e),
                  (function (t, e) {
                    o.disableAll(),
                      e.isWebGL2 && o.enable(0),
                      e.supportsVertexTextures && o.enable(1),
                      e.instancing && o.enable(2),
                      e.instancingColor && o.enable(3),
                      e.matcap && o.enable(4),
                      e.envMap && o.enable(5),
                      e.normalMapObjectSpace && o.enable(6),
                      e.normalMapTangentSpace && o.enable(7),
                      e.clearcoat && o.enable(8),
                      e.iridescence && o.enable(9),
                      e.alphaTest && o.enable(10),
                      e.vertexColors && o.enable(11),
                      e.vertexAlphas && o.enable(12),
                      e.vertexUv1s && o.enable(13),
                      e.vertexUv2s && o.enable(14),
                      e.vertexUv3s && o.enable(15),
                      e.vertexTangents && o.enable(16),
                      e.anisotropy && o.enable(17),
                      e.alphaHash && o.enable(18),
                      e.batching && o.enable(19),
                      t.push(o.mask),
                      o.disableAll(),
                      e.fog && o.enable(0),
                      e.useFog && o.enable(1),
                      e.flatShading && o.enable(2),
                      e.logarithmicDepthBuffer && o.enable(3),
                      e.skinning && o.enable(4),
                      e.morphTargets && o.enable(5),
                      e.morphNormals && o.enable(6),
                      e.morphColors && o.enable(7),
                      e.premultipliedAlpha && o.enable(8),
                      e.shadowMapEnabled && o.enable(9),
                      e.useLegacyLights && o.enable(10),
                      e.doubleSided && o.enable(11),
                      e.flipSided && o.enable(12),
                      e.useDepthPacking && o.enable(13),
                      e.dithering && o.enable(14),
                      e.transmission && o.enable(15),
                      e.sheen && o.enable(16),
                      e.opaque && o.enable(17),
                      e.pointsUvs && o.enable(18),
                      e.decodeVideoTexture && o.enable(19),
                      t.push(o.mask);
                  })(n, e),
                  n.push(t.outputColorSpace)),
                n.push(e.customProgramCacheKey),
                n.join()
              );
            },
            getUniforms: function (t) {
              const e = g[t.type];
              let n;
              if (e) {
                const t = Ui[e];
                n = pi.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let i;
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                if (e.cacheKey === n) {
                  (i = e), ++i.usedTimes;
                  break;
                }
              }
              return void 0 === i && ((i = new Ns(t, n, e, s)), h.push(i)), i;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = h.indexOf(t);
                (h[e] = h[h.length - 1]), h.pop(), t.destroy();
              }
            },
            releaseShaderCache: function (t) {
              c.remove(t);
            },
            programs: h,
            dispose: function () {
              c.dispose();
            },
          };
        }
        function zs() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, i) {
              t.get(e)[n] = i;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function Hs(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id;
        }
        function Gs(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id;
        }
        function ks() {
          const t = [];
          let e = 0;
          const n = [],
            i = [],
            r = [];
          function s(n, i, r, s, a, o) {
            let l = t[e];
            return (
              void 0 === l
                ? ((l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: o,
                  }),
                  (t[e] = l))
                : ((l.id = n.id),
                  (l.object = n),
                  (l.geometry = i),
                  (l.material = r),
                  (l.groupOrder = s),
                  (l.renderOrder = n.renderOrder),
                  (l.z = a),
                  (l.group = o)),
              e++,
              l
            );
          }
          return {
            opaque: n,
            transmissive: i,
            transparent: r,
            init: function () {
              (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
            },
            push: function (t, e, a, o, l, c) {
              const h = s(t, e, a, o, l, c);
              a.transmission > 0 ? i.push(h) : !0 === a.transparent ? r.push(h) : n.push(h);
            },
            unshift: function (t, e, a, o, l, c) {
              const h = s(t, e, a, o, l, c);
              a.transmission > 0
                ? i.unshift(h)
                : !0 === a.transparent
                ? r.unshift(h)
                : n.unshift(h);
            },
            finish: function () {
              for (let n = e, i = t.length; n < i; n++) {
                const e = t[n];
                if (null === e.id) break;
                (e.id = null),
                  (e.object = null),
                  (e.geometry = null),
                  (e.material = null),
                  (e.group = null);
              }
            },
            sort: function (t, e) {
              n.length > 1 && n.sort(t || Hs),
                i.length > 1 && i.sort(e || Gs),
                r.length > 1 && r.sort(e || Gs);
            },
          };
        }
        function Vs() {
          let t = new WeakMap();
          return {
            get: function (e, n) {
              const i = t.get(e);
              let r;
              return (
                void 0 === i
                  ? ((r = new ks()), t.set(e, [r]))
                  : n >= i.length
                  ? ((r = new ks()), i.push(r))
                  : (r = i[n]),
                r
              );
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function Ws() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                  n = { direction: new ae(), color: new Tn() };
                  break;
                case "SpotLight":
                  n = {
                    position: new ae(),
                    direction: new ae(),
                    color: new Tn(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case "PointLight":
                  n = { position: new ae(), color: new Tn(), distance: 0, decay: 0 };
                  break;
                case "HemisphereLight":
                  n = { direction: new ae(), skyColor: new Tn(), groundColor: new Tn() };
                  break;
                case "RectAreaLight":
                  n = {
                    color: new Tn(),
                    position: new ae(),
                    halfWidth: new ae(),
                    halfHeight: new ae(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let Xs = 0;
        function js(t, e) {
          return (
            (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
          );
        }
        function qs(t, e) {
          const n = new Ws(),
            i = (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new It(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new It(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (t[e.id] = n), n;
                },
              };
            })(),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotLightMap: [],
              spotShadow: [],
              spotShadowMap: [],
              spotLightMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
              numSpotLightShadowsWithMaps: 0,
              numLightProbes: 0,
            };
          for (let t = 0; t < 9; t++) r.probe.push(new ae());
          const s = new ae(),
            a = new Oe(),
            o = new Oe();
          return {
            setup: function (s, a) {
              let o = 0,
                l = 0,
                c = 0;
              for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
              let h = 0,
                u = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0,
                g = 0,
                _ = 0,
                v = 0,
                x = 0,
                y = 0;
              s.sort(js);
              const M = !0 === a ? Math.PI : 1;
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  a = e.color,
                  S = e.intensity,
                  b = e.distance,
                  E = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight) (o += a.r * S * M), (l += a.g * S * M), (c += a.b * S * M);
                else if (e.isLightProbe) {
                  for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], S);
                  y++;
                } else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if ((t.color.copy(e.color).multiplyScalar(e.intensity * M), e.castShadow)) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.directionalShadow[h] = n),
                      (r.directionalShadowMap[h] = E),
                      (r.directionalShadowMatrix[h] = e.shadow.matrix),
                      m++;
                  }
                  (r.directional[h] = t), h++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(a).multiplyScalar(S * M),
                    (t.distance = b),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    (r.spot[d] = t);
                  const s = e.shadow;
                  if (
                    (e.map &&
                      ((r.spotLightMap[v] = e.map), v++, s.updateMatrices(e), e.castShadow && x++),
                    (r.spotLightMatrix[d] = s.matrix),
                    e.castShadow)
                  ) {
                    const t = i.get(e);
                    (t.shadowBias = s.bias),
                      (t.shadowNormalBias = s.normalBias),
                      (t.shadowRadius = s.radius),
                      (t.shadowMapSize = s.mapSize),
                      (r.spotShadow[d] = t),
                      (r.spotShadowMap[d] = E),
                      _++;
                  }
                  d++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(a).multiplyScalar(S),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (r.rectArea[p] = t),
                    p++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity * M),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (r.pointShadow[u] = n),
                      (r.pointShadowMap[u] = E),
                      (r.pointShadowMatrix[u] = e.shadow.matrix),
                      g++;
                  }
                  (r.point[u] = t), u++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(S * M),
                    t.groundColor.copy(e.groundColor).multiplyScalar(S * M),
                    (r.hemi[f] = t),
                    f++;
                }
              }
              p > 0 &&
                (e.isWebGL2
                  ? !0 === t.has("OES_texture_float_linear")
                    ? ((r.rectAreaLTC1 = Ii.LTC_FLOAT_1), (r.rectAreaLTC2 = Ii.LTC_FLOAT_2))
                    : ((r.rectAreaLTC1 = Ii.LTC_HALF_1), (r.rectAreaLTC2 = Ii.LTC_HALF_2))
                  : !0 === t.has("OES_texture_float_linear")
                  ? ((r.rectAreaLTC1 = Ii.LTC_FLOAT_1), (r.rectAreaLTC2 = Ii.LTC_FLOAT_2))
                  : !0 === t.has("OES_texture_half_float_linear")
                  ? ((r.rectAreaLTC1 = Ii.LTC_HALF_1), (r.rectAreaLTC2 = Ii.LTC_HALF_2))
                  : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                    )),
                (r.ambient[0] = o),
                (r.ambient[1] = l),
                (r.ambient[2] = c);
              const S = r.hash;
              (S.directionalLength === h &&
                S.pointLength === u &&
                S.spotLength === d &&
                S.rectAreaLength === p &&
                S.hemiLength === f &&
                S.numDirectionalShadows === m &&
                S.numPointShadows === g &&
                S.numSpotShadows === _ &&
                S.numSpotMaps === v &&
                S.numLightProbes === y) ||
                ((r.directional.length = h),
                (r.spot.length = d),
                (r.rectArea.length = p),
                (r.point.length = u),
                (r.hemi.length = f),
                (r.directionalShadow.length = m),
                (r.directionalShadowMap.length = m),
                (r.pointShadow.length = g),
                (r.pointShadowMap.length = g),
                (r.spotShadow.length = _),
                (r.spotShadowMap.length = _),
                (r.directionalShadowMatrix.length = m),
                (r.pointShadowMatrix.length = g),
                (r.spotLightMatrix.length = _ + v - x),
                (r.spotLightMap.length = v),
                (r.numSpotLightShadowsWithMaps = x),
                (r.numLightProbes = y),
                (S.directionalLength = h),
                (S.pointLength = u),
                (S.spotLength = d),
                (S.rectAreaLength = p),
                (S.hemiLength = f),
                (S.numDirectionalShadows = m),
                (S.numPointShadows = g),
                (S.numSpotShadows = _),
                (S.numSpotMaps = v),
                (S.numLightProbes = y),
                (r.version = Xs++));
            },
            setupView: function (t, e) {
              let n = 0,
                i = 0,
                l = 0,
                c = 0,
                h = 0;
              const u = e.matrixWorldInverse;
              for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e];
                if (d.isDirectionalLight) {
                  const t = r.directional[n];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    n++;
                } else if (d.isSpotLight) {
                  const t = r.spot[l];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    l++;
                } else if (d.isRectAreaLight) {
                  const t = r.rectArea[c];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    o.identity(),
                    a.copy(d.matrixWorld),
                    a.premultiply(u),
                    o.extractRotation(a),
                    t.halfWidth.set(0.5 * d.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * d.height, 0),
                    t.halfWidth.applyMatrix4(o),
                    t.halfHeight.applyMatrix4(o),
                    c++;
                } else if (d.isPointLight) {
                  const t = r.point[i];
                  t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++;
                } else if (d.isHemisphereLight) {
                  const t = r.hemi[h];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    t.direction.transformDirection(u),
                    h++;
                }
              }
            },
            state: r,
          };
        }
        function Ys(t, e) {
          const n = new qs(t, e),
            i = [],
            r = [];
          return {
            init: function () {
              (i.length = 0), (r.length = 0);
            },
            state: { lightsArray: i, shadowsArray: r, lights: n },
            setupLights: function (t) {
              n.setup(i, t);
            },
            setupLightsView: function (t) {
              n.setupView(i, t);
            },
            pushLight: function (t) {
              i.push(t);
            },
            pushShadow: function (t) {
              r.push(t);
            },
          };
        }
        function Ks(t, e) {
          let n = new WeakMap();
          return {
            get: function (i, r = 0) {
              const s = n.get(i);
              let a;
              return (
                void 0 === s
                  ? ((a = new Ys(t, e)), n.set(i, [a]))
                  : r >= s.length
                  ? ((a = new Ys(t, e)), s.push(a))
                  : (a = s[r]),
                a
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class Zs extends Rn {
          constructor(t) {
            super(),
              (this.isMeshDepthMaterial = !0),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        class Js extends Rn {
          constructor(t) {
            super(),
              (this.isMeshDistanceMaterial = !0),
              (this.type = "MeshDistanceMaterial"),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        function Qs(t, e, n) {
          let i = new wi();
          const s = new It(),
            c = new It(),
            h = new te(),
            u = new Zs({ depthPacking: 3201 }),
            d = new Js(),
            p = {},
            f = n.maxTextureSize,
            m = { [o]: 1, 1: o, [l]: l },
            g = new fi({
              defines: { VSM_SAMPLES: 8 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new It() },
                radius: { value: 4 },
              },
              vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
              fragmentShader:
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            }),
            _ = g.clone();
          _.defines.HORIZONTAL_PASS = 1;
          const v = new Vn();
          v.setAttribute(
            "position",
            new In(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          const x = new oi(v, g),
            y = this;
          (this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = r);
          let M = this.type;
          function S(n, i) {
            const r = e.update(x);
            g.defines.VSM_SAMPLES !== n.blurSamples &&
              ((g.defines.VSM_SAMPLES = n.blurSamples),
              (_.defines.VSM_SAMPLES = n.blurSamples),
              (g.needsUpdate = !0),
              (_.needsUpdate = !0)),
              null === n.mapPass && (n.mapPass = new ne(s.x, s.y)),
              (g.uniforms.shadow_pass.value = n.map.texture),
              (g.uniforms.resolution.value = n.mapSize),
              (g.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(i, null, r, g, x, null),
              (_.uniforms.shadow_pass.value = n.mapPass.texture),
              (_.uniforms.resolution.value = n.mapSize),
              (_.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(i, null, r, _, x, null);
          }
          function b(e, n, i, r) {
            let s = null;
            const o = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
            if (void 0 !== o) s = o;
            else if (
              ((s = !0 === i.isPointLight ? d : u),
              (t.localClippingEnabled &&
                !0 === n.clipShadows &&
                Array.isArray(n.clippingPlanes) &&
                0 !== n.clippingPlanes.length) ||
                (n.displacementMap && 0 !== n.displacementScale) ||
                (n.alphaMap && n.alphaTest > 0) ||
                (n.map && n.alphaTest > 0))
            ) {
              const t = s.uuid,
                e = n.uuid;
              let i = p[t];
              void 0 === i && ((i = {}), (p[t] = i));
              let r = i[e];
              void 0 === r && ((r = s.clone()), (i[e] = r), n.addEventListener("dispose", T)),
                (s = r);
            }
            return (
              (s.visible = n.visible),
              (s.wireframe = n.wireframe),
              (s.side =
                r === a
                  ? null !== n.shadowSide
                    ? n.shadowSide
                    : n.side
                  : null !== n.shadowSide
                  ? n.shadowSide
                  : m[n.side]),
              (s.alphaMap = n.alphaMap),
              (s.alphaTest = n.alphaTest),
              (s.map = n.map),
              (s.clipShadows = n.clipShadows),
              (s.clippingPlanes = n.clippingPlanes),
              (s.clipIntersection = n.clipIntersection),
              (s.displacementMap = n.displacementMap),
              (s.displacementScale = n.displacementScale),
              (s.displacementBias = n.displacementBias),
              (s.wireframeLinewidth = n.wireframeLinewidth),
              (s.linewidth = n.linewidth),
              !0 === i.isPointLight &&
                !0 === s.isMeshDistanceMaterial &&
                (t.properties.get(s).light = i),
              s
            );
          }
          function E(n, r, s, o, l) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(r.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && l === a)) &&
              (!n.frustumCulled || i.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
              const i = e.update(n),
                a = n.material;
              if (Array.isArray(a)) {
                const e = i.groups;
                for (let c = 0, h = e.length; c < h; c++) {
                  const h = e[c],
                    u = a[h.materialIndex];
                  if (u && u.visible) {
                    const e = b(n, u, o, l);
                    n.onBeforeShadow(t, n, r, s, i, e, h),
                      t.renderBufferDirect(s, null, i, e, n, h),
                      n.onAfterShadow(t, n, r, s, i, e, h);
                  }
                }
              } else if (a.visible) {
                const e = b(n, a, o, l);
                n.onBeforeShadow(t, n, r, s, i, e, null),
                  t.renderBufferDirect(s, null, i, e, n, null),
                  n.onAfterShadow(t, n, r, s, i, e, null);
              }
            }
            const c = n.children;
            for (let t = 0, e = c.length; t < e; t++) E(c[t], r, s, o, l);
          }
          function T(t) {
            t.target.removeEventListener("dispose", T);
            for (const e in p) {
              const n = p[e],
                i = t.target.uuid;
              i in n && (n[i].dispose(), delete n[i]);
            }
          }
          this.render = function (e, n, r) {
            if (!1 === y.enabled) return;
            if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
            if (0 === e.length) return;
            const o = t.getRenderTarget(),
              l = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              d = t.state;
            d.setBlending(0),
              d.buffers.color.setClear(1, 1, 1, 1),
              d.buffers.depth.setTest(!0),
              d.setScissorTest(!1);
            const p = M !== a && this.type === a,
              m = M === a && this.type !== a;
            for (let o = 0, l = e.length; o < l; o++) {
              const l = e[o],
                u = l.shadow;
              if (void 0 === u) {
                console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                continue;
              }
              if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
              s.copy(u.mapSize);
              const g = u.getFrameExtents();
              if (
                (s.multiply(g),
                c.copy(u.mapSize),
                (s.x > f || s.y > f) &&
                  (s.x > f && ((c.x = Math.floor(f / g.x)), (s.x = c.x * g.x), (u.mapSize.x = c.x)),
                  s.y > f && ((c.y = Math.floor(f / g.y)), (s.y = c.y * g.y), (u.mapSize.y = c.y))),
                null === u.map || !0 === p || !0 === m)
              ) {
                const t = this.type !== a ? { minFilter: w, magFilter: w } : {};
                null !== u.map && u.map.dispose(),
                  (u.map = new ne(s.x, s.y, t)),
                  (u.map.texture.name = l.name + ".shadowMap"),
                  u.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(u.map), t.clear();
              const _ = u.getViewportCount();
              for (let t = 0; t < _; t++) {
                const e = u.getViewport(t);
                h.set(c.x * e.x, c.y * e.y, c.x * e.z, c.y * e.w),
                  d.viewport(h),
                  u.updateMatrices(l, t),
                  (i = u.getFrustum()),
                  E(n, r, u.camera, l, this.type);
              }
              !0 !== u.isPointLightShadow && this.type === a && S(u, r), (u.needsUpdate = !1);
            }
            (M = this.type), (y.needsUpdate = !1), t.setRenderTarget(o, l, u);
          };
        }
        function $s(t, e, n) {
          const i = n.isWebGL2,
            r = new (function () {
              let e = !1;
              const n = new te();
              let i = null;
              const r = new te(0, 0, 0, 0);
              return {
                setMask: function (n) {
                  i === n || e || (t.colorMask(n, n, n, n), (i = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, i, s, a, o) {
                  !0 === o && ((e *= a), (i *= a), (s *= a)),
                    n.set(e, i, s, a),
                    !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
                },
                reset: function () {
                  (e = !1), (i = null), r.set(-1, 0, 0, 0);
                },
              };
            })(),
            s = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null;
              return {
                setTest: function (e) {
                  e ? W(t.DEPTH_TEST) : X(t.DEPTH_TEST);
                },
                setMask: function (i) {
                  n === i || e || (t.depthMask(i), (n = i));
                },
                setFunc: function (e) {
                  if (i !== e) {
                    switch (e) {
                      case 0:
                        t.depthFunc(t.NEVER);
                        break;
                      case 1:
                        t.depthFunc(t.ALWAYS);
                        break;
                      case 2:
                        t.depthFunc(t.LESS);
                        break;
                      case 3:
                      default:
                        t.depthFunc(t.LEQUAL);
                        break;
                      case 4:
                        t.depthFunc(t.EQUAL);
                        break;
                      case 5:
                        t.depthFunc(t.GEQUAL);
                        break;
                      case 6:
                        t.depthFunc(t.GREATER);
                        break;
                      case 7:
                        t.depthFunc(t.NOTEQUAL);
                    }
                    i = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  r !== e && (t.clearDepth(e), (r = e));
                },
                reset: function () {
                  (e = !1), (n = null), (i = null), (r = null);
                },
              };
            })(),
            a = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null,
                s = null,
                a = null,
                o = null,
                l = null,
                c = null;
              return {
                setTest: function (n) {
                  e || (n ? W(t.STENCIL_TEST) : X(t.STENCIL_TEST));
                },
                setMask: function (i) {
                  n === i || e || (t.stencilMask(i), (n = i));
                },
                setFunc: function (e, n, a) {
                  (i === e && r === n && s === a) ||
                    (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
                },
                setOp: function (e, n, i) {
                  (a === e && o === n && l === i) ||
                    (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (i = null),
                    (r = null),
                    (s = null),
                    (a = null),
                    (o = null),
                    (l = null),
                    (c = null);
                },
              };
            })(),
            o = new WeakMap(),
            h = new WeakMap();
          let u = {},
            d = {},
            p = new WeakMap(),
            f = [],
            m = null,
            g = !1,
            _ = null,
            v = null,
            x = null,
            y = null,
            M = null,
            S = null,
            b = null,
            E = new Tn(0, 0, 0),
            T = 0,
            A = !1,
            w = null,
            R = null,
            C = null,
            L = null,
            P = null;
          const I = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
          let U = !1,
            N = 0;
          const D = t.getParameter(t.VERSION);
          -1 !== D.indexOf("WebGL")
            ? ((N = parseFloat(/^WebGL (\d)/.exec(D)[1])), (U = N >= 1))
            : -1 !== D.indexOf("OpenGL ES") &&
              ((N = parseFloat(/^OpenGL ES (\d)/.exec(D)[1])), (U = N >= 2));
          let O = null,
            B = {};
          const F = t.getParameter(t.SCISSOR_BOX),
            z = t.getParameter(t.VIEWPORT),
            H = new te().fromArray(F),
            G = new te().fromArray(z);
          function k(e, n, r, s) {
            const a = new Uint8Array(4),
              o = t.createTexture();
            t.bindTexture(e, o),
              t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
              t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (let o = 0; o < r; o++)
              !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
                ? t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a)
                : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, a);
            return o;
          }
          const V = {};
          function W(e) {
            !0 !== u[e] && (t.enable(e), (u[e] = !0));
          }
          function X(e) {
            !1 !== u[e] && (t.disable(e), (u[e] = !1));
          }
          (V[t.TEXTURE_2D] = k(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
            (V[t.TEXTURE_CUBE_MAP] = k(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
            i &&
              ((V[t.TEXTURE_2D_ARRAY] = k(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1)),
              (V[t.TEXTURE_3D] = k(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            a.setClear(0),
            W(t.DEPTH_TEST),
            s.setFunc(3),
            K(!1),
            Z(1),
            W(t.CULL_FACE),
            Y(0);
          const j = { [c]: t.FUNC_ADD, 101: t.FUNC_SUBTRACT, 102: t.FUNC_REVERSE_SUBTRACT };
          if (i) (j[103] = t.MIN), (j[104] = t.MAX);
          else {
            const t = e.get("EXT_blend_minmax");
            null !== t && ((j[103] = t.MIN_EXT), (j[104] = t.MAX_EXT));
          }
          const q = {
            200: t.ZERO,
            201: t.ONE,
            202: t.SRC_COLOR,
            204: t.SRC_ALPHA,
            210: t.SRC_ALPHA_SATURATE,
            208: t.DST_COLOR,
            206: t.DST_ALPHA,
            203: t.ONE_MINUS_SRC_COLOR,
            205: t.ONE_MINUS_SRC_ALPHA,
            209: t.ONE_MINUS_DST_COLOR,
            207: t.ONE_MINUS_DST_ALPHA,
            211: t.CONSTANT_COLOR,
            212: t.ONE_MINUS_CONSTANT_COLOR,
            213: t.CONSTANT_ALPHA,
            214: t.ONE_MINUS_CONSTANT_ALPHA,
          };
          function Y(e, n, i, r, s, a, o, l, h, u) {
            if (0 !== e) {
              if ((!1 === g && (W(t.BLEND), (g = !0)), 5 === e))
                (s = s || n),
                  (a = a || i),
                  (o = o || r),
                  (n === v && s === M) || (t.blendEquationSeparate(j[n], j[s]), (v = n), (M = s)),
                  (i === x && r === y && a === S && o === b) ||
                    (t.blendFuncSeparate(q[i], q[r], q[a], q[o]),
                    (x = i),
                    (y = r),
                    (S = a),
                    (b = o)),
                  (!1 !== l.equals(E) && h === T) ||
                    (t.blendColor(l.r, l.g, l.b, h), E.copy(l), (T = h)),
                  (_ = e),
                  (A = !1);
              else if (e !== _ || u !== A) {
                if (((v === c && M === c) || (t.blendEquation(t.FUNC_ADD), (v = c), (M = c)), u))
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      );
                      break;
                    case 2:
                      t.blendFunc(t.ONE, t.ONE);
                      break;
                    case 3:
                      t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                      break;
                    case 4:
                      t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                else
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(
                        t.SRC_ALPHA,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      );
                      break;
                    case 2:
                      t.blendFunc(t.SRC_ALPHA, t.ONE);
                      break;
                    case 3:
                      t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                      break;
                    case 4:
                      t.blendFunc(t.ZERO, t.SRC_COLOR);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                (x = null),
                  (y = null),
                  (S = null),
                  (b = null),
                  E.set(0, 0, 0),
                  (T = 0),
                  (_ = e),
                  (A = u);
              }
            } else !0 === g && (X(t.BLEND), (g = !1));
          }
          function K(e) {
            w !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (w = e));
          }
          function Z(e) {
            0 !== e
              ? (W(t.CULL_FACE),
                e !== R &&
                  (1 === e
                    ? t.cullFace(t.BACK)
                    : 2 === e
                    ? t.cullFace(t.FRONT)
                    : t.cullFace(t.FRONT_AND_BACK)))
              : X(t.CULL_FACE),
              (R = e);
          }
          function J(e, n, i) {
            e
              ? (W(t.POLYGON_OFFSET_FILL),
                (L === n && P === i) || (t.polygonOffset(n, i), (L = n), (P = i)))
              : X(t.POLYGON_OFFSET_FILL);
          }
          return {
            buffers: { color: r, depth: s, stencil: a },
            enable: W,
            disable: X,
            bindFramebuffer: function (e, n) {
              return (
                d[e] !== n &&
                (t.bindFramebuffer(e, n),
                (d[e] = n),
                i &&
                  (e === t.DRAW_FRAMEBUFFER && (d[t.FRAMEBUFFER] = n),
                  e === t.FRAMEBUFFER && (d[t.DRAW_FRAMEBUFFER] = n)),
                !0)
              );
            },
            drawBuffers: function (i, r) {
              let s = f,
                a = !1;
              if (i)
                if (
                  ((s = p.get(r)),
                  void 0 === s && ((s = []), p.set(r, s)),
                  i.isWebGLMultipleRenderTargets)
                ) {
                  const e = i.texture;
                  if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                    for (let n = 0, i = e.length; n < i; n++) s[n] = t.COLOR_ATTACHMENT0 + n;
                    (s.length = e.length), (a = !0);
                  }
                } else s[0] !== t.COLOR_ATTACHMENT0 && ((s[0] = t.COLOR_ATTACHMENT0), (a = !0));
              else s[0] !== t.BACK && ((s[0] = t.BACK), (a = !0));
              a &&
                (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
            },
            useProgram: function (e) {
              return m !== e && (t.useProgram(e), (m = e), !0);
            },
            setBlending: Y,
            setMaterial: function (e, n) {
              e.side === l ? X(t.CULL_FACE) : W(t.CULL_FACE);
              let i = 1 === e.side;
              n && (i = !i),
                K(i),
                1 === e.blending && !1 === e.transparent
                  ? Y(0)
                  : Y(
                      e.blending,
                      e.blendEquation,
                      e.blendSrc,
                      e.blendDst,
                      e.blendEquationAlpha,
                      e.blendSrcAlpha,
                      e.blendDstAlpha,
                      e.blendColor,
                      e.blendAlpha,
                      e.premultipliedAlpha
                    ),
                s.setFunc(e.depthFunc),
                s.setTest(e.depthTest),
                s.setMask(e.depthWrite),
                r.setMask(e.colorWrite);
              const o = e.stencilWrite;
              a.setTest(o),
                o &&
                  (a.setMask(e.stencilWriteMask),
                  a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                  a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                J(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                !0 === e.alphaToCoverage
                  ? W(t.SAMPLE_ALPHA_TO_COVERAGE)
                  : X(t.SAMPLE_ALPHA_TO_COVERAGE);
            },
            setFlipSided: K,
            setCullFace: Z,
            setLineWidth: function (e) {
              e !== C && (U && t.lineWidth(e), (C = e));
            },
            setPolygonOffset: J,
            setScissorTest: function (e) {
              e ? W(t.SCISSOR_TEST) : X(t.SCISSOR_TEST);
            },
            activeTexture: function (e) {
              void 0 === e && (e = t.TEXTURE0 + I - 1), O !== e && (t.activeTexture(e), (O = e));
            },
            bindTexture: function (e, n, i) {
              void 0 === i && (i = null === O ? t.TEXTURE0 + I - 1 : O);
              let r = B[i];
              void 0 === r && ((r = { type: void 0, texture: void 0 }), (B[i] = r)),
                (r.type === e && r.texture === n) ||
                  (O !== i && (t.activeTexture(i), (O = i)),
                  t.bindTexture(e, n || V[e]),
                  (r.type = e),
                  (r.texture = n));
            },
            unbindTexture: function () {
              const e = B[O];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexImage3D: function () {
              try {
                t.compressedTexImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            updateUBOMapping: function (e, n) {
              let i = h.get(n);
              void 0 === i && ((i = new WeakMap()), h.set(n, i));
              let r = i.get(e);
              void 0 === r && ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
            },
            uniformBlockBinding: function (e, n) {
              const i = h.get(n).get(e);
              o.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), o.set(n, i));
            },
            texStorage2D: function () {
              try {
                t.texStorage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texStorage3D: function () {
              try {
                t.texStorage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texSubImage2D: function () {
              try {
                t.texSubImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texSubImage3D: function () {
              try {
                t.texSubImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexSubImage2D: function () {
              try {
                t.compressedTexSubImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexSubImage3D: function () {
              try {
                t.compressedTexSubImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            scissor: function (e) {
              !1 === H.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), H.copy(e));
            },
            viewport: function (e) {
              !1 === G.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), G.copy(e));
            },
            reset: function () {
              t.disable(t.BLEND),
                t.disable(t.CULL_FACE),
                t.disable(t.DEPTH_TEST),
                t.disable(t.POLYGON_OFFSET_FILL),
                t.disable(t.SCISSOR_TEST),
                t.disable(t.STENCIL_TEST),
                t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.ONE, t.ZERO),
                t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                t.blendColor(0, 0, 0, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(t.LESS),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(t.ALWAYS, 0, 4294967295),
                t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                t.clearStencil(0),
                t.cullFace(t.BACK),
                t.frontFace(t.CCW),
                t.polygonOffset(0, 0),
                t.activeTexture(t.TEXTURE0),
                t.bindFramebuffer(t.FRAMEBUFFER, null),
                !0 === i &&
                  (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                  t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (u = {}),
                (O = null),
                (B = {}),
                (d = {}),
                (p = new WeakMap()),
                (f = []),
                (m = null),
                (g = !1),
                (_ = null),
                (v = null),
                (x = null),
                (y = null),
                (M = null),
                (S = null),
                (b = null),
                (E = new Tn(0, 0, 0)),
                (T = 0),
                (A = !1),
                (w = null),
                (R = null),
                (C = null),
                (L = null),
                (P = null),
                H.set(0, 0, t.canvas.width, t.canvas.height),
                G.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                s.reset(),
                a.reset();
            },
          };
        }
        function ta(t, e, n, i, r, s, a) {
          const o = r.isWebGL2,
            l = e.has("WEBGL_multisampled_render_to_texture")
              ? e.get("WEBGL_multisampled_render_to_texture")
              : null,
            c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
            h = new WeakMap();
          let u;
          const d = new WeakMap();
          let p = !1;
          try {
            p =
              "undefined" != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d");
          } catch (t) {}
          function f(t, e) {
            return p ? new OffscreenCanvas(t, e) : Ot("canvas");
          }
          function m(t, e, n, i) {
            let r = 1;
            if (
              ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
              r < 1 || !0 === e)
            ) {
              if (
                ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const i = e ? Rt : Math.floor,
                  s = i(r * t.width),
                  a = i(r * t.height);
                void 0 === u && (u = f(s, a));
                const o = n ? f(s, a) : u;
                return (
                  (o.width = s),
                  (o.height = a),
                  o.getContext("2d").drawImage(t, 0, 0, s, a),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                      t.width +
                      "x" +
                      t.height +
                      ") to (" +
                      s +
                      "x" +
                      a +
                      ")."
                  ),
                  o
                );
              }
              return (
                "data" in t &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      t.width +
                      "x" +
                      t.height +
                      ")."
                  ),
                t
              );
            }
            return t;
          }
          function g(t) {
            return wt(t.width) && wt(t.height);
          }
          function _(t, e) {
            return t.generateMipmaps && e && t.minFilter !== w && t.minFilter !== L;
          }
          function v(e) {
            t.generateMipmap(e);
          }
          function x(n, i, r, s, a = !1) {
            if (!1 === o) return i;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'"
              );
            }
            let l = i;
            if (
              (i === t.RED &&
                (r === t.FLOAT && (l = t.R32F),
                r === t.HALF_FLOAT && (l = t.R16F),
                r === t.UNSIGNED_BYTE && (l = t.R8)),
              i === t.RED_INTEGER &&
                (r === t.UNSIGNED_BYTE && (l = t.R8UI),
                r === t.UNSIGNED_SHORT && (l = t.R16UI),
                r === t.UNSIGNED_INT && (l = t.R32UI),
                r === t.BYTE && (l = t.R8I),
                r === t.SHORT && (l = t.R16I),
                r === t.INT && (l = t.R32I)),
              i === t.RG &&
                (r === t.FLOAT && (l = t.RG32F),
                r === t.HALF_FLOAT && (l = t.RG16F),
                r === t.UNSIGNED_BYTE && (l = t.RG8)),
              i === t.RGBA)
            ) {
              const e = a ? lt : Wt.getTransfer(s);
              r === t.FLOAT && (l = t.RGBA32F),
                r === t.HALF_FLOAT && (l = t.RGBA16F),
                r === t.UNSIGNED_BYTE && (l = e === ct ? t.SRGB8_ALPHA8 : t.RGBA8),
                r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
                r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1);
            }
            return (
              (l !== t.R16F &&
                l !== t.R32F &&
                l !== t.RG16F &&
                l !== t.RG32F &&
                l !== t.RGBA16F &&
                l !== t.RGBA32F) ||
                e.get("EXT_color_buffer_float"),
              l
            );
          }
          function y(t, e, n) {
            return !0 === _(t, n) ||
              (t.isFramebufferTexture && t.minFilter !== w && t.minFilter !== L)
              ? Math.log2(Math.max(e.width, e.height)) + 1
              : void 0 !== t.mipmaps && t.mipmaps.length > 0
              ? t.mipmaps.length
              : t.isCompressedTexture && Array.isArray(t.image)
              ? e.mipmaps.length
              : 1;
          }
          function M(e) {
            return e === w || e === R || e === C ? t.NEAREST : t.LINEAR;
          }
          function S(t) {
            const e = t.target;
            e.removeEventListener("dispose", S),
              (function (t) {
                const e = i.get(t);
                if (void 0 === e.__webglInit) return;
                const n = t.source,
                  r = d.get(n);
                if (r) {
                  const i = r[e.__cacheKey];
                  i.usedTimes--,
                    0 === i.usedTimes && k(t),
                    0 === Object.keys(r).length && d.delete(n);
                }
                i.remove(t);
              })(e),
              e.isVideoTexture && h.delete(e);
          }
          function b(e) {
            const n = e.target;
            n.removeEventListener("dispose", b),
              (function (e) {
                const n = e.texture,
                  r = i.get(e),
                  s = i.get(n);
                if (
                  (void 0 !== s.__webglTexture &&
                    (t.deleteTexture(s.__webglTexture), a.memory.textures--),
                  e.depthTexture && e.depthTexture.dispose(),
                  e.isWebGLCubeRenderTarget)
                )
                  for (let e = 0; e < 6; e++) {
                    if (Array.isArray(r.__webglFramebuffer[e]))
                      for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                        t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                    else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                    r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                  }
                else {
                  if (Array.isArray(r.__webglFramebuffer))
                    for (let e = 0; e < r.__webglFramebuffer.length; e++)
                      t.deleteFramebuffer(r.__webglFramebuffer[e]);
                  else t.deleteFramebuffer(r.__webglFramebuffer);
                  if (
                    (r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer)
                  )
                    for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                      r.__webglColorRenderbuffer[e] &&
                        t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                  r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                }
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = i.get(n[e]);
                    r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--),
                      i.remove(n[e]);
                  }
                i.remove(n), i.remove(e);
              })(n);
          }
          function k(e) {
            const n = i.get(e);
            t.deleteTexture(n.__webglTexture);
            const r = e.source;
            delete d.get(r)[n.__cacheKey], a.memory.textures--;
          }
          let V = 0;
          function W(e, r) {
            const s = i.get(e);
            if (
              (e.isVideoTexture &&
                (function (t) {
                  const e = a.render.frame;
                  h.get(t) !== e && (h.set(t, e), t.update());
                })(e),
              !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version)
            ) {
              const t = e.image;
              if (null === t)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but no image data found."
                );
              else {
                if (!1 !== t.complete) return void Z(s, e, r);
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              }
            }
            n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
          }
          const X = { [E]: t.REPEAT, [T]: t.CLAMP_TO_EDGE, [A]: t.MIRRORED_REPEAT },
            j = {
              [w]: t.NEAREST,
              [R]: t.NEAREST_MIPMAP_NEAREST,
              [C]: t.NEAREST_MIPMAP_LINEAR,
              [L]: t.LINEAR,
              [P]: t.LINEAR_MIPMAP_NEAREST,
              [I]: t.LINEAR_MIPMAP_LINEAR,
            },
            q = {
              512: t.NEVER,
              519: t.ALWAYS,
              513: t.LESS,
              515: t.LEQUAL,
              514: t.EQUAL,
              518: t.GEQUAL,
              516: t.GREATER,
              517: t.NOTEQUAL,
            };
          function Y(n, s, a) {
            if (
              (a
                ? (t.texParameteri(n, t.TEXTURE_WRAP_S, X[s.wrapS]),
                  t.texParameteri(n, t.TEXTURE_WRAP_T, X[s.wrapT]),
                  (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                    t.texParameteri(n, t.TEXTURE_WRAP_R, X[s.wrapR]),
                  t.texParameteri(n, t.TEXTURE_MAG_FILTER, j[s.magFilter]),
                  t.texParameteri(n, t.TEXTURE_MIN_FILTER, j[s.minFilter]))
                : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                  t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                  (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                    t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
                  (s.wrapS === T && s.wrapT === T) ||
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                    ),
                  t.texParameteri(n, t.TEXTURE_MAG_FILTER, M(s.magFilter)),
                  t.texParameteri(n, t.TEXTURE_MIN_FILTER, M(s.minFilter)),
                  s.minFilter !== w &&
                    s.minFilter !== L &&
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                    )),
              s.compareFunction &&
                (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
                t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, q[s.compareFunction])),
              !0 === e.has("EXT_texture_filter_anisotropic"))
            ) {
              const a = e.get("EXT_texture_filter_anisotropic");
              if (s.magFilter === w) return;
              if (s.minFilter !== C && s.minFilter !== I) return;
              if (s.type === O && !1 === e.has("OES_texture_float_linear")) return;
              if (!1 === o && s.type === B && !1 === e.has("OES_texture_half_float_linear")) return;
              (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  a.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(s.anisotropy, r.getMaxAnisotropy())
                ),
                (i.get(s).__currentAnisotropy = s.anisotropy));
            }
          }
          function K(e, n) {
            let i = !1;
            void 0 === e.__webglInit && ((e.__webglInit = !0), n.addEventListener("dispose", S));
            const r = n.source;
            let s = d.get(r);
            void 0 === s && ((s = {}), d.set(r, s));
            const o = (function (t) {
              const e = [];
              return (
                e.push(t.wrapS),
                e.push(t.wrapT),
                e.push(t.wrapR || 0),
                e.push(t.magFilter),
                e.push(t.minFilter),
                e.push(t.anisotropy),
                e.push(t.internalFormat),
                e.push(t.format),
                e.push(t.type),
                e.push(t.generateMipmaps),
                e.push(t.premultiplyAlpha),
                e.push(t.flipY),
                e.push(t.unpackAlignment),
                e.push(t.colorSpace),
                e.join()
              );
            })(n);
            if (o !== e.__cacheKey) {
              void 0 === s[o] &&
                ((s[o] = { texture: t.createTexture(), usedTimes: 0 }),
                a.memory.textures++,
                (i = !0)),
                s[o].usedTimes++;
              const r = s[e.__cacheKey];
              void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && k(n)),
                (e.__cacheKey = o),
                (e.__webglTexture = s[o].texture);
            }
            return i;
          }
          function Z(e, a, l) {
            let c = t.TEXTURE_2D;
            (a.isDataArrayTexture || a.isCompressedArrayTexture) && (c = t.TEXTURE_2D_ARRAY),
              a.isData3DTexture && (c = t.TEXTURE_3D);
            const h = K(e, a),
              u = a.source;
            n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + l);
            const d = i.get(u);
            if (u.version !== d.__version || !0 === h) {
              n.activeTexture(t.TEXTURE0 + l);
              const e = Wt.getPrimaries(Wt.workingColorSpace),
                i = a.colorSpace === it ? null : Wt.getPrimaries(a.colorSpace),
                p = a.colorSpace === it || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
              t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
                t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
                t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
              const f =
                (function (t) {
                  return (
                    !o &&
                    (t.wrapS !== T || t.wrapT !== T || (t.minFilter !== w && t.minFilter !== L))
                  );
                })(a) && !1 === g(a.image);
              let M = m(a.image, f, !1, r.maxTextureSize);
              M = nt(a, M);
              const S = g(M) || o,
                b = s.convert(a.format, a.colorSpace);
              let E,
                A = s.convert(a.type),
                R = x(a.internalFormat, b, A, a.colorSpace, a.isVideoTexture);
              Y(c, a, S);
              const C = a.mipmaps,
                P = o && !0 !== a.isVideoTexture && 36196 !== R,
                I = void 0 === d.__version || !0 === h,
                U = y(a, M, S);
              if (a.isDepthTexture)
                (R = t.DEPTH_COMPONENT),
                  o
                    ? (R =
                        a.type === O
                          ? t.DEPTH_COMPONENT32F
                          : a.type === D
                          ? t.DEPTH_COMPONENT24
                          : a.type === F
                          ? t.DEPTH24_STENCIL8
                          : t.DEPTH_COMPONENT16)
                    : a.type === O &&
                      console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                  a.format === H &&
                    R === t.DEPTH_COMPONENT &&
                    a.type !== N &&
                    a.type !== D &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                    ),
                    (a.type = D),
                    (A = s.convert(a.type))),
                  a.format === G &&
                    R === t.DEPTH_COMPONENT &&
                    ((R = t.DEPTH_STENCIL),
                    a.type !== F &&
                      (console.warn(
                        "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                      ),
                      (a.type = F),
                      (A = s.convert(a.type)))),
                  I &&
                    (P
                      ? n.texStorage2D(t.TEXTURE_2D, 1, R, M.width, M.height)
                      : n.texImage2D(t.TEXTURE_2D, 0, R, M.width, M.height, 0, b, A, null));
              else if (a.isDataTexture)
                if (C.length > 0 && S) {
                  P && I && n.texStorage2D(t.TEXTURE_2D, U, R, C[0].width, C[0].height);
                  for (let e = 0, i = C.length; e < i; e++)
                    (E = C[e]),
                      P
                        ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, E.width, E.height, b, A, E.data)
                        : n.texImage2D(t.TEXTURE_2D, e, R, E.width, E.height, 0, b, A, E.data);
                  a.generateMipmaps = !1;
                } else
                  P
                    ? (I && n.texStorage2D(t.TEXTURE_2D, U, R, M.width, M.height),
                      n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, M.width, M.height, b, A, M.data))
                    : n.texImage2D(t.TEXTURE_2D, 0, R, M.width, M.height, 0, b, A, M.data);
              else if (a.isCompressedTexture)
                if (a.isCompressedArrayTexture) {
                  P &&
                    I &&
                    n.texStorage3D(t.TEXTURE_2D_ARRAY, U, R, C[0].width, C[0].height, M.depth);
                  for (let e = 0, i = C.length; e < i; e++)
                    (E = C[e]),
                      a.format !== z
                        ? null !== b
                          ? P
                            ? n.compressedTexSubImage3D(
                                t.TEXTURE_2D_ARRAY,
                                e,
                                0,
                                0,
                                0,
                                E.width,
                                E.height,
                                M.depth,
                                b,
                                E.data,
                                0,
                                0
                              )
                            : n.compressedTexImage3D(
                                t.TEXTURE_2D_ARRAY,
                                e,
                                R,
                                E.width,
                                E.height,
                                M.depth,
                                0,
                                E.data,
                                0,
                                0
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : P
                        ? n.texSubImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            0,
                            0,
                            0,
                            E.width,
                            E.height,
                            M.depth,
                            b,
                            A,
                            E.data
                          )
                        : n.texImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            R,
                            E.width,
                            E.height,
                            M.depth,
                            0,
                            b,
                            A,
                            E.data
                          );
                } else {
                  P && I && n.texStorage2D(t.TEXTURE_2D, U, R, C[0].width, C[0].height);
                  for (let e = 0, i = C.length; e < i; e++)
                    (E = C[e]),
                      a.format !== z
                        ? null !== b
                          ? P
                            ? n.compressedTexSubImage2D(
                                t.TEXTURE_2D,
                                e,
                                0,
                                0,
                                E.width,
                                E.height,
                                b,
                                E.data
                              )
                            : n.compressedTexImage2D(
                                t.TEXTURE_2D,
                                e,
                                R,
                                E.width,
                                E.height,
                                0,
                                E.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : P
                        ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, E.width, E.height, b, A, E.data)
                        : n.texImage2D(t.TEXTURE_2D, e, R, E.width, E.height, 0, b, A, E.data);
                }
              else if (a.isDataArrayTexture)
                P
                  ? (I && n.texStorage3D(t.TEXTURE_2D_ARRAY, U, R, M.width, M.height, M.depth),
                    n.texSubImage3D(
                      t.TEXTURE_2D_ARRAY,
                      0,
                      0,
                      0,
                      0,
                      M.width,
                      M.height,
                      M.depth,
                      b,
                      A,
                      M.data
                    ))
                  : n.texImage3D(
                      t.TEXTURE_2D_ARRAY,
                      0,
                      R,
                      M.width,
                      M.height,
                      M.depth,
                      0,
                      b,
                      A,
                      M.data
                    );
              else if (a.isData3DTexture)
                P
                  ? (I && n.texStorage3D(t.TEXTURE_3D, U, R, M.width, M.height, M.depth),
                    n.texSubImage3D(
                      t.TEXTURE_3D,
                      0,
                      0,
                      0,
                      0,
                      M.width,
                      M.height,
                      M.depth,
                      b,
                      A,
                      M.data
                    ))
                  : n.texImage3D(t.TEXTURE_3D, 0, R, M.width, M.height, M.depth, 0, b, A, M.data);
              else if (a.isFramebufferTexture) {
                if (I)
                  if (P) n.texStorage2D(t.TEXTURE_2D, U, R, M.width, M.height);
                  else {
                    let e = M.width,
                      i = M.height;
                    for (let r = 0; r < U; r++)
                      n.texImage2D(t.TEXTURE_2D, r, R, e, i, 0, b, A, null), (e >>= 1), (i >>= 1);
                  }
              } else if (C.length > 0 && S) {
                P && I && n.texStorage2D(t.TEXTURE_2D, U, R, C[0].width, C[0].height);
                for (let e = 0, i = C.length; e < i; e++)
                  (E = C[e]),
                    P
                      ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, b, A, E)
                      : n.texImage2D(t.TEXTURE_2D, e, R, b, A, E);
                a.generateMipmaps = !1;
              } else
                P
                  ? (I && n.texStorage2D(t.TEXTURE_2D, U, R, M.width, M.height),
                    n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, b, A, M))
                  : n.texImage2D(t.TEXTURE_2D, 0, R, b, A, M);
              _(a, S) && v(c), (d.__version = u.version), a.onUpdate && a.onUpdate(a);
            }
            e.__version = a.version;
          }
          function J(e, r, a, o, c, h) {
            const u = s.convert(a.format, a.colorSpace),
              d = s.convert(a.type),
              p = x(a.internalFormat, u, d, a.colorSpace);
            if (!i.get(r).__hasExternalTextures) {
              const e = Math.max(1, r.width >> h),
                i = Math.max(1, r.height >> h);
              c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY
                ? n.texImage3D(c, h, p, e, i, r.depth, 0, u, d, null)
                : n.texImage2D(c, h, p, e, i, 0, u, d, null);
            }
            n.bindFramebuffer(t.FRAMEBUFFER, e),
              et(r)
                ? l.framebufferTexture2DMultisampleEXT(
                    t.FRAMEBUFFER,
                    o,
                    c,
                    i.get(a).__webglTexture,
                    0,
                    tt(r)
                  )
                : (c === t.TEXTURE_2D ||
                    (c >= t.TEXTURE_CUBE_MAP_POSITIVE_X && c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                  t.framebufferTexture2D(t.FRAMEBUFFER, o, c, i.get(a).__webglTexture, h),
              n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
          function Q(e, n, i) {
            if ((t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer)) {
              let r = !0 === o ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
              if (i || et(n)) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === O
                    ? (r = t.DEPTH_COMPONENT32F)
                    : e.type === D && (r = t.DEPTH_COMPONENT24));
                const i = tt(n);
                et(n)
                  ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height)
                  : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height);
              } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
              t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e);
            } else if (n.depthBuffer && n.stencilBuffer) {
              const r = tt(n);
              i && !1 === et(n)
                ? t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    r,
                    t.DEPTH24_STENCIL8,
                    n.width,
                    n.height
                  )
                : et(n)
                ? l.renderbufferStorageMultisampleEXT(
                    t.RENDERBUFFER,
                    r,
                    t.DEPTH24_STENCIL8,
                    n.width,
                    n.height
                  )
                : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.RENDERBUFFER,
                  e
                );
            } else {
              const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
              for (let r = 0; r < e.length; r++) {
                const a = e[r],
                  o = s.convert(a.format, a.colorSpace),
                  c = s.convert(a.type),
                  h = x(a.internalFormat, o, c, a.colorSpace),
                  u = tt(n);
                i && !1 === et(n)
                  ? t.renderbufferStorageMultisample(t.RENDERBUFFER, u, h, n.width, n.height)
                  : et(n)
                  ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, u, h, n.width, n.height)
                  : t.renderbufferStorage(t.RENDERBUFFER, h, n.width, n.height);
              }
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null);
          }
          function $(e) {
            const r = i.get(e),
              s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
              if (s) throw new Error("target.depthTexture not supported in Cube render targets");
              !(function (e, r) {
                if (r && r.isWebGLCubeRenderTarget)
                  throw new Error("Depth Texture with cube render targets is not supported");
                if (
                  (n.bindFramebuffer(t.FRAMEBUFFER, e),
                  !r.depthTexture || !r.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (i.get(r.depthTexture).__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                  W(r.depthTexture, 0);
                const s = i.get(r.depthTexture).__webglTexture,
                  a = tt(r);
                if (r.depthTexture.format === H)
                  et(r)
                    ? l.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        t.DEPTH_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0,
                        a
                      )
                    : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                else {
                  if (r.depthTexture.format !== G) throw new Error("Unknown depthTexture format");
                  et(r)
                    ? l.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0,
                        a
                      )
                    : t.framebufferTexture2D(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                }
              })(r.__webglFramebuffer, e);
            } else if (s) {
              r.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++)
                n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
                  (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                  Q(r.__webglDepthbuffer[i], e, !1);
            } else
              n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
                (r.__webglDepthbuffer = t.createRenderbuffer()),
                Q(r.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
          function tt(t) {
            return Math.min(r.maxSamples, t.samples);
          }
          function et(t) {
            const n = i.get(t);
            return (
              o &&
              t.samples > 0 &&
              !0 === e.has("WEBGL_multisampled_render_to_texture") &&
              !1 !== n.__useRenderToTexture
            );
          }
          function nt(t, n) {
            const i = t.colorSpace,
              r = t.format,
              s = t.type;
            return (
              !0 === t.isCompressedTexture ||
                !0 === t.isVideoTexture ||
                t.format === mt ||
                (i !== st &&
                  i !== it &&
                  (Wt.getTransfer(i) === ct
                    ? !1 === o
                      ? !0 === e.has("EXT_sRGB") && r === z
                        ? ((t.format = mt), (t.minFilter = L), (t.generateMipmaps = !1))
                        : (n = Yt.sRGBToLinear(n))
                      : (r === z && s === U) ||
                        console.warn(
                          "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                        )
                    : console.error("THREE.WebGLTextures: Unsupported texture color space:", i))),
              n
            );
          }
          (this.allocateTextureUnit = function () {
            const t = V;
            return (
              t >= r.maxTextures &&
                console.warn(
                  "THREE.WebGLTextures: Trying to use " +
                    t +
                    " texture units while this GPU supports only " +
                    r.maxTextures
                ),
              (V += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              V = 0;
            }),
            (this.setTexture2D = W),
            (this.setTexture2DArray = function (e, r) {
              const s = i.get(e);
              e.version > 0 && s.__version !== e.version
                ? Z(s, e, r)
                : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r);
            }),
            (this.setTexture3D = function (e, r) {
              const s = i.get(e);
              e.version > 0 && s.__version !== e.version
                ? Z(s, e, r)
                : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
            }),
            (this.setTextureCube = function (e, a) {
              const l = i.get(e);
              e.version > 0 && l.__version !== e.version
                ? (function (e, a, l) {
                    if (6 !== a.image.length) return;
                    const c = K(e, a),
                      h = a.source;
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + l);
                    const u = i.get(h);
                    if (h.version !== u.__version || !0 === c) {
                      n.activeTexture(t.TEXTURE0 + l);
                      const e = Wt.getPrimaries(Wt.workingColorSpace),
                        i = a.colorSpace === it ? null : Wt.getPrimaries(a.colorSpace),
                        d = a.colorSpace === it || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
                        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                        t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
                        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                      const p = a.isCompressedTexture || a.image[0].isCompressedTexture,
                        f = a.image[0] && a.image[0].isDataTexture,
                        M = [];
                      for (let t = 0; t < 6; t++)
                        (M[t] =
                          p || f
                            ? f
                              ? a.image[t].image
                              : a.image[t]
                            : m(a.image[t], !1, !0, r.maxCubemapSize)),
                          (M[t] = nt(a, M[t]));
                      const S = M[0],
                        b = g(S) || o,
                        E = s.convert(a.format, a.colorSpace),
                        T = s.convert(a.type),
                        A = x(a.internalFormat, E, T, a.colorSpace),
                        w = o && !0 !== a.isVideoTexture,
                        R = void 0 === u.__version || !0 === c;
                      let C,
                        L = y(a, S, b);
                      if ((Y(t.TEXTURE_CUBE_MAP, a, b), p)) {
                        w && R && n.texStorage2D(t.TEXTURE_CUBE_MAP, L, A, S.width, S.height);
                        for (let e = 0; e < 6; e++) {
                          C = M[e].mipmaps;
                          for (let i = 0; i < C.length; i++) {
                            const r = C[i];
                            a.format !== z
                              ? null !== E
                                ? w
                                  ? n.compressedTexSubImage2D(
                                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                      i,
                                      0,
                                      0,
                                      r.width,
                                      r.height,
                                      E,
                                      r.data
                                    )
                                  : n.compressedTexImage2D(
                                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                      i,
                                      A,
                                      r.width,
                                      r.height,
                                      0,
                                      r.data
                                    )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                  )
                              : w
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  0,
                                  0,
                                  r.width,
                                  r.height,
                                  E,
                                  T,
                                  r.data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  A,
                                  r.width,
                                  r.height,
                                  0,
                                  E,
                                  T,
                                  r.data
                                );
                          }
                        }
                      } else {
                        (C = a.mipmaps),
                          w &&
                            R &&
                            (C.length > 0 && L++,
                            n.texStorage2D(t.TEXTURE_CUBE_MAP, L, A, M[0].width, M[0].height));
                        for (let e = 0; e < 6; e++)
                          if (f) {
                            w
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  0,
                                  0,
                                  M[e].width,
                                  M[e].height,
                                  E,
                                  T,
                                  M[e].data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  A,
                                  M[e].width,
                                  M[e].height,
                                  0,
                                  E,
                                  T,
                                  M[e].data
                                );
                            for (let i = 0; i < C.length; i++) {
                              const r = C[i].image[e].image;
                              w
                                ? n.texSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    0,
                                    0,
                                    r.width,
                                    r.height,
                                    E,
                                    T,
                                    r.data
                                  )
                                : n.texImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    A,
                                    r.width,
                                    r.height,
                                    0,
                                    E,
                                    T,
                                    r.data
                                  );
                            }
                          } else {
                            w
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  0,
                                  0,
                                  E,
                                  T,
                                  M[e]
                                )
                              : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, A, E, T, M[e]);
                            for (let i = 0; i < C.length; i++) {
                              const r = C[i];
                              w
                                ? n.texSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    0,
                                    0,
                                    E,
                                    T,
                                    r.image[e]
                                  )
                                : n.texImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    A,
                                    E,
                                    T,
                                    r.image[e]
                                  );
                            }
                          }
                      }
                      _(a, b) && v(t.TEXTURE_CUBE_MAP),
                        (u.__version = h.version),
                        a.onUpdate && a.onUpdate(a);
                    }
                    e.__version = a.version;
                  })(l, e, a)
                : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + a);
            }),
            (this.rebindTextures = function (e, n, r) {
              const s = i.get(e);
              void 0 !== n &&
                J(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0),
                void 0 !== r && $(e);
            }),
            (this.setupRenderTarget = function (e) {
              const l = e.texture,
                c = i.get(e),
                h = i.get(l);
              e.addEventListener("dispose", b),
                !0 !== e.isWebGLMultipleRenderTargets &&
                  (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()),
                  (h.__version = l.version),
                  a.memory.textures++);
              const u = !0 === e.isWebGLCubeRenderTarget,
                d = !0 === e.isWebGLMultipleRenderTargets,
                p = g(e) || o;
              if (u) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  if (o && l.mipmaps && l.mipmaps.length > 0) {
                    c.__webglFramebuffer[e] = [];
                    for (let n = 0; n < l.mipmaps.length; n++)
                      c.__webglFramebuffer[e][n] = t.createFramebuffer();
                  } else c.__webglFramebuffer[e] = t.createFramebuffer();
              } else {
                if (o && l.mipmaps && l.mipmaps.length > 0) {
                  c.__webglFramebuffer = [];
                  for (let e = 0; e < l.mipmaps.length; e++)
                    c.__webglFramebuffer[e] = t.createFramebuffer();
                } else c.__webglFramebuffer = t.createFramebuffer();
                if (d)
                  if (r.drawBuffers) {
                    const n = e.texture;
                    for (let e = 0, r = n.length; e < r; e++) {
                      const r = i.get(n[e]);
                      void 0 === r.__webglTexture &&
                        ((r.__webglTexture = t.createTexture()), a.memory.textures++);
                    }
                  } else
                    console.warn(
                      "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                    );
                if (o && e.samples > 0 && !1 === et(e)) {
                  const i = d ? l : [l];
                  (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (c.__webglColorRenderbuffer = []),
                    n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                  for (let n = 0; n < i.length; n++) {
                    const r = i[n];
                    (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                      t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                    const a = s.convert(r.format, r.colorSpace),
                      o = s.convert(r.type),
                      l = x(r.internalFormat, a, o, r.colorSpace, !0 === e.isXRRenderTarget),
                      h = tt(e);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, h, l, e.width, e.height),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + n,
                        t.RENDERBUFFER,
                        c.__webglColorRenderbuffer[n]
                      );
                  }
                  t.bindRenderbuffer(t.RENDERBUFFER, null),
                    e.depthBuffer &&
                      ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      Q(c.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(t.FRAMEBUFFER, null);
                }
              }
              if (u) {
                n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), Y(t.TEXTURE_CUBE_MAP, l, p);
                for (let n = 0; n < 6; n++)
                  if (o && l.mipmaps && l.mipmaps.length > 0)
                    for (let i = 0; i < l.mipmaps.length; i++)
                      J(
                        c.__webglFramebuffer[n][i],
                        e,
                        l,
                        t.COLOR_ATTACHMENT0,
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        i
                      );
                  else
                    J(
                      c.__webglFramebuffer[n],
                      e,
                      l,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                      0
                    );
                _(l, p) && v(t.TEXTURE_CUBE_MAP), n.unbindTexture();
              } else if (d) {
                const r = e.texture;
                for (let s = 0, a = r.length; s < a; s++) {
                  const a = r[s],
                    o = i.get(a);
                  n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
                    Y(t.TEXTURE_2D, a, p),
                    J(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D, 0),
                    _(a, p) && v(t.TEXTURE_2D);
                }
                n.unbindTexture();
              } else {
                let i = t.TEXTURE_2D;
                if (
                  ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
                    (o
                      ? (i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY)
                      : console.error(
                          "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                        )),
                  n.bindTexture(i, h.__webglTexture),
                  Y(i, l, p),
                  o && l.mipmaps && l.mipmaps.length > 0)
                )
                  for (let n = 0; n < l.mipmaps.length; n++)
                    J(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
                else J(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
                _(l, p) && v(i), n.unbindTexture();
              }
              e.depthBuffer && $(e);
            }),
            (this.updateRenderTargetMipmap = function (e) {
              const r = g(e) || o,
                s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
              for (let a = 0, o = s.length; a < o; a++) {
                const o = s[a];
                if (_(o, r)) {
                  const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    s = i.get(o).__webglTexture;
                  n.bindTexture(r, s), v(r), n.unbindTexture();
                }
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (o && e.samples > 0 && !1 === et(e)) {
                const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
                  s = e.width,
                  a = e.height;
                let o = t.COLOR_BUFFER_BIT;
                const l = [],
                  h = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                  u = i.get(e),
                  d = !0 === e.isWebGLMultipleRenderTargets;
                if (d)
                  for (let e = 0; e < r.length; e++)
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.RENDERBUFFER,
                        null
                      ),
                      n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                      t.framebufferTexture2D(
                        t.DRAW_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.TEXTURE_2D,
                        null,
                        0
                      );
                n.bindFramebuffer(t.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                  n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                for (let n = 0; n < r.length; n++) {
                  l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(h);
                  const p = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                  if (
                    (!1 === p &&
                      (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT),
                      e.stencilBuffer && (o |= t.STENCIL_BUFFER_BIT)),
                    d &&
                      t.framebufferRenderbuffer(
                        t.READ_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0,
                        t.RENDERBUFFER,
                        u.__webglColorRenderbuffer[n]
                      ),
                    !0 === p &&
                      (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [h]),
                      t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [h])),
                    d)
                  ) {
                    const e = i.get(r[n]).__webglTexture;
                    t.framebufferTexture2D(
                      t.DRAW_FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_2D,
                      e,
                      0
                    );
                  }
                  t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST),
                    c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
                }
                if (
                  (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                  n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                  d)
                )
                  for (let e = 0; e < r.length; e++) {
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.RENDERBUFFER,
                        u.__webglColorRenderbuffer[e]
                      );
                    const s = i.get(r[e]).__webglTexture;
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                      t.framebufferTexture2D(
                        t.DRAW_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                  }
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer);
              }
            }),
            (this.setupDepthRenderbuffer = $),
            (this.setupFrameBufferTexture = J),
            (this.useMultisampledRTT = et);
        }
        function ea(t, e, n) {
          const i = n.isWebGL2;
          return {
            convert: function (n, r = "") {
              let s;
              const a = Wt.getTransfer(r);
              if (n === U) return t.UNSIGNED_BYTE;
              if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
              if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
              if (1010 === n) return t.BYTE;
              if (1011 === n) return t.SHORT;
              if (n === N) return t.UNSIGNED_SHORT;
              if (1013 === n) return t.INT;
              if (n === D) return t.UNSIGNED_INT;
              if (n === O) return t.FLOAT;
              if (n === B)
                return i
                  ? t.HALF_FLOAT
                  : ((s = e.get("OES_texture_half_float")), null !== s ? s.HALF_FLOAT_OES : null);
              if (1021 === n) return t.ALPHA;
              if (n === z) return t.RGBA;
              if (1024 === n) return t.LUMINANCE;
              if (1025 === n) return t.LUMINANCE_ALPHA;
              if (n === H) return t.DEPTH_COMPONENT;
              if (n === G) return t.DEPTH_STENCIL;
              if (n === mt) return (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null;
              if (1028 === n) return t.RED;
              if (1029 === n) return t.RED_INTEGER;
              if (1030 === n) return t.RG;
              if (1031 === n) return t.RG_INTEGER;
              if (1033 === n) return t.RGBA_INTEGER;
              if (n === k || n === V || n === W || n === X)
                if (a === ct) {
                  if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === s)) return null;
                  if (n === k) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                  if (n === V) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                  if (n === W) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                  if (n === X) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else {
                  if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s)) return null;
                  if (n === k) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (n === V) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (n === W) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (n === X) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
              if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s)) return null;
                if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (36196 === n)
                return (
                  (s = e.get("WEBGL_compressed_texture_etc1")),
                  null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
                );
              if (37492 === n || 37496 === n) {
                if (((s = e.get("WEBGL_compressed_texture_etc")), null === s)) return null;
                if (37492 === n) return a === ct ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (37496 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                    : s.COMPRESSED_RGBA8_ETC2_EAC;
              }
              if (
                37808 === n ||
                37809 === n ||
                37810 === n ||
                37811 === n ||
                37812 === n ||
                37813 === n ||
                37814 === n ||
                37815 === n ||
                37816 === n ||
                37817 === n ||
                37818 === n ||
                37819 === n ||
                37820 === n ||
                37821 === n
              ) {
                if (((s = e.get("WEBGL_compressed_texture_astc")), null === s)) return null;
                if (37808 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                    : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (37809 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                    : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (37810 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (37811 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (37812 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (37813 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (37814 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (37815 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (37816 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (37817 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (37818 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (37819 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (37820 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                    : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (37821 === n)
                  return a === ct
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                    : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
              }
              if (n === j || 36494 === n || 36495 === n) {
                if (((s = e.get("EXT_texture_compression_bptc")), null === s)) return null;
                if (n === j)
                  return a === ct
                    ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                    : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (36494 === n) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (36495 === n) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
              }
              if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                if (((s = e.get("EXT_texture_compression_rgtc")), null === s)) return null;
                if (n === j) return s.COMPRESSED_RED_RGTC1_EXT;
                if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
              }
              return n === F
                ? i
                  ? t.UNSIGNED_INT_24_8
                  : ((s = e.get("WEBGL_depth_texture")),
                    null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0 !== t[n]
                ? t[n]
                : null;
            },
          };
        }
        class na extends gi {
          constructor(t = []) {
            super(), (this.isArrayCamera = !0), (this.cameras = t);
          }
        }
        class ia extends ln {
          constructor() {
            super(), (this.isGroup = !0), (this.type = "Group");
          }
        }
        const ra = { type: "move" };
        class sa {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new ia()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new ia()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new ae()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new ae())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new ia()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new ae()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new ae())),
              this._grip
            );
          }
          dispatchEvent(t) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(t),
              null !== this._grip && this._grip.dispatchEvent(t),
              null !== this._hand && this._hand.dispatchEvent(t),
              this
            );
          }
          connect(t) {
            if (t && t.hand) {
              const e = this._hand;
              if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
            }
            return this.dispatchEvent({ type: "connected", data: t }), this;
          }
          disconnect(t) {
            return (
              this.dispatchEvent({ type: "disconnected", data: t }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(t, e, n) {
            let i = null,
              r = null,
              s = null;
            const a = this._targetRay,
              o = this._grip,
              l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState) {
              if (l && t.hand) {
                s = !0;
                for (const i of t.hand.values()) {
                  const t = e.getJointPose(i, n),
                    r = this._getHandJoint(l, i);
                  null !== t &&
                    (r.matrix.fromArray(t.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    (r.matrixWorldNeedsUpdate = !0),
                    (r.jointRadius = t.radius)),
                    (r.visible = null !== t);
                }
                const i = l.joints["index-finger-tip"],
                  r = l.joints["thumb-tip"],
                  a = i.position.distanceTo(r.position),
                  o = 0.02,
                  c = 0.005;
                l.inputState.pinching && a > o + c
                  ? ((l.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: t.handedness,
                      target: this,
                    }))
                  : !l.inputState.pinching &&
                    a <= o - c &&
                    ((l.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: t.handedness,
                      target: this,
                    }));
              } else
                null !== o &&
                  t.gripSpace &&
                  ((r = e.getPose(t.gripSpace, n)),
                  null !== r &&
                    (o.matrix.fromArray(r.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    (o.matrixWorldNeedsUpdate = !0),
                    r.linearVelocity
                      ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(r.linearVelocity))
                      : (o.hasLinearVelocity = !1),
                    r.angularVelocity
                      ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(r.angularVelocity))
                      : (o.hasAngularVelocity = !1)));
              null !== a &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null === i && null !== r && (i = r),
                null !== i &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  (a.matrixWorldNeedsUpdate = !0),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(ra)));
            }
            return (
              null !== a && (a.visible = null !== i),
              null !== o && (o.visible = null !== r),
              null !== l && (l.visible = null !== s),
              this
            );
          }
          _getHandJoint(t, e) {
            if (void 0 === t.joints[e.jointName]) {
              const n = new ia();
              (n.matrixAutoUpdate = !1), (n.visible = !1), (t.joints[e.jointName] = n), t.add(n);
            }
            return t.joints[e.jointName];
          }
        }
        class aa extends vt {
          constructor(t, e) {
            super();
            const n = this;
            let i = null,
              r = 1,
              s = null,
              a = "local-floor",
              o = 1,
              l = null,
              c = null,
              h = null,
              u = null,
              d = null,
              p = null;
            const f = e.getContextAttributes();
            let m = null,
              g = null;
            const _ = [],
              v = [],
              x = new It();
            let y = null;
            const M = new gi();
            M.layers.enable(1), (M.viewport = new te());
            const S = new gi();
            S.layers.enable(2), (S.viewport = new te());
            const b = [M, S],
              E = new na();
            E.layers.enable(1), E.layers.enable(2);
            let T = null,
              A = null;
            function w(t) {
              const e = v.indexOf(t.inputSource);
              if (-1 === e) return;
              const n = _[e];
              void 0 !== n &&
                (n.update(t.inputSource, t.frame, l || s),
                n.dispatchEvent({ type: t.type, data: t.inputSource }));
            }
            function R() {
              i.removeEventListener("select", w),
                i.removeEventListener("selectstart", w),
                i.removeEventListener("selectend", w),
                i.removeEventListener("squeeze", w),
                i.removeEventListener("squeezestart", w),
                i.removeEventListener("squeezeend", w),
                i.removeEventListener("end", R),
                i.removeEventListener("inputsourceschange", C);
              for (let t = 0; t < _.length; t++) {
                const e = v[t];
                null !== e && ((v[t] = null), _[t].disconnect(e));
              }
              (T = null),
                (A = null),
                t.setRenderTarget(m),
                (d = null),
                (u = null),
                (h = null),
                (i = null),
                (g = null),
                O.stop(),
                (n.isPresenting = !1),
                t.setPixelRatio(y),
                t.setSize(x.width, x.height, !1),
                n.dispatchEvent({ type: "sessionend" });
            }
            function C(t) {
              for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                  i = v.indexOf(n);
                i >= 0 && ((v[i] = null), _[i].disconnect(n));
              }
              for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e];
                let i = v.indexOf(n);
                if (-1 === i) {
                  for (let t = 0; t < _.length; t++) {
                    if (t >= v.length) {
                      v.push(n), (i = t);
                      break;
                    }
                    if (null === v[t]) {
                      (v[t] = n), (i = t);
                      break;
                    }
                  }
                  if (-1 === i) break;
                }
                const r = _[i];
                r && r.connect(n);
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (t) {
                let e = _[t];
                return void 0 === e && ((e = new sa()), (_[t] = e)), e.getTargetRaySpace();
              }),
              (this.getControllerGrip = function (t) {
                let e = _[t];
                return void 0 === e && ((e = new sa()), (_[t] = e)), e.getGripSpace();
              }),
              (this.getHand = function (t) {
                let e = _[t];
                return void 0 === e && ((e = new sa()), (_[t] = e)), e.getHandSpace();
              }),
              (this.setFramebufferScaleFactor = function (t) {
                (r = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (this.setReferenceSpaceType = function (t) {
                (a = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (this.getReferenceSpace = function () {
                return l || s;
              }),
              (this.setReferenceSpace = function (t) {
                l = t;
              }),
              (this.getBaseLayer = function () {
                return null !== u ? u : d;
              }),
              (this.getBinding = function () {
                return h;
              }),
              (this.getFrame = function () {
                return p;
              }),
              (this.getSession = function () {
                return i;
              }),
              (this.setSession = async function (c) {
                if (((i = c), null !== i)) {
                  if (
                    ((m = t.getRenderTarget()),
                    i.addEventListener("select", w),
                    i.addEventListener("selectstart", w),
                    i.addEventListener("selectend", w),
                    i.addEventListener("squeeze", w),
                    i.addEventListener("squeezestart", w),
                    i.addEventListener("squeezeend", w),
                    i.addEventListener("end", R),
                    i.addEventListener("inputsourceschange", C),
                    !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                    (y = t.getPixelRatio()),
                    t.getSize(x),
                    void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2)
                  ) {
                    const n = {
                      antialias: void 0 !== i.renderState.layers || f.antialias,
                      alpha: !0,
                      depth: f.depth,
                      stencil: f.stencil,
                      framebufferScaleFactor: r,
                    };
                    (d = new XRWebGLLayer(i, e, n)),
                      i.updateRenderState({ baseLayer: d }),
                      t.setPixelRatio(1),
                      t.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                      (g = new ne(d.framebufferWidth, d.framebufferHeight, {
                        format: z,
                        type: U,
                        colorSpace: t.outputColorSpace,
                        stencilBuffer: f.stencil,
                      }));
                  } else {
                    let n = null,
                      s = null,
                      a = null;
                    f.depth &&
                      ((a = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                      (n = f.stencil ? G : H),
                      (s = f.stencil ? F : D));
                    const o = { colorFormat: e.RGBA8, depthFormat: a, scaleFactor: r };
                    (h = new XRWebGLBinding(i, e)),
                      (u = h.createProjectionLayer(o)),
                      i.updateRenderState({ layers: [u] }),
                      t.setPixelRatio(1),
                      t.setSize(u.textureWidth, u.textureHeight, !1),
                      (g = new ne(u.textureWidth, u.textureHeight, {
                        format: z,
                        type: U,
                        depthTexture: new ur(
                          u.textureWidth,
                          u.textureHeight,
                          s,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          n
                        ),
                        stencilBuffer: f.stencil,
                        colorSpace: t.outputColorSpace,
                        samples: f.antialias ? 4 : 0,
                      })),
                      (t.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues);
                  }
                  (g.isXRRenderTarget = !0),
                    this.setFoveation(o),
                    (l = null),
                    (s = await i.requestReferenceSpace(a)),
                    O.setContext(i),
                    O.start(),
                    (n.isPresenting = !0),
                    n.dispatchEvent({ type: "sessionstart" });
                }
              }),
              (this.getEnvironmentBlendMode = function () {
                if (null !== i) return i.environmentBlendMode;
              });
            const L = new ae(),
              P = new ae();
            function I(t, e) {
              null === e
                ? t.matrixWorld.copy(t.matrix)
                : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
            }
            (this.updateCamera = function (t) {
              if (null === i) return;
              (E.near = S.near = M.near = t.near),
                (E.far = S.far = M.far = t.far),
                (T === E.near && A === E.far) ||
                  (i.updateRenderState({ depthNear: E.near, depthFar: E.far }),
                  (T = E.near),
                  (A = E.far));
              const e = t.parent,
                n = E.cameras;
              I(E, e);
              for (let t = 0; t < n.length; t++) I(n[t], e);
              2 === n.length
                ? (function (t, e, n) {
                    L.setFromMatrixPosition(e.matrixWorld), P.setFromMatrixPosition(n.matrixWorld);
                    const i = L.distanceTo(P),
                      r = e.projectionMatrix.elements,
                      s = n.projectionMatrix.elements,
                      a = r[14] / (r[10] - 1),
                      o = r[14] / (r[10] + 1),
                      l = (r[9] + 1) / r[5],
                      c = (r[9] - 1) / r[5],
                      h = (r[8] - 1) / r[0],
                      u = (s[8] + 1) / s[0],
                      d = a * h,
                      p = a * u,
                      f = i / (-h + u),
                      m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                      t.translateX(m),
                      t.translateZ(f),
                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                      t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = a + f,
                      _ = o + f,
                      v = d - m,
                      x = p + (i - m),
                      y = ((l * o) / _) * g,
                      M = ((c * o) / _) * g;
                    t.projectionMatrix.makePerspective(v, x, y, M, g, _),
                      t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
                  })(E, M, S)
                : E.projectionMatrix.copy(M.projectionMatrix),
                (function (t, e, n) {
                  null === n
                    ? t.matrix.copy(e.matrixWorld)
                    : (t.matrix.copy(n.matrixWorld),
                      t.matrix.invert(),
                      t.matrix.multiply(e.matrixWorld)),
                    t.matrix.decompose(t.position, t.quaternion, t.scale),
                    t.updateMatrixWorld(!0),
                    t.projectionMatrix.copy(e.projectionMatrix),
                    t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                    t.isPerspectiveCamera &&
                      ((t.fov = 2 * St * Math.atan(1 / t.projectionMatrix.elements[5])),
                      (t.zoom = 1));
                })(t, E, e);
            }),
              (this.getCamera = function () {
                return E;
              }),
              (this.getFoveation = function () {
                if (null !== u || null !== d) return o;
              }),
              (this.setFoveation = function (t) {
                (o = t),
                  null !== u && (u.fixedFoveation = t),
                  null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
              });
            let N = null;
            const O = new Ri();
            O.setAnimationLoop(function (e, i) {
              if (((c = i.getViewerPose(l || s)), (p = i), null !== c)) {
                const e = c.views;
                null !== d &&
                  (t.setRenderTargetFramebuffer(g, d.framebuffer), t.setRenderTarget(g));
                let n = !1;
                e.length !== E.cameras.length && ((E.cameras.length = 0), (n = !0));
                for (let i = 0; i < e.length; i++) {
                  const r = e[i];
                  let s = null;
                  if (null !== d) s = d.getViewport(r);
                  else {
                    const e = h.getViewSubImage(u, r);
                    (s = e.viewport),
                      0 === i &&
                        (t.setRenderTargetTextures(
                          g,
                          e.colorTexture,
                          u.ignoreDepthValues ? void 0 : e.depthStencilTexture
                        ),
                        t.setRenderTarget(g));
                  }
                  let a = b[i];
                  void 0 === a &&
                    ((a = new gi()), a.layers.enable(i), (a.viewport = new te()), (b[i] = a)),
                    a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.quaternion, a.scale),
                    a.projectionMatrix.fromArray(r.projectionMatrix),
                    a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                    a.viewport.set(s.x, s.y, s.width, s.height),
                    0 === i &&
                      (E.matrix.copy(a.matrix),
                      E.matrix.decompose(E.position, E.quaternion, E.scale)),
                    !0 === n && E.cameras.push(a);
                }
              }
              for (let t = 0; t < _.length; t++) {
                const e = v[t],
                  n = _[t];
                null !== e && void 0 !== n && n.update(e, i, l || s);
              }
              N && N(e, i),
                i.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: i }),
                (p = null);
            }),
              (this.setAnimationLoop = function (t) {
                N = t;
              }),
              (this.dispose = function () {});
          }
        }
        function oa(t, e) {
          function n(t, e) {
            !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
          }
          function i(i, r) {
            (i.opacity.value = r.opacity),
              r.color && i.diffuse.value.copy(r.color),
              r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
              r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
              r.alphaMap && ((i.alphaMap.value = r.alphaMap), n(r.alphaMap, i.alphaMapTransform)),
              r.bumpMap &&
                ((i.bumpMap.value = r.bumpMap),
                n(r.bumpMap, i.bumpMapTransform),
                (i.bumpScale.value = r.bumpScale),
                1 === r.side && (i.bumpScale.value *= -1)),
              r.normalMap &&
                ((i.normalMap.value = r.normalMap),
                n(r.normalMap, i.normalMapTransform),
                i.normalScale.value.copy(r.normalScale),
                1 === r.side && i.normalScale.value.negate()),
              r.displacementMap &&
                ((i.displacementMap.value = r.displacementMap),
                n(r.displacementMap, i.displacementMapTransform),
                (i.displacementScale.value = r.displacementScale),
                (i.displacementBias.value = r.displacementBias)),
              r.emissiveMap &&
                ((i.emissiveMap.value = r.emissiveMap), n(r.emissiveMap, i.emissiveMapTransform)),
              r.specularMap &&
                ((i.specularMap.value = r.specularMap), n(r.specularMap, i.specularMapTransform)),
              r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
            const s = e.get(r).envMap;
            if (
              (s &&
                ((i.envMap.value = s),
                (i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
                (i.reflectivity.value = r.reflectivity),
                (i.ior.value = r.ior),
                (i.refractionRatio.value = r.refractionRatio)),
              r.lightMap)
            ) {
              i.lightMap.value = r.lightMap;
              const e = !0 === t._useLegacyLights ? Math.PI : 1;
              (i.lightMapIntensity.value = r.lightMapIntensity * e),
                n(r.lightMap, i.lightMapTransform);
            }
            r.aoMap &&
              ((i.aoMap.value = r.aoMap),
              (i.aoMapIntensity.value = r.aoMapIntensity),
              n(r.aoMap, i.aoMapTransform));
          }
          return {
            refreshFogUniforms: function (e, n) {
              n.color.getRGB(e.fogColor.value, di(t)),
                n.isFog
                  ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
                  : n.isFogExp2 && (e.fogDensity.value = n.density);
            },
            refreshMaterialUniforms: function (t, r, s, a, o) {
              r.isMeshBasicMaterial || r.isMeshLambertMaterial
                ? i(t, r)
                : r.isMeshToonMaterial
                ? (i(t, r),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                  })(t, r))
                : r.isMeshPhongMaterial
                ? (i(t, r),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4));
                  })(t, r))
                : r.isMeshStandardMaterial
                ? (i(t, r),
                  (function (t, i) {
                    (t.metalness.value = i.metalness),
                      i.metalnessMap &&
                        ((t.metalnessMap.value = i.metalnessMap),
                        n(i.metalnessMap, t.metalnessMapTransform)),
                      (t.roughness.value = i.roughness),
                      i.roughnessMap &&
                        ((t.roughnessMap.value = i.roughnessMap),
                        n(i.roughnessMap, t.roughnessMapTransform));
                    e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity);
                  })(t, r),
                  r.isMeshPhysicalMaterial &&
                    (function (t, e, i) {
                      (t.ior.value = e.ior),
                        e.sheen > 0 &&
                          (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                          (t.sheenRoughness.value = e.sheenRoughness),
                          e.sheenColorMap &&
                            ((t.sheenColorMap.value = e.sheenColorMap),
                            n(e.sheenColorMap, t.sheenColorMapTransform)),
                          e.sheenRoughnessMap &&
                            ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                            n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
                        e.clearcoat > 0 &&
                          ((t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.clearcoatMap &&
                            ((t.clearcoatMap.value = e.clearcoatMap),
                            n(e.clearcoatMap, t.clearcoatMapTransform)),
                          e.clearcoatRoughnessMap &&
                            ((t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                            n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)),
                          e.clearcoatNormalMap &&
                            ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                            n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                            t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                            1 === e.side && t.clearcoatNormalScale.value.negate())),
                        e.iridescence > 0 &&
                          ((t.iridescence.value = e.iridescence),
                          (t.iridescenceIOR.value = e.iridescenceIOR),
                          (t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0]),
                          (t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1]),
                          e.iridescenceMap &&
                            ((t.iridescenceMap.value = e.iridescenceMap),
                            n(e.iridescenceMap, t.iridescenceMapTransform)),
                          e.iridescenceThicknessMap &&
                            ((t.iridescenceThicknessMap.value = e.iridescenceThicknessMap),
                            n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))),
                        e.transmission > 0 &&
                          ((t.transmission.value = e.transmission),
                          (t.transmissionSamplerMap.value = i.texture),
                          t.transmissionSamplerSize.value.set(i.width, i.height),
                          e.transmissionMap &&
                            ((t.transmissionMap.value = e.transmissionMap),
                            n(e.transmissionMap, t.transmissionMapTransform)),
                          (t.thickness.value = e.thickness),
                          e.thicknessMap &&
                            ((t.thicknessMap.value = e.thicknessMap),
                            n(e.thicknessMap, t.thicknessMapTransform)),
                          (t.attenuationDistance.value = e.attenuationDistance),
                          t.attenuationColor.value.copy(e.attenuationColor)),
                        e.anisotropy > 0 &&
                          (t.anisotropyVector.value.set(
                            e.anisotropy * Math.cos(e.anisotropyRotation),
                            e.anisotropy * Math.sin(e.anisotropyRotation)
                          ),
                          e.anisotropyMap &&
                            ((t.anisotropyMap.value = e.anisotropyMap),
                            n(e.anisotropyMap, t.anisotropyMapTransform))),
                        (t.specularIntensity.value = e.specularIntensity),
                        t.specularColor.value.copy(e.specularColor),
                        e.specularColorMap &&
                          ((t.specularColorMap.value = e.specularColorMap),
                          n(e.specularColorMap, t.specularColorMapTransform)),
                        e.specularIntensityMap &&
                          ((t.specularIntensityMap.value = e.specularIntensityMap),
                          n(e.specularIntensityMap, t.specularIntensityMapTransform));
                    })(t, r, o))
                : r.isMeshMatcapMaterial
                ? (i(t, r),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                  })(t, r))
                : r.isMeshDepthMaterial
                ? i(t, r)
                : r.isMeshDistanceMaterial
                ? (i(t, r),
                  (function (t, n) {
                    const i = e.get(n).light;
                    t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                      (t.nearDistance.value = i.shadow.camera.near),
                      (t.farDistance.value = i.shadow.camera.far);
                  })(t, r))
                : r.isMeshNormalMaterial
                ? i(t, r)
                : r.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
                  })(t, r),
                  r.isLineDashedMaterial &&
                    (function (t, e) {
                      (t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale);
                    })(t, r))
                : r.isPointsMaterial
                ? (function (t, e, i, r) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * i),
                      (t.scale.value = 0.5 * r),
                      e.map && ((t.map.value = e.map), n(e.map, t.uvTransform)),
                      e.alphaMap &&
                        ((t.alphaMap.value = e.alphaMap), n(e.alphaMap, t.alphaMapTransform)),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                  })(t, r, s, a)
                : r.isSpriteMaterial
                ? (function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && ((t.map.value = e.map), n(e.map, t.mapTransform)),
                      e.alphaMap &&
                        ((t.alphaMap.value = e.alphaMap), n(e.alphaMap, t.alphaMapTransform)),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                  })(t, r)
                : r.isShadowMaterial
                ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
                : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
            },
          };
        }
        function la(t, e, n, i) {
          let r = {},
            s = {},
            a = [];
          const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
          function l(t, e, n, i) {
            const r = t.value,
              s = e + "_" + n;
            if (void 0 === i[s])
              return (i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone()), !0;
            {
              const t = i[s];
              if ("number" == typeof r || "boolean" == typeof r) {
                if (t !== r) return (i[s] = r), !0;
              } else if (!1 === t.equals(r)) return t.copy(r), !0;
            }
            return !1;
          }
          function c(t) {
            const e = { boundary: 0, storage: 0 };
            return (
              "number" == typeof t || "boolean" == typeof t
                ? ((e.boundary = 4), (e.storage = 4))
                : t.isVector2
                ? ((e.boundary = 8), (e.storage = 8))
                : t.isVector3 || t.isColor
                ? ((e.boundary = 16), (e.storage = 12))
                : t.isVector4
                ? ((e.boundary = 16), (e.storage = 16))
                : t.isMatrix3
                ? ((e.boundary = 48), (e.storage = 48))
                : t.isMatrix4
                ? ((e.boundary = 64), (e.storage = 64))
                : t.isTexture
                ? console.warn(
                    "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                  )
                : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t),
              e
            );
          }
          function h(e) {
            const n = e.target;
            n.removeEventListener("dispose", h);
            const i = a.indexOf(n.__bindingPointIndex);
            a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
          }
          return {
            bind: function (t, e) {
              const n = e.program;
              i.uniformBlockBinding(t, n);
            },
            update: function (n, u) {
              let d = r[n.id];
              void 0 === d &&
                ((function (t) {
                  const e = t.uniforms;
                  let n = 0;
                  for (let t = 0, i = e.length; t < i; t++) {
                    const i = Array.isArray(e[t]) ? e[t] : [e[t]];
                    for (let t = 0, e = i.length; t < e; t++) {
                      const e = i[t],
                        r = Array.isArray(e.value) ? e.value : [e.value];
                      for (let t = 0, i = r.length; t < i; t++) {
                        const i = c(r[t]),
                          s = n % 16;
                        0 !== s && 16 - s < i.boundary && (n += 16 - s),
                          (e.__data = new Float32Array(i.storage / Float32Array.BYTES_PER_ELEMENT)),
                          (e.__offset = n),
                          (n += i.storage);
                      }
                    }
                  }
                  const i = n % 16;
                  i > 0 && (n += 16 - i), (t.__size = n), (t.__cache = {});
                })(n),
                (d = (function (e) {
                  const n = (function () {
                    for (let t = 0; t < o; t++) if (-1 === a.indexOf(t)) return a.push(t), t;
                    return (
                      console.error(
                        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                      ),
                      0
                    );
                  })();
                  e.__bindingPointIndex = n;
                  const i = t.createBuffer(),
                    r = e.__size,
                    s = e.usage;
                  return (
                    t.bindBuffer(t.UNIFORM_BUFFER, i),
                    t.bufferData(t.UNIFORM_BUFFER, r, s),
                    t.bindBuffer(t.UNIFORM_BUFFER, null),
                    t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                    i
                  );
                })(n)),
                (r[n.id] = d),
                n.addEventListener("dispose", h));
              const p = u.program;
              i.updateUBOMapping(n, p);
              const f = e.render.frame;
              s[n.id] !== f &&
                ((function (e) {
                  const n = r[e.id],
                    i = e.uniforms,
                    s = e.__cache;
                  t.bindBuffer(t.UNIFORM_BUFFER, n);
                  for (let e = 0, n = i.length; e < n; e++) {
                    const n = Array.isArray(i[e]) ? i[e] : [i[e]];
                    for (let i = 0, r = n.length; i < r; i++) {
                      const r = n[i];
                      if (!0 === l(r, e, i, s)) {
                        const e = r.__offset,
                          n = Array.isArray(r.value) ? r.value : [r.value];
                        let i = 0;
                        for (let s = 0; s < n.length; s++) {
                          const a = n[s],
                            o = c(a);
                          "number" == typeof a || "boolean" == typeof a
                            ? ((r.__data[0] = a),
                              t.bufferSubData(t.UNIFORM_BUFFER, e + i, r.__data))
                            : a.isMatrix3
                            ? ((r.__data[0] = a.elements[0]),
                              (r.__data[1] = a.elements[1]),
                              (r.__data[2] = a.elements[2]),
                              (r.__data[3] = 0),
                              (r.__data[4] = a.elements[3]),
                              (r.__data[5] = a.elements[4]),
                              (r.__data[6] = a.elements[5]),
                              (r.__data[7] = 0),
                              (r.__data[8] = a.elements[6]),
                              (r.__data[9] = a.elements[7]),
                              (r.__data[10] = a.elements[8]),
                              (r.__data[11] = 0))
                            : (a.toArray(r.__data, i),
                              (i += o.storage / Float32Array.BYTES_PER_ELEMENT));
                        }
                        t.bufferSubData(t.UNIFORM_BUFFER, e, r.__data);
                      }
                    }
                  }
                  t.bindBuffer(t.UNIFORM_BUFFER, null);
                })(n),
                (s[n.id] = f));
            },
            dispose: function () {
              for (const e in r) t.deleteBuffer(r[e]);
              (a = []), (r = {}), (s = {});
            },
          };
        }
        class ca {
          constructor(t = {}) {
            const {
              canvas: e = Bt(),
              context: n = null,
              depth: r = !0,
              stencil: s = !0,
              alpha: a = !1,
              antialias: c = !1,
              premultipliedAlpha: h = !0,
              preserveDrawingBuffer: u = !1,
              powerPreference: d = "default",
              failIfMajorPerformanceCaveat: f = !1,
            } = t;
            let m;
            (this.isWebGLRenderer = !0), (m = null !== n ? n.getContextAttributes().alpha : a);
            const g = new Uint32Array(4),
              _ = new Int32Array(4);
            let v = null,
              x = null;
            const y = [],
              M = [];
            (this.domElement = e),
              (this.debug = { checkShaderErrors: !0, onShaderError: null }),
              (this.autoClear = !0),
              (this.autoClearColor = !0),
              (this.autoClearDepth = !0),
              (this.autoClearStencil = !0),
              (this.sortObjects = !0),
              (this.clippingPlanes = []),
              (this.localClippingEnabled = !1),
              (this._outputColorSpace = rt),
              (this._useLegacyLights = !1),
              (this.toneMapping = p),
              (this.toneMappingExposure = 1);
            const S = this;
            let b = !1,
              E = 0,
              T = 0,
              A = null,
              w = -1,
              R = null;
            const C = new te(),
              L = new te();
            let P = null;
            const H = new Tn(0);
            let G = 0,
              k = e.width,
              V = e.height,
              W = 1,
              X = null,
              j = null;
            const q = new te(0, 0, k, V),
              Y = new te(0, 0, k, V);
            let K = !1;
            const Z = new wi();
            let J = !1,
              Q = !1,
              $ = null;
            const tt = new Oe(),
              et = new It(),
              nt = new ae(),
              it = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0,
              };
            function at() {
              return null === A ? W : 1;
            }
            let ot,
              lt,
              ct,
              ht,
              ut,
              dt,
              pt,
              ft,
              mt,
              gt,
              _t,
              vt,
              xt,
              yt,
              Mt,
              St,
              bt,
              Et,
              Tt,
              At,
              wt,
              Ct,
              Lt,
              Pt,
              Ut = n;
            function Nt(t, n) {
              for (let i = 0; i < t.length; i++) {
                const r = t[i],
                  s = e.getContext(r, n);
                if (null !== s) return s;
              }
              return null;
            }
            try {
              const t = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: c,
                premultipliedAlpha: h,
                preserveDrawingBuffer: u,
                powerPreference: d,
                failIfMajorPerformanceCaveat: f,
              };
              if (
                ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${i}`),
                e.addEventListener("webglcontextlost", Ft, !1),
                e.addEventListener("webglcontextrestored", zt, !1),
                e.addEventListener("webglcontextcreationerror", Ht, !1),
                null === Ut)
              ) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if ((!0 === S.isWebGL1Renderer && e.shift(), (Ut = Nt(e, t)), null === Ut))
                  throw Nt(e)
                    ? new Error("Error creating WebGL context with your selected attributes.")
                    : new Error("Error creating WebGL context.");
              }
              "undefined" != typeof WebGLRenderingContext &&
                Ut instanceof WebGLRenderingContext &&
                console.warn(
                  "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
                ),
                void 0 === Ut.getShaderPrecisionFormat &&
                  (Ut.getShaderPrecisionFormat = function () {
                    return { rangeMin: 1, rangeMax: 1, precision: 1 };
                  });
            } catch (t) {
              throw (console.error("THREE.WebGLRenderer: " + t.message), t);
            }
            function Dt() {
              (ot = new ir(Ut)),
                (lt = new Fi(Ut, ot, t)),
                ot.init(lt),
                (Ct = new ea(Ut, ot, lt)),
                (ct = new $s(Ut, ot, lt)),
                (ht = new ar(Ut)),
                (ut = new zs()),
                (dt = new ta(Ut, ot, ct, ut, lt, Ct, ht)),
                (pt = new Hi(S)),
                (ft = new nr(S)),
                (mt = new Ci(Ut, lt)),
                (Lt = new Oi(Ut, ot, mt, lt)),
                (gt = new rr(Ut, mt, ht, Lt)),
                (_t = new hr(Ut, gt, mt, ht)),
                (Tt = new cr(Ut, lt, dt)),
                (St = new zi(ut)),
                (vt = new Fs(S, pt, ft, ot, lt, Lt, St)),
                (xt = new oa(S, ut)),
                (yt = new Vs()),
                (Mt = new Ks(ot, lt)),
                (Et = new Di(S, pt, ft, ct, _t, m, h)),
                (bt = new Qs(S, _t, lt)),
                (Pt = new la(Ut, ht, lt, ct)),
                (At = new Bi(Ut, ot, ht, lt)),
                (wt = new sr(Ut, ot, ht, lt)),
                (ht.programs = vt.programs),
                (S.capabilities = lt),
                (S.extensions = ot),
                (S.properties = ut),
                (S.renderLists = yt),
                (S.shadowMap = bt),
                (S.state = ct),
                (S.info = ht);
            }
            Dt();
            const Ot = new aa(S, Ut);
            function Ft(t) {
              t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (b = !0);
            }
            function zt() {
              console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
              const t = ht.autoReset,
                e = bt.enabled,
                n = bt.autoUpdate,
                i = bt.needsUpdate,
                r = bt.type;
              Dt(),
                (ht.autoReset = t),
                (bt.enabled = e),
                (bt.autoUpdate = n),
                (bt.needsUpdate = i),
                (bt.type = r);
            }
            function Ht(t) {
              console.error(
                "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
                t.statusMessage
              );
            }
            function Gt(t) {
              const e = t.target;
              e.removeEventListener("dispose", Gt),
                (function (t) {
                  (function (t) {
                    const e = ut.get(t).programs;
                    void 0 !== e &&
                      (e.forEach(function (t) {
                        vt.releaseProgram(t);
                      }),
                      t.isShaderMaterial && vt.releaseShaderCache(t));
                  })(t),
                    ut.remove(t);
                })(e);
            }
            function kt(t, e, n) {
              !0 === t.transparent && t.side === l && !1 === t.forceSinglePass
                ? ((t.side = 1),
                  (t.needsUpdate = !0),
                  Jt(t, e, n),
                  (t.side = o),
                  (t.needsUpdate = !0),
                  Jt(t, e, n),
                  (t.side = l))
                : Jt(t, e, n);
            }
            (this.xr = Ot),
              (this.getContext = function () {
                return Ut;
              }),
              (this.getContextAttributes = function () {
                return Ut.getContextAttributes();
              }),
              (this.forceContextLoss = function () {
                const t = ot.get("WEBGL_lose_context");
                t && t.loseContext();
              }),
              (this.forceContextRestore = function () {
                const t = ot.get("WEBGL_lose_context");
                t && t.restoreContext();
              }),
              (this.getPixelRatio = function () {
                return W;
              }),
              (this.setPixelRatio = function (t) {
                void 0 !== t && ((W = t), this.setSize(k, V, !1));
              }),
              (this.getSize = function (t) {
                return t.set(k, V);
              }),
              (this.setSize = function (t, n, i = !0) {
                Ot.isPresenting
                  ? console.warn(
                      "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                    )
                  : ((k = t),
                    (V = n),
                    (e.width = Math.floor(t * W)),
                    (e.height = Math.floor(n * W)),
                    !0 === i && ((e.style.width = t + "px"), (e.style.height = n + "px")),
                    this.setViewport(0, 0, t, n));
              }),
              (this.getDrawingBufferSize = function (t) {
                return t.set(k * W, V * W).floor();
              }),
              (this.setDrawingBufferSize = function (t, n, i) {
                (k = t),
                  (V = n),
                  (W = i),
                  (e.width = Math.floor(t * i)),
                  (e.height = Math.floor(n * i)),
                  this.setViewport(0, 0, t, n);
              }),
              (this.getCurrentViewport = function (t) {
                return t.copy(C);
              }),
              (this.getViewport = function (t) {
                return t.copy(q);
              }),
              (this.setViewport = function (t, e, n, i) {
                t.isVector4 ? q.set(t.x, t.y, t.z, t.w) : q.set(t, e, n, i),
                  ct.viewport(C.copy(q).multiplyScalar(W).floor());
              }),
              (this.getScissor = function (t) {
                return t.copy(Y);
              }),
              (this.setScissor = function (t, e, n, i) {
                t.isVector4 ? Y.set(t.x, t.y, t.z, t.w) : Y.set(t, e, n, i),
                  ct.scissor(L.copy(Y).multiplyScalar(W).floor());
              }),
              (this.getScissorTest = function () {
                return K;
              }),
              (this.setScissorTest = function (t) {
                ct.setScissorTest((K = t));
              }),
              (this.setOpaqueSort = function (t) {
                X = t;
              }),
              (this.setTransparentSort = function (t) {
                j = t;
              }),
              (this.getClearColor = function (t) {
                return t.copy(Et.getClearColor());
              }),
              (this.setClearColor = function () {
                Et.setClearColor.apply(Et, arguments);
              }),
              (this.getClearAlpha = function () {
                return Et.getClearAlpha();
              }),
              (this.setClearAlpha = function () {
                Et.setClearAlpha.apply(Et, arguments);
              }),
              (this.clear = function (t = !0, e = !0, n = !0) {
                let i = 0;
                if (t) {
                  let t = !1;
                  if (null !== A) {
                    const e = A.texture.format;
                    t = 1033 === e || 1031 === e || 1029 === e;
                  }
                  if (t) {
                    const t = A.texture.type,
                      e = t === U || t === D || t === N || t === F || 1017 === t || 1018 === t,
                      n = Et.getClearColor(),
                      i = Et.getClearAlpha(),
                      r = n.r,
                      s = n.g,
                      a = n.b;
                    e
                      ? ((g[0] = r),
                        (g[1] = s),
                        (g[2] = a),
                        (g[3] = i),
                        Ut.clearBufferuiv(Ut.COLOR, 0, g))
                      : ((_[0] = r),
                        (_[1] = s),
                        (_[2] = a),
                        (_[3] = i),
                        Ut.clearBufferiv(Ut.COLOR, 0, _));
                  } else i |= Ut.COLOR_BUFFER_BIT;
                }
                e && (i |= Ut.DEPTH_BUFFER_BIT),
                  n &&
                    ((i |= Ut.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)),
                  Ut.clear(i);
              }),
              (this.clearColor = function () {
                this.clear(!0, !1, !1);
              }),
              (this.clearDepth = function () {
                this.clear(!1, !0, !1);
              }),
              (this.clearStencil = function () {
                this.clear(!1, !1, !0);
              }),
              (this.dispose = function () {
                e.removeEventListener("webglcontextlost", Ft, !1),
                  e.removeEventListener("webglcontextrestored", zt, !1),
                  e.removeEventListener("webglcontextcreationerror", Ht, !1),
                  yt.dispose(),
                  Mt.dispose(),
                  ut.dispose(),
                  pt.dispose(),
                  ft.dispose(),
                  _t.dispose(),
                  Lt.dispose(),
                  Pt.dispose(),
                  vt.dispose(),
                  Ot.dispose(),
                  Ot.removeEventListener("sessionstart", Wt),
                  Ot.removeEventListener("sessionend", Xt),
                  $ && ($.dispose(), ($ = null)),
                  jt.stop();
              }),
              (this.renderBufferDirect = function (t, e, n, i, r, s) {
                null === e && (e = it);
                const a = r.isMesh && r.matrixWorld.determinant() < 0,
                  o = (function (t, e, n, i, r) {
                    !0 !== e.isScene && (e = it), dt.resetTextureUnits();
                    const s = e.fog,
                      a = i.isMeshStandardMaterial ? e.environment : null,
                      o =
                        null === A
                          ? S.outputColorSpace
                          : !0 === A.isXRRenderTarget
                          ? A.texture.colorSpace
                          : st,
                      l = (i.isMeshStandardMaterial ? ft : pt).get(i.envMap || a),
                      c =
                        !0 === i.vertexColors &&
                        !!n.attributes.color &&
                        4 === n.attributes.color.itemSize,
                      h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                      u = !!n.morphAttributes.position,
                      d = !!n.morphAttributes.normal,
                      f = !!n.morphAttributes.color;
                    let m = p;
                    i.toneMapped &&
                      ((null !== A && !0 !== A.isXRRenderTarget) || (m = S.toneMapping));
                    const g =
                        n.morphAttributes.position ||
                        n.morphAttributes.normal ||
                        n.morphAttributes.color,
                      _ = void 0 !== g ? g.length : 0,
                      v = ut.get(i),
                      y = x.state.lights;
                    if (!0 === J && (!0 === Q || t !== R)) {
                      const e = t === R && i.id === w;
                      St.setState(i, t, e);
                    }
                    let M = !1;
                    i.version === v.__version
                      ? (v.needsLights && v.lightsStateVersion !== y.state.version) ||
                        v.outputColorSpace !== o ||
                        (r.isBatchedMesh && !1 === v.batching)
                        ? (M = !0)
                        : r.isBatchedMesh || !0 !== v.batching
                        ? r.isInstancedMesh && !1 === v.instancing
                          ? (M = !0)
                          : r.isInstancedMesh || !0 !== v.instancing
                          ? r.isSkinnedMesh && !1 === v.skinning
                            ? (M = !0)
                            : r.isSkinnedMesh || !0 !== v.skinning
                            ? (r.isInstancedMesh &&
                                !0 === v.instancingColor &&
                                null === r.instanceColor) ||
                              (r.isInstancedMesh &&
                                !1 === v.instancingColor &&
                                null !== r.instanceColor) ||
                              v.envMap !== l ||
                              (!0 === i.fog && v.fog !== s)
                              ? (M = !0)
                              : void 0 === v.numClippingPlanes ||
                                (v.numClippingPlanes === St.numPlanes &&
                                  v.numIntersection === St.numIntersection)
                              ? (v.vertexAlphas !== c ||
                                  v.vertexTangents !== h ||
                                  v.morphTargets !== u ||
                                  v.morphNormals !== d ||
                                  v.morphColors !== f ||
                                  v.toneMapping !== m ||
                                  (!0 === lt.isWebGL2 && v.morphTargetsCount !== _)) &&
                                (M = !0)
                              : (M = !0)
                            : (M = !0)
                          : (M = !0)
                        : (M = !0)
                      : ((M = !0), (v.__version = i.version));
                    let b = v.currentProgram;
                    !0 === M && (b = Jt(i, e, r));
                    let E = !1,
                      T = !1,
                      C = !1;
                    const L = b.getUniforms(),
                      P = v.uniforms;
                    if (
                      (ct.useProgram(b.program) && ((E = !0), (T = !0), (C = !0)),
                      i.id !== w && ((w = i.id), (T = !0)),
                      E || R !== t)
                    ) {
                      L.setValue(Ut, "projectionMatrix", t.projectionMatrix),
                        L.setValue(Ut, "viewMatrix", t.matrixWorldInverse);
                      const e = L.map.cameraPosition;
                      void 0 !== e && e.setValue(Ut, nt.setFromMatrixPosition(t.matrixWorld)),
                        lt.logarithmicDepthBuffer &&
                          L.setValue(Ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                        (i.isMeshPhongMaterial ||
                          i.isMeshToonMaterial ||
                          i.isMeshLambertMaterial ||
                          i.isMeshBasicMaterial ||
                          i.isMeshStandardMaterial ||
                          i.isShaderMaterial) &&
                          L.setValue(Ut, "isOrthographic", !0 === t.isOrthographicCamera),
                        R !== t && ((R = t), (T = !0), (C = !0));
                    }
                    if (r.isSkinnedMesh) {
                      L.setOptional(Ut, r, "bindMatrix"), L.setOptional(Ut, r, "bindMatrixInverse");
                      const t = r.skeleton;
                      t &&
                        (lt.floatVertexTextures
                          ? (null === t.boneTexture && t.computeBoneTexture(),
                            L.setValue(Ut, "boneTexture", t.boneTexture, dt))
                          : console.warn(
                              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                            ));
                    }
                    r.isBatchedMesh &&
                      (L.setOptional(Ut, r, "batchingTexture"),
                      L.setValue(Ut, "batchingTexture", r._matricesTexture, dt));
                    const I = n.morphAttributes;
                    var U, N;
                    if (
                      ((void 0 !== I.position ||
                        void 0 !== I.normal ||
                        (void 0 !== I.color && !0 === lt.isWebGL2)) &&
                        Tt.update(r, n, b),
                      (T || v.receiveShadow !== r.receiveShadow) &&
                        ((v.receiveShadow = r.receiveShadow),
                        L.setValue(Ut, "receiveShadow", r.receiveShadow)),
                      i.isMeshGouraudMaterial &&
                        null !== i.envMap &&
                        ((P.envMap.value = l),
                        (P.flipEnvMap.value =
                          l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1)),
                      T &&
                        (L.setValue(Ut, "toneMappingExposure", S.toneMappingExposure),
                        v.needsLights &&
                          ((N = C),
                          ((U = P).ambientLightColor.needsUpdate = N),
                          (U.lightProbe.needsUpdate = N),
                          (U.directionalLights.needsUpdate = N),
                          (U.directionalLightShadows.needsUpdate = N),
                          (U.pointLights.needsUpdate = N),
                          (U.pointLightShadows.needsUpdate = N),
                          (U.spotLights.needsUpdate = N),
                          (U.spotLightShadows.needsUpdate = N),
                          (U.rectAreaLights.needsUpdate = N),
                          (U.hemisphereLights.needsUpdate = N)),
                        s && !0 === i.fog && xt.refreshFogUniforms(P, s),
                        xt.refreshMaterialUniforms(P, i, W, V, $),
                        gs.upload(Ut, Qt(v), P, dt)),
                      i.isShaderMaterial &&
                        !0 === i.uniformsNeedUpdate &&
                        (gs.upload(Ut, Qt(v), P, dt), (i.uniformsNeedUpdate = !1)),
                      i.isSpriteMaterial && L.setValue(Ut, "center", r.center),
                      L.setValue(Ut, "modelViewMatrix", r.modelViewMatrix),
                      L.setValue(Ut, "normalMatrix", r.normalMatrix),
                      L.setValue(Ut, "modelMatrix", r.matrixWorld),
                      i.isShaderMaterial || i.isRawShaderMaterial)
                    ) {
                      const t = i.uniformsGroups;
                      for (let e = 0, n = t.length; e < n; e++)
                        if (lt.isWebGL2) {
                          const n = t[e];
                          Pt.update(n, b), Pt.bind(n, b);
                        } else
                          console.warn(
                            "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                          );
                    }
                    return b;
                  })(t, e, n, i, r);
                ct.setMaterial(i, a);
                let l = n.index,
                  c = 1;
                if (!0 === i.wireframe) {
                  if (((l = gt.getWireframeAttribute(n)), void 0 === l)) return;
                  c = 2;
                }
                const h = n.drawRange,
                  u = n.attributes.position;
                let d = h.start * c,
                  f = (h.start + h.count) * c;
                null !== s &&
                  ((d = Math.max(d, s.start * c)), (f = Math.min(f, (s.start + s.count) * c))),
                  null !== l
                    ? ((d = Math.max(d, 0)), (f = Math.min(f, l.count)))
                    : null != u && ((d = Math.max(d, 0)), (f = Math.min(f, u.count)));
                const m = f - d;
                if (m < 0 || m === 1 / 0) return;
                let g;
                Lt.setup(r, i, o, n, l);
                let _ = At;
                if ((null !== l && ((g = mt.get(l)), (_ = wt), _.setIndex(g)), r.isMesh))
                  !0 === i.wireframe
                    ? (ct.setLineWidth(i.wireframeLinewidth * at()), _.setMode(Ut.LINES))
                    : _.setMode(Ut.TRIANGLES);
                else if (r.isLine) {
                  let t = i.linewidth;
                  void 0 === t && (t = 1),
                    ct.setLineWidth(t * at()),
                    r.isLineSegments
                      ? _.setMode(Ut.LINES)
                      : r.isLineLoop
                      ? _.setMode(Ut.LINE_LOOP)
                      : _.setMode(Ut.LINE_STRIP);
                } else r.isPoints ? _.setMode(Ut.POINTS) : r.isSprite && _.setMode(Ut.TRIANGLES);
                if (r.isBatchedMesh)
                  _.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                else if (r.isInstancedMesh) _.renderInstances(d, m, r.count);
                else if (n.isInstancedBufferGeometry) {
                  const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                    e = Math.min(n.instanceCount, t);
                  _.renderInstances(d, m, e);
                } else _.render(d, m);
              }),
              (this.compile = function (t, e, n = null) {
                null === n && (n = t),
                  (x = Mt.get(n)),
                  x.init(),
                  M.push(x),
                  n.traverseVisible(function (t) {
                    t.isLight &&
                      t.layers.test(e.layers) &&
                      (x.pushLight(t), t.castShadow && x.pushShadow(t));
                  }),
                  t !== n &&
                    t.traverseVisible(function (t) {
                      t.isLight &&
                        t.layers.test(e.layers) &&
                        (x.pushLight(t), t.castShadow && x.pushShadow(t));
                    }),
                  x.setupLights(S._useLegacyLights);
                const i = new Set();
                return (
                  t.traverse(function (t) {
                    const e = t.material;
                    if (e)
                      if (Array.isArray(e))
                        for (let r = 0; r < e.length; r++) {
                          const s = e[r];
                          kt(s, n, t), i.add(s);
                        }
                      else kt(e, n, t), i.add(e);
                  }),
                  M.pop(),
                  (x = null),
                  i
                );
              }),
              (this.compileAsync = function (t, e, n = null) {
                const i = this.compile(t, e, n);
                return new Promise((e) => {
                  function n() {
                    i.forEach(function (t) {
                      ut.get(t).currentProgram.isReady() && i.delete(t);
                    }),
                      0 !== i.size ? setTimeout(n, 10) : e(t);
                  }
                  null !== ot.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10);
                });
              });
            let Vt = null;
            function Wt() {
              jt.stop();
            }
            function Xt() {
              jt.start();
            }
            const jt = new Ri();
            function qt(t, e, n, i) {
              if (!1 === t.visible) return;
              if (t.layers.test(e.layers))
                if (t.isGroup) n = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight) x.pushLight(t), t.castShadow && x.pushShadow(t);
                else if (t.isSprite) {
                  if (!t.frustumCulled || Z.intersectsSprite(t)) {
                    i && nt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(tt);
                    const e = _t.update(t),
                      r = t.material;
                    r.visible && v.push(t, e, r, n, nt.z, null);
                  }
                } else if (
                  (t.isMesh || t.isLine || t.isPoints) &&
                  (!t.frustumCulled || Z.intersectsObject(t))
                ) {
                  const e = _t.update(t),
                    r = t.material;
                  if (
                    (i &&
                      (void 0 !== t.boundingSphere
                        ? (null === t.boundingSphere && t.computeBoundingSphere(),
                          nt.copy(t.boundingSphere.center))
                        : (null === e.boundingSphere && e.computeBoundingSphere(),
                          nt.copy(e.boundingSphere.center)),
                      nt.applyMatrix4(t.matrixWorld).applyMatrix4(tt)),
                    Array.isArray(r))
                  ) {
                    const i = e.groups;
                    for (let s = 0, a = i.length; s < a; s++) {
                      const a = i[s],
                        o = r[a.materialIndex];
                      o && o.visible && v.push(t, e, o, n, nt.z, a);
                    }
                  } else r.visible && v.push(t, e, r, n, nt.z, null);
                }
              const r = t.children;
              for (let t = 0, s = r.length; t < s; t++) qt(r[t], e, n, i);
            }
            function Yt(t, e, n, i) {
              const r = t.opaque,
                s = t.transmissive,
                a = t.transparent;
              x.setupLightsView(n),
                !0 === J && St.setGlobalState(S.clippingPlanes, n),
                s.length > 0 &&
                  (function (t, e, n, i) {
                    if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
                    const r = lt.isWebGL2;
                    null === $ &&
                      ($ = new ne(1, 1, {
                        generateMipmaps: !0,
                        type: ot.has("EXT_color_buffer_half_float") ? B : U,
                        minFilter: I,
                        samples: r ? 4 : 0,
                      })),
                      S.getDrawingBufferSize(et),
                      r ? $.setSize(et.x, et.y) : $.setSize(Rt(et.x), Rt(et.y));
                    const s = S.getRenderTarget();
                    S.setRenderTarget($),
                      S.getClearColor(H),
                      (G = S.getClearAlpha()),
                      G < 1 && S.setClearColor(16777215, 0.5),
                      S.clear();
                    const a = S.toneMapping;
                    (S.toneMapping = p),
                      Kt(t, n, i),
                      dt.updateMultisampleRenderTarget($),
                      dt.updateRenderTargetMipmap($);
                    let o = !1;
                    for (let t = 0, r = e.length; t < r; t++) {
                      const r = e[t],
                        s = r.object,
                        a = r.geometry,
                        c = r.material,
                        h = r.group;
                      if (c.side === l && s.layers.test(i.layers)) {
                        const t = c.side;
                        (c.side = 1),
                          (c.needsUpdate = !0),
                          Zt(s, n, i, a, c, h),
                          (c.side = t),
                          (c.needsUpdate = !0),
                          (o = !0);
                      }
                    }
                    !0 === o &&
                      (dt.updateMultisampleRenderTarget($), dt.updateRenderTargetMipmap($)),
                      S.setRenderTarget(s),
                      S.setClearColor(H, G),
                      (S.toneMapping = a);
                  })(r, s, e, n),
                i && ct.viewport(C.copy(i)),
                r.length > 0 && Kt(r, e, n),
                s.length > 0 && Kt(s, e, n),
                a.length > 0 && Kt(a, e, n),
                ct.buffers.depth.setTest(!0),
                ct.buffers.depth.setMask(!0),
                ct.buffers.color.setMask(!0),
                ct.setPolygonOffset(!1);
            }
            function Kt(t, e, n) {
              const i = !0 === e.isScene ? e.overrideMaterial : null;
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = s.object,
                  o = s.geometry,
                  l = null === i ? s.material : i,
                  c = s.group;
                a.layers.test(n.layers) && Zt(a, e, n, o, l, c);
              }
            }
            function Zt(t, e, n, i, r, s) {
              t.onBeforeRender(S, e, n, i, r, s),
                t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                r.onBeforeRender(S, e, n, i, t, s),
                !0 === r.transparent && r.side === l && !1 === r.forceSinglePass
                  ? ((r.side = 1),
                    (r.needsUpdate = !0),
                    S.renderBufferDirect(n, e, i, r, t, s),
                    (r.side = o),
                    (r.needsUpdate = !0),
                    S.renderBufferDirect(n, e, i, r, t, s),
                    (r.side = l))
                  : S.renderBufferDirect(n, e, i, r, t, s),
                t.onAfterRender(S, e, n, i, r, s);
            }
            function Jt(t, e, n) {
              !0 !== e.isScene && (e = it);
              const i = ut.get(t),
                r = x.state.lights,
                s = x.state.shadowsArray,
                a = r.state.version,
                o = vt.getParameters(t, r.state, s, e, n),
                l = vt.getProgramCacheKey(o);
              let c = i.programs;
              (i.environment = t.isMeshStandardMaterial ? e.environment : null),
                (i.fog = e.fog),
                (i.envMap = (t.isMeshStandardMaterial ? ft : pt).get(t.envMap || i.environment)),
                void 0 === c &&
                  (t.addEventListener("dispose", Gt), (c = new Map()), (i.programs = c));
              let h = c.get(l);
              if (void 0 !== h) {
                if (i.currentProgram === h && i.lightsStateVersion === a) return $t(t, o), h;
              } else
                (o.uniforms = vt.getUniforms(t)),
                  t.onBuild(n, o, S),
                  t.onBeforeCompile(o, S),
                  (h = vt.acquireProgram(o, l)),
                  c.set(l, h),
                  (i.uniforms = o.uniforms);
              const u = i.uniforms;
              return (
                ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
                  (u.clippingPlanes = St.uniform),
                $t(t, o),
                (i.needsLights = (function (t) {
                  return (
                    t.isMeshLambertMaterial ||
                    t.isMeshToonMaterial ||
                    t.isMeshPhongMaterial ||
                    t.isMeshStandardMaterial ||
                    t.isShadowMaterial ||
                    (t.isShaderMaterial && !0 === t.lights)
                  );
                })(t)),
                (i.lightsStateVersion = a),
                i.needsLights &&
                  ((u.ambientLightColor.value = r.state.ambient),
                  (u.lightProbe.value = r.state.probe),
                  (u.directionalLights.value = r.state.directional),
                  (u.directionalLightShadows.value = r.state.directionalShadow),
                  (u.spotLights.value = r.state.spot),
                  (u.spotLightShadows.value = r.state.spotShadow),
                  (u.rectAreaLights.value = r.state.rectArea),
                  (u.ltc_1.value = r.state.rectAreaLTC1),
                  (u.ltc_2.value = r.state.rectAreaLTC2),
                  (u.pointLights.value = r.state.point),
                  (u.pointLightShadows.value = r.state.pointShadow),
                  (u.hemisphereLights.value = r.state.hemi),
                  (u.directionalShadowMap.value = r.state.directionalShadowMap),
                  (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
                  (u.spotShadowMap.value = r.state.spotShadowMap),
                  (u.spotLightMatrix.value = r.state.spotLightMatrix),
                  (u.spotLightMap.value = r.state.spotLightMap),
                  (u.pointShadowMap.value = r.state.pointShadowMap),
                  (u.pointShadowMatrix.value = r.state.pointShadowMatrix)),
                (i.currentProgram = h),
                (i.uniformsList = null),
                h
              );
            }
            function Qt(t) {
              if (null === t.uniformsList) {
                const e = t.currentProgram.getUniforms();
                t.uniformsList = gs.seqWithValue(e.seq, t.uniforms);
              }
              return t.uniformsList;
            }
            function $t(t, e) {
              const n = ut.get(t);
              (n.outputColorSpace = e.outputColorSpace),
                (n.batching = e.batching),
                (n.instancing = e.instancing),
                (n.instancingColor = e.instancingColor),
                (n.skinning = e.skinning),
                (n.morphTargets = e.morphTargets),
                (n.morphNormals = e.morphNormals),
                (n.morphColors = e.morphColors),
                (n.morphTargetsCount = e.morphTargetsCount),
                (n.numClippingPlanes = e.numClippingPlanes),
                (n.numIntersection = e.numClipIntersection),
                (n.vertexAlphas = e.vertexAlphas),
                (n.vertexTangents = e.vertexTangents),
                (n.toneMapping = e.toneMapping);
            }
            jt.setAnimationLoop(function (t) {
              Vt && Vt(t);
            }),
              "undefined" != typeof self && jt.setContext(self),
              (this.setAnimationLoop = function (t) {
                (Vt = t), Ot.setAnimationLoop(t), null === t ? jt.stop() : jt.start();
              }),
              Ot.addEventListener("sessionstart", Wt),
              Ot.addEventListener("sessionend", Xt),
              (this.render = function (t, e) {
                if (void 0 !== e && !0 !== e.isCamera)
                  return void console.error(
                    "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                  );
                if (!0 === b) return;
                !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                  null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                  !0 === Ot.enabled &&
                    !0 === Ot.isPresenting &&
                    (!0 === Ot.cameraAutoUpdate && Ot.updateCamera(e), (e = Ot.getCamera())),
                  !0 === t.isScene && t.onBeforeRender(S, t, e, A),
                  (x = Mt.get(t, M.length)),
                  x.init(),
                  M.push(x),
                  tt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                  Z.setFromProjectionMatrix(tt),
                  (Q = this.localClippingEnabled),
                  (J = St.init(this.clippingPlanes, Q)),
                  (v = yt.get(t, y.length)),
                  v.init(),
                  y.push(v),
                  qt(t, e, 0, S.sortObjects),
                  v.finish(),
                  !0 === S.sortObjects && v.sort(X, j),
                  this.info.render.frame++,
                  !0 === J && St.beginShadows();
                const n = x.state.shadowsArray;
                if (
                  (bt.render(n, t, e),
                  !0 === J && St.endShadows(),
                  !0 === this.info.autoReset && this.info.reset(),
                  Et.render(v, t),
                  x.setupLights(S._useLegacyLights),
                  e.isArrayCamera)
                ) {
                  const n = e.cameras;
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    Yt(v, t, i, i.viewport);
                  }
                } else Yt(v, t, e);
                null !== A && (dt.updateMultisampleRenderTarget(A), dt.updateRenderTargetMipmap(A)),
                  !0 === t.isScene && t.onAfterRender(S, t, e),
                  Lt.resetDefaultState(),
                  (w = -1),
                  (R = null),
                  M.pop(),
                  (x = M.length > 0 ? M[M.length - 1] : null),
                  y.pop(),
                  (v = y.length > 0 ? y[y.length - 1] : null);
              }),
              (this.getActiveCubeFace = function () {
                return E;
              }),
              (this.getActiveMipmapLevel = function () {
                return T;
              }),
              (this.getRenderTarget = function () {
                return A;
              }),
              (this.setRenderTargetTextures = function (t, e, n) {
                (ut.get(t.texture).__webglTexture = e), (ut.get(t.depthTexture).__webglTexture = n);
                const i = ut.get(t);
                (i.__hasExternalTextures = !0),
                  i.__hasExternalTextures &&
                    ((i.__autoAllocateDepthBuffer = void 0 === n),
                    i.__autoAllocateDepthBuffer ||
                      (!0 === ot.has("WEBGL_multisampled_render_to_texture") &&
                        (console.warn(
                          "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                        ),
                        (i.__useRenderToTexture = !1))));
              }),
              (this.setRenderTargetFramebuffer = function (t, e) {
                const n = ut.get(t);
                (n.__webglFramebuffer = e), (n.__useDefaultFramebuffer = void 0 === e);
              }),
              (this.setRenderTarget = function (t, e = 0, n = 0) {
                (A = t), (E = e), (T = n);
                let i = !0,
                  r = null,
                  s = !1,
                  a = !1;
                if (t) {
                  const o = ut.get(t);
                  void 0 !== o.__useDefaultFramebuffer
                    ? (ct.bindFramebuffer(Ut.FRAMEBUFFER, null), (i = !1))
                    : void 0 === o.__webglFramebuffer
                    ? dt.setupRenderTarget(t)
                    : o.__hasExternalTextures &&
                      dt.rebindTextures(
                        t,
                        ut.get(t.texture).__webglTexture,
                        ut.get(t.depthTexture).__webglTexture
                      );
                  const l = t.texture;
                  (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) &&
                    (a = !0);
                  const c = ut.get(t).__webglFramebuffer;
                  t.isWebGLCubeRenderTarget
                    ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
                    : (r =
                        lt.isWebGL2 && t.samples > 0 && !1 === dt.useMultisampledRTT(t)
                          ? ut.get(t).__webglMultisampledFramebuffer
                          : Array.isArray(c)
                          ? c[n]
                          : c),
                    C.copy(t.viewport),
                    L.copy(t.scissor),
                    (P = t.scissorTest);
                } else
                  C.copy(q).multiplyScalar(W).floor(), L.copy(Y).multiplyScalar(W).floor(), (P = K);
                if (
                  (ct.bindFramebuffer(Ut.FRAMEBUFFER, r) &&
                    lt.drawBuffers &&
                    i &&
                    ct.drawBuffers(t, r),
                  ct.viewport(C),
                  ct.scissor(L),
                  ct.setScissorTest(P),
                  s)
                ) {
                  const i = ut.get(t.texture);
                  Ut.framebufferTexture2D(
                    Ut.FRAMEBUFFER,
                    Ut.COLOR_ATTACHMENT0,
                    Ut.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    i.__webglTexture,
                    n
                  );
                } else if (a) {
                  const i = ut.get(t.texture),
                    r = e || 0;
                  Ut.framebufferTextureLayer(
                    Ut.FRAMEBUFFER,
                    Ut.COLOR_ATTACHMENT0,
                    i.__webglTexture,
                    n || 0,
                    r
                  );
                }
                w = -1;
              }),
              (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
                if (!t || !t.isWebGLRenderTarget)
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                  );
                let o = ut.get(t).__webglFramebuffer;
                if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
                  ct.bindFramebuffer(Ut.FRAMEBUFFER, o);
                  try {
                    const a = t.texture,
                      o = a.format,
                      l = a.type;
                    if (
                      o !== z &&
                      Ct.convert(o) !== Ut.getParameter(Ut.IMPLEMENTATION_COLOR_READ_FORMAT)
                    )
                      return void console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                      );
                    const c =
                      l === B &&
                      (ot.has("EXT_color_buffer_half_float") ||
                        (lt.isWebGL2 && ot.has("EXT_color_buffer_float")));
                    if (
                      !(
                        l === U ||
                        Ct.convert(l) === Ut.getParameter(Ut.IMPLEMENTATION_COLOR_READ_TYPE) ||
                        (l === O &&
                          (lt.isWebGL2 ||
                            ot.has("OES_texture_float") ||
                            ot.has("WEBGL_color_buffer_float"))) ||
                        c
                      )
                    )
                      return void console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                      );
                    e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      Ut.readPixels(e, n, i, r, Ct.convert(o), Ct.convert(l), s);
                  } finally {
                    const t = null !== A ? ut.get(A).__webglFramebuffer : null;
                    ct.bindFramebuffer(Ut.FRAMEBUFFER, t);
                  }
                }
              }),
              (this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n),
                  r = Math.floor(e.image.width * i),
                  s = Math.floor(e.image.height * i);
                dt.setTexture2D(e, 0),
                  Ut.copyTexSubImage2D(Ut.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
                  ct.unbindTexture();
              }),
              (this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width,
                  s = e.image.height,
                  a = Ct.convert(n.format),
                  o = Ct.convert(n.type);
                dt.setTexture2D(n, 0),
                  Ut.pixelStorei(Ut.UNPACK_FLIP_Y_WEBGL, n.flipY),
                  Ut.pixelStorei(Ut.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                  Ut.pixelStorei(Ut.UNPACK_ALIGNMENT, n.unpackAlignment),
                  e.isDataTexture
                    ? Ut.texSubImage2D(Ut.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data)
                    : e.isCompressedTexture
                    ? Ut.compressedTexSubImage2D(
                        Ut.TEXTURE_2D,
                        i,
                        t.x,
                        t.y,
                        e.mipmaps[0].width,
                        e.mipmaps[0].height,
                        a,
                        e.mipmaps[0].data
                      )
                    : Ut.texSubImage2D(Ut.TEXTURE_2D, i, t.x, t.y, a, o, e.image),
                  0 === i && n.generateMipmaps && Ut.generateMipmap(Ut.TEXTURE_2D),
                  ct.unbindTexture();
              }),
              (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                if (S.isWebGL1Renderer)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                  );
                const s = t.max.x - t.min.x + 1,
                  a = t.max.y - t.min.y + 1,
                  o = t.max.z - t.min.z + 1,
                  l = Ct.convert(i.format),
                  c = Ct.convert(i.type);
                let h;
                if (i.isData3DTexture) dt.setTexture3D(i, 0), (h = Ut.TEXTURE_3D);
                else {
                  if (!i.isDataArrayTexture && !i.isCompressedArrayTexture)
                    return void console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                    );
                  dt.setTexture2DArray(i, 0), (h = Ut.TEXTURE_2D_ARRAY);
                }
                Ut.pixelStorei(Ut.UNPACK_FLIP_Y_WEBGL, i.flipY),
                  Ut.pixelStorei(Ut.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                  Ut.pixelStorei(Ut.UNPACK_ALIGNMENT, i.unpackAlignment);
                const u = Ut.getParameter(Ut.UNPACK_ROW_LENGTH),
                  d = Ut.getParameter(Ut.UNPACK_IMAGE_HEIGHT),
                  p = Ut.getParameter(Ut.UNPACK_SKIP_PIXELS),
                  f = Ut.getParameter(Ut.UNPACK_SKIP_ROWS),
                  m = Ut.getParameter(Ut.UNPACK_SKIP_IMAGES),
                  g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
                Ut.pixelStorei(Ut.UNPACK_ROW_LENGTH, g.width),
                  Ut.pixelStorei(Ut.UNPACK_IMAGE_HEIGHT, g.height),
                  Ut.pixelStorei(Ut.UNPACK_SKIP_PIXELS, t.min.x),
                  Ut.pixelStorei(Ut.UNPACK_SKIP_ROWS, t.min.y),
                  Ut.pixelStorei(Ut.UNPACK_SKIP_IMAGES, t.min.z),
                  n.isDataTexture || n.isData3DTexture
                    ? Ut.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data)
                    : n.isCompressedArrayTexture
                    ? (console.warn(
                        "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                      ),
                      Ut.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data))
                    : Ut.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g),
                  Ut.pixelStorei(Ut.UNPACK_ROW_LENGTH, u),
                  Ut.pixelStorei(Ut.UNPACK_IMAGE_HEIGHT, d),
                  Ut.pixelStorei(Ut.UNPACK_SKIP_PIXELS, p),
                  Ut.pixelStorei(Ut.UNPACK_SKIP_ROWS, f),
                  Ut.pixelStorei(Ut.UNPACK_SKIP_IMAGES, m),
                  0 === r && i.generateMipmaps && Ut.generateMipmap(h),
                  ct.unbindTexture();
              }),
              (this.initTexture = function (t) {
                t.isCubeTexture
                  ? dt.setTextureCube(t, 0)
                  : t.isData3DTexture
                  ? dt.setTexture3D(t, 0)
                  : t.isDataArrayTexture || t.isCompressedArrayTexture
                  ? dt.setTexture2DArray(t, 0)
                  : dt.setTexture2D(t, 0),
                  ct.unbindTexture();
              }),
              (this.resetState = function () {
                (E = 0), (T = 0), (A = null), ct.reset(), Lt.reset();
              }),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
          get coordinateSystem() {
            return gt;
          }
          get outputColorSpace() {
            return this._outputColorSpace;
          }
          set outputColorSpace(t) {
            this._outputColorSpace = t;
            const e = this.getContext();
            (e.drawingBufferColorSpace = t === at ? "display-p3" : "srgb"),
              (e.unpackColorSpace = Wt.workingColorSpace === ot ? "display-p3" : "srgb");
          }
          get outputEncoding() {
            return (
              console.warn(
                "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
              ),
              this.outputColorSpace === rt ? nt : 3e3
            );
          }
          set outputEncoding(t) {
            console.warn(
              "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
            ),
              (this.outputColorSpace = t === nt ? rt : st);
          }
          get useLegacyLights() {
            return (
              console.warn(
                "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
              ),
              this._useLegacyLights
            );
          }
          set useLegacyLights(t) {
            console.warn(
              "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
            ),
              (this._useLegacyLights = t);
          }
        }
        (class extends ca {}).prototype.isWebGL1Renderer = !0;
        class ha {
          constructor(t, e) {
            (this.isInterleavedBuffer = !0),
              (this.array = t),
              (this.stride = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.usage = pt),
              (this._updateRange = { offset: 0, count: -1 }),
              (this.updateRanges = []),
              (this.version = 0),
              (this.uuid = bt());
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          get updateRange() {
            return (
              console.warn(
                "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
              ),
              this._updateRange
            );
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          addUpdateRange(t, e) {
            this.updateRanges.push({ start: t, count: e });
          }
          clearUpdateRanges() {
            this.updateRanges.length = 0;
          }
          copy(t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = bt()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
              n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n;
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          toJSON(t) {
            return (
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = bt()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
                  new Uint32Array(this.array.buffer)
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        }
        const ua = new ae();
        class da {
          constructor(t, e, n, i = !1) {
            (this.isInterleavedBufferAttribute = !0),
              (this.name = ""),
              (this.data = t),
              (this.itemSize = e),
              (this.offset = n),
              (this.normalized = i);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(t) {
            this.data.needsUpdate = t;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
              ua.fromBufferAttribute(this, e), ua.applyMatrix4(t), this.setXYZ(e, ua.x, ua.y, ua.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              ua.fromBufferAttribute(this, e),
                ua.applyNormalMatrix(t),
                this.setXYZ(e, ua.x, ua.y, ua.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              ua.fromBufferAttribute(this, e),
                ua.transformDirection(t),
                this.setXYZ(e, ua.x, ua.y, ua.z);
            return this;
          }
          setX(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset] = e),
              this
            );
          }
          setY(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          }
          setZ(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          }
          setW(t, e) {
            return (
              this.normalized && (e = Lt(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          }
          getX(t) {
            let e = this.data.array[t * this.data.stride + this.offset];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          getY(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 1];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          getZ(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 2];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          getW(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 3];
            return this.normalized && (e = Ct(e, this.array)), e;
          }
          setXY(t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized && ((e = Lt(e, this.array)), (n = Lt(n, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = Lt(e, this.array)), (n = Lt(n, this.array)), (i = Lt(i, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = Lt(e, this.array)),
                (n = Lt(n, this.array)),
                (i = Lt(i, this.array)),
                (r = Lt(r, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              (this.data.array[t + 3] = r),
              this
            );
          }
          clone(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
              }
              return new In(new this.array.constructor(t), this.itemSize, this.normalized);
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new da(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          }
          toJSON(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          }
        }
        const pa = new ae(),
          fa = new te(),
          ma = new te(),
          ga = new ae(),
          _a = new Oe(),
          va = new ae(),
          xa = new we(),
          ya = new Oe(),
          Ma = new De();
        class Sa extends oi {
          constructor(t, e) {
            super(t, e),
              (this.isSkinnedMesh = !0),
              (this.type = "SkinnedMesh"),
              (this.bindMode = y),
              (this.bindMatrix = new Oe()),
              (this.bindMatrixInverse = new Oe()),
              (this.boundingBox = null),
              (this.boundingSphere = null);
          }
          computeBoundingBox() {
            const t = this.geometry;
            null === this.boundingBox && (this.boundingBox = new ce()),
              this.boundingBox.makeEmpty();
            const e = t.getAttribute("position");
            for (let t = 0; t < e.count; t++)
              this.getVertexPosition(t, va), this.boundingBox.expandByPoint(va);
          }
          computeBoundingSphere() {
            const t = this.geometry;
            null === this.boundingSphere && (this.boundingSphere = new we()),
              this.boundingSphere.makeEmpty();
            const e = t.getAttribute("position");
            for (let t = 0; t < e.count; t++)
              this.getVertexPosition(t, va), this.boundingSphere.expandByPoint(va);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              this
            );
          }
          raycast(t, e) {
            const n = this.material,
              i = this.matrixWorld;
            void 0 !== n &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              xa.copy(this.boundingSphere),
              xa.applyMatrix4(i),
              !1 !== t.ray.intersectsSphere(xa) &&
                (ya.copy(i).invert(),
                Ma.copy(t.ray).applyMatrix4(ya),
                (null !== this.boundingBox && !1 === Ma.intersectsBox(this.boundingBox)) ||
                  this._computeIntersections(t, e, Ma)));
          }
          getVertexPosition(t, e) {
            return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
          }
          bind(t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights() {
            const t = new te(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
              t.fromBufferAttribute(e, n);
              const i = 1 / t.manhattanLength();
              i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              this.bindMode === y
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : "detached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
          applyBoneTransform(t, e) {
            const n = this.skeleton,
              i = this.geometry;
            fa.fromBufferAttribute(i.attributes.skinIndex, t),
              ma.fromBufferAttribute(i.attributes.skinWeight, t),
              pa.copy(e).applyMatrix4(this.bindMatrix),
              e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
              const i = ma.getComponent(t);
              if (0 !== i) {
                const r = fa.getComponent(t);
                _a.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(ga.copy(pa).applyMatrix4(_a), i);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          }
          boneTransform(t, e) {
            return (
              console.warn(
                "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
              ),
              this.applyBoneTransform(t, e)
            );
          }
        }
        class ba extends ln {
          constructor() {
            super(), (this.isBone = !0), (this.type = "Bone");
          }
        }
        class Ea extends $t {
          constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = w, c = w, h, u) {
            super(null, s, a, o, l, c, i, r, h, u),
              (this.isDataTexture = !0),
              (this.image = { data: t, width: e, height: n }),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        const Ta = new Oe(),
          Aa = new Oe();
        class wa {
          constructor(t = [], e = []) {
            (this.uuid = bt()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length))
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Oe());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new Oe();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i] ? t[i].matrixWorld : Aa;
              Ta.multiplyMatrices(r, e[i]), Ta.toArray(n, 16 * i);
            }
            null !== i && (i.needsUpdate = !0);
          }
          clone() {
            return new wa(this.bones, this.boneInverses);
          }
          computeBoneTexture() {
            let t = Math.sqrt(4 * this.bones.length);
            (t = 4 * Math.ceil(t / 4)), (t = Math.max(t, 4));
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new Ea(e, t, t, z, O);
            return (n.needsUpdate = !0), (this.boneMatrices = e), (this.boneTexture = n), this;
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
              const i = t.bones[n];
              let r = e[i];
              void 0 === r &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", i), (r = new ba())),
                this.bones.push(r),
                this.boneInverses.push(new Oe().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i];
              t.bones.push(r.uuid);
              const s = n[i];
              t.boneInverses.push(s.toArray());
            }
            return t;
          }
        }
        class Ra extends In {
          constructor(t, e, n, i = 1) {
            super(t, e, n), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = i);
          }
          copy(t) {
            return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t
            );
          }
        }
        const Ca = new Oe(),
          La = new Oe(),
          Pa = [],
          Ia = new ce(),
          Ua = new Oe(),
          Na = new oi(),
          Da = new we();
        class Oa extends oi {
          constructor(t, e, n) {
            super(t, e),
              (this.isInstancedMesh = !0),
              (this.instanceMatrix = new Ra(new Float32Array(16 * n), 16)),
              (this.instanceColor = null),
              (this.count = n),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            for (let t = 0; t < n; t++) this.setMatrixAt(t, Ua);
          }
          computeBoundingBox() {
            const t = this.geometry,
              e = this.count;
            null === this.boundingBox && (this.boundingBox = new ce()),
              null === t.boundingBox && t.computeBoundingBox(),
              this.boundingBox.makeEmpty();
            for (let n = 0; n < e; n++)
              this.getMatrixAt(n, Ca),
                Ia.copy(t.boundingBox).applyMatrix4(Ca),
                this.boundingBox.union(Ia);
          }
          computeBoundingSphere() {
            const t = this.geometry,
              e = this.count;
            null === this.boundingSphere && (this.boundingSphere = new we()),
              null === t.boundingSphere && t.computeBoundingSphere(),
              this.boundingSphere.makeEmpty();
            for (let n = 0; n < e; n++)
              this.getMatrixAt(n, Ca),
                Da.copy(t.boundingSphere).applyMatrix4(Ca),
                this.boundingSphere.union(Da);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              this
            );
          }
          getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          }
          getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          }
          raycast(t, e) {
            const n = this.matrixWorld,
              i = this.count;
            if (
              ((Na.geometry = this.geometry),
              (Na.material = this.material),
              void 0 !== Na.material &&
                (null === this.boundingSphere && this.computeBoundingSphere(),
                Da.copy(this.boundingSphere),
                Da.applyMatrix4(n),
                !1 !== t.ray.intersectsSphere(Da)))
            )
              for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, Ca),
                  La.multiplyMatrices(n, Ca),
                  (Na.matrixWorld = La),
                  Na.raycast(t, Pa);
                for (let t = 0, n = Pa.length; t < n; t++) {
                  const n = Pa[t];
                  (n.instanceId = r), (n.object = this), e.push(n);
                }
                Pa.length = 0;
              }
          }
          setColorAt(t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new Ra(new Float32Array(3 * this.instanceMatrix.count), 3)),
              e.toArray(this.instanceColor.array, 3 * t);
          }
          setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        class Ba extends Rn {
          constructor(t) {
            super(),
              (this.isLineBasicMaterial = !0),
              (this.type = "LineBasicMaterial"),
              (this.color = new Tn(16777215)),
              (this.map = null),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        const Fa = new ae(),
          za = new ae(),
          Ha = new Oe(),
          Ga = new De(),
          ka = new we();
        class Va extends ln {
          constructor(t = new Vn(), e = new Ba()) {
            super(),
              (this.isLine = !0),
              (this.type = "Line"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
              const e = t.attributes.position,
                n = [0];
              for (let t = 1, i = e.count; t < i; t++)
                Fa.fromBufferAttribute(e, t - 1),
                  za.fromBufferAttribute(e, t),
                  (n[t] = n[t - 1]),
                  (n[t] += Fa.distanceTo(za));
              t.setAttribute("lineDistance", new Dn(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Line.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              ka.copy(n.boundingSphere),
              ka.applyMatrix4(i),
              (ka.radius += r),
              !1 === t.ray.intersectsSphere(ka))
            )
              return;
            Ha.copy(i).invert(), Ga.copy(t.ray).applyMatrix4(Ha);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              l = new ae(),
              c = new ae(),
              h = new ae(),
              u = new ae(),
              d = this.isLineSegments ? 2 : 1,
              p = n.index,
              f = n.attributes.position;
            if (null !== p)
              for (
                let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                const i = p.getX(n),
                  r = p.getX(n + 1);
                if (
                  (l.fromBufferAttribute(f, i),
                  c.fromBufferAttribute(f, r),
                  Ga.distanceSqToSegment(l, c, u, h) > o)
                )
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const s = t.ray.origin.distanceTo(u);
                s < t.near ||
                  s > t.far ||
                  e.push({
                    distance: s,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            else
              for (
                let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                if (
                  (l.fromBufferAttribute(f, n),
                  c.fromBufferAttribute(f, n + 1),
                  Ga.distanceSqToSegment(l, c, u, h) > o)
                )
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const i = t.ray.origin.distanceTo(u);
                i < t.near ||
                  i > t.far ||
                  e.push({
                    distance: i,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
        }
        const Wa = new ae(),
          Xa = new ae();
        class ja extends Va {
          constructor(t, e) {
            super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
          }
          computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
              const e = t.attributes.position,
                n = [];
              for (let t = 0, i = e.count; t < i; t += 2)
                Wa.fromBufferAttribute(e, t),
                  Xa.fromBufferAttribute(e, t + 1),
                  (n[t] = 0 === t ? 0 : n[t - 1]),
                  (n[t + 1] = n[t] + Wa.distanceTo(Xa));
              t.setAttribute("lineDistance", new Dn(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
        }
        class qa extends Va {
          constructor(t, e) {
            super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
          }
        }
        class Ya extends Rn {
          constructor(t) {
            super(),
              (this.isPointsMaterial = !0),
              (this.type = "PointsMaterial"),
              (this.color = new Tn(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.fog = t.fog),
              this
            );
          }
        }
        const Ka = new Oe(),
          Za = new De(),
          Ja = new we(),
          Qa = new ae();
        class $a extends ln {
          constructor(t = new Vn(), e = new Ya()) {
            super(),
              (this.isPoints = !0),
              (this.type = "Points"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.material = Array.isArray(t.material) ? t.material.slice() : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Points.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Ja.copy(n.boundingSphere),
              Ja.applyMatrix4(i),
              (Ja.radius += r),
              !1 === t.ray.intersectsSphere(Ja))
            )
              return;
            Ka.copy(i).invert(), Za.copy(t.ray).applyMatrix4(Ka);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              l = n.index,
              c = n.attributes.position;
            if (null !== l)
              for (
                let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count);
                n < r;
                n++
              ) {
                const r = l.getX(n);
                Qa.fromBufferAttribute(c, r), to(Qa, r, o, i, t, e, this);
              }
            else
              for (
                let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count);
                n < r;
                n++
              )
                Qa.fromBufferAttribute(c, n), to(Qa, n, o, i, t, e, this);
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
        }
        function to(t, e, n, i, r, s, a) {
          const o = Za.distanceSqToPoint(t);
          if (o < n) {
            const n = new ae();
            Za.closestPointToPoint(t, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            s.push({
              distance: l,
              distanceToRay: Math.sqrt(o),
              point: n,
              index: e,
              face: null,
              object: a,
            });
          }
        }
        class eo extends Rn {
          constructor(t) {
            super(),
              (this.isMeshStandardMaterial = !0),
              (this.defines = { STANDARD: "" }),
              (this.type = "MeshStandardMaterial"),
              (this.color = new Tn(16777215)),
              (this.roughness = 1),
              (this.metalness = 0),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Tn(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new It(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.roughnessMap = null),
              (this.metalnessMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.envMapIntensity = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "" }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              (this.fog = t.fog),
              this
            );
          }
        }
        class no extends eo {
          constructor(t) {
            super(),
              (this.isMeshPhysicalMaterial = !0),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.type = "MeshPhysicalMaterial"),
              (this.anisotropyRotation = 0),
              (this.anisotropyMap = null),
              (this.clearcoatMap = null),
              (this.clearcoatRoughness = 0),
              (this.clearcoatRoughnessMap = null),
              (this.clearcoatNormalScale = new It(1, 1)),
              (this.clearcoatNormalMap = null),
              (this.ior = 1.5),
              Object.defineProperty(this, "reflectivity", {
                get: function () {
                  return Et((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                  this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
              }),
              (this.iridescenceMap = null),
              (this.iridescenceIOR = 1.3),
              (this.iridescenceThicknessRange = [100, 400]),
              (this.iridescenceThicknessMap = null),
              (this.sheenColor = new Tn(0)),
              (this.sheenColorMap = null),
              (this.sheenRoughness = 1),
              (this.sheenRoughnessMap = null),
              (this.transmissionMap = null),
              (this.thickness = 0),
              (this.thicknessMap = null),
              (this.attenuationDistance = 1 / 0),
              (this.attenuationColor = new Tn(1, 1, 1)),
              (this.specularIntensity = 1),
              (this.specularIntensityMap = null),
              (this.specularColor = new Tn(1, 1, 1)),
              (this.specularColorMap = null),
              (this._anisotropy = 0),
              (this._clearcoat = 0),
              (this._iridescence = 0),
              (this._sheen = 0),
              (this._transmission = 0),
              this.setValues(t);
          }
          get anisotropy() {
            return this._anisotropy;
          }
          set anisotropy(t) {
            this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t);
          }
          get clearcoat() {
            return this._clearcoat;
          }
          set clearcoat(t) {
            this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
          }
          get iridescence() {
            return this._iridescence;
          }
          set iridescence(t) {
            this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t);
          }
          get sheen() {
            return this._sheen;
          }
          set sheen(t) {
            this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
          }
          get transmission() {
            return this._transmission;
          }
          set transmission(t) {
            this._transmission > 0 != t > 0 && this.version++, (this._transmission = t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.anisotropy = t.anisotropy),
              (this.anisotropyRotation = t.anisotropyRotation),
              (this.anisotropyMap = t.anisotropyMap),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.ior = t.ior),
              (this.iridescence = t.iridescence),
              (this.iridescenceMap = t.iridescenceMap),
              (this.iridescenceIOR = t.iridescenceIOR),
              (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
              (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
              (this.sheen = t.sheen),
              this.sheenColor.copy(t.sheenColor),
              (this.sheenColorMap = t.sheenColorMap),
              (this.sheenRoughness = t.sheenRoughness),
              (this.sheenRoughnessMap = t.sheenRoughnessMap),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              (this.thickness = t.thickness),
              (this.thicknessMap = t.thicknessMap),
              (this.attenuationDistance = t.attenuationDistance),
              this.attenuationColor.copy(t.attenuationColor),
              (this.specularIntensity = t.specularIntensity),
              (this.specularIntensityMap = t.specularIntensityMap),
              this.specularColor.copy(t.specularColor),
              (this.specularColorMap = t.specularColorMap),
              this
            );
          }
        }
        function io(t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        }
        function ro(t) {
          const e = t.length,
            n = new Array(e);
          for (let t = 0; t !== e; ++t) n[t] = t;
          return (
            n.sort(function (e, n) {
              return t[e] - t[n];
            }),
            n
          );
        }
        function so(t, e, n) {
          const i = t.length,
            r = new t.constructor(i);
          for (let s = 0, a = 0; a !== i; ++s) {
            const i = n[s] * e;
            for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
          }
          return r;
        }
        function ao(t, e, n, i) {
          let r = 1,
            s = t[0];
          for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
          if (void 0 === s) return;
          let a = s[i];
          if (void 0 !== a)
            if (Array.isArray(a))
              do {
                (a = s[i]), void 0 !== a && (e.push(s.time), n.push.apply(n, a)), (s = t[r++]);
              } while (void 0 !== s);
            else if (void 0 !== a.toArray)
              do {
                (a = s[i]), void 0 !== a && (e.push(s.time), a.toArray(n, n.length)), (s = t[r++]);
              } while (void 0 !== s);
            else
              do {
                (a = s[i]), void 0 !== a && (e.push(s.time), n.push(a)), (s = t[r++]);
              } while (void 0 !== s);
        }
        class oo {
          constructor(t, e, n, i) {
            (this.parameterPositions = t),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
              (this.sampleValues = e),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              i = e[n],
              r = e[n - 1];
            t: {
              e: {
                let s;
                n: {
                  i: if (!(t < i)) {
                    for (let s = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i;
                        return (
                          (n = e.length), (this._cachedIndex = n), this.copySampleValue_(n - 1)
                        );
                      }
                      if (n === s) break;
                      if (((r = i), (i = e[++n]), t < i)) break e;
                    }
                    s = e.length;
                    break n;
                  }
                  if (t >= r) break t;
                  {
                    const a = e[1];
                    t < a && ((n = 2), (r = a));
                    for (let s = n - 2; ; ) {
                      if (void 0 === r) return (this._cachedIndex = 0), this.copySampleValue_(0);
                      if (n === s) break;
                      if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                    }
                    (s = n), (n = 0);
                  }
                }
                for (; n < s; ) {
                  const i = (n + s) >>> 1;
                  t < e[i] ? (s = i) : (n = i + 1);
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (void 0 === i)
                  return (n = e.length), (this._cachedIndex = n), this.copySampleValue_(n - 1);
              }
              (this._cachedIndex = n), this.intervalChanged_(n, r, i);
            }
            return this.interpolate_(n, r, t, i);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e;
          }
          interpolate_() {
            throw new Error("call to abstract method");
          }
          intervalChanged_() {}
        }
        class lo extends oo {
          constructor(t, e, n, i) {
            super(t, e, n, i),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: Z, endingEnd: Z });
          }
          intervalChanged_(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2,
              s = t + 1,
              a = i[r],
              o = i[s];
            if (void 0 === a)
              switch (this.getSettings_().endingStart) {
                case J:
                  (r = t), (a = 2 * e - n);
                  break;
                case Q:
                  (r = i.length - 2), (a = e + i[r] - i[r + 1]);
                  break;
                default:
                  (r = t), (a = n);
              }
            if (void 0 === o)
              switch (this.getSettings_().endingEnd) {
                case J:
                  (s = t), (o = 2 * n - e);
                  break;
                case Q:
                  (s = 1), (o = n + i[1] - i[0]);
                  break;
                default:
                  (s = t - 1), (o = e);
              }
            const l = 0.5 * (n - e),
              c = this.valueSize;
            (this._weightPrev = l / (e - a)),
              (this._weightNext = l / (o - n)),
              (this._offsetPrev = r * c),
              (this._offsetNext = s * c);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = t * a,
              l = o - a,
              c = this._offsetPrev,
              h = this._offsetNext,
              u = this._weightPrev,
              d = this._weightNext,
              p = (n - e) / (i - e),
              f = p * p,
              m = f * p,
              g = -u * m + 2 * u * f - u * p,
              _ = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
              v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
              x = d * m - d * f;
            for (let t = 0; t !== a; ++t)
              r[t] = g * s[c + t] + _ * s[l + t] + v * s[o + t] + x * s[h + t];
            return r;
          }
        }
        class co extends oo {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = t * a,
              l = o - a,
              c = (n - e) / (i - e),
              h = 1 - c;
            for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
            return r;
          }
        }
        class ho extends oo {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t) {
            return this.copySampleValue_(t - 1);
          }
        }
        class uo {
          constructor(t, e, n, i) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
              throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            (this.name = t),
              (this.times = io(e, this.TimeBufferType)),
              (this.values = io(n, this.ValueBufferType)),
              this.setInterpolation(i || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = { name: t.name, times: io(t.times, Array), values: io(t.values, Array) };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new ho(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new co(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new lo(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case q:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case Y:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case K:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return q;
              case this.InterpolantFactoryMethodLinear:
                return Y;
              case this.InterpolantFactoryMethodSmooth:
                return K;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              i = n.length;
            let r = 0,
              s = i - 1;
            for (; r !== i && n[r] < t; ) ++r;
            for (; -1 !== s && n[s] > e; ) --s;
            if ((++s, 0 !== r || s !== i)) {
              r >= s && ((s = Math.max(s, 1)), (r = s - 1));
              const t = this.getValueSize();
              (this.times = n.slice(r, s)), (this.values = this.values.slice(r * t, s * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), (t = !1));
            const n = this.times,
              i = this.values,
              r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
            let s = null;
            for (let e = 0; e !== r; e++) {
              const i = n[e];
              if ("number" == typeof i && isNaN(i)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                  (t = !1);
                break;
              }
              if (null !== s && s > i) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), (t = !1);
                break;
              }
              s = i;
            }
            if (void 0 !== i && ((a = i), ArrayBuffer.isView(a) && !(a instanceof DataView)))
              for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e];
                if (isNaN(n)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                    (t = !1);
                  break;
                }
              }
            var a;
            return t;
          }
          optimize() {
            const t = this.times.slice(),
              e = this.values.slice(),
              n = this.getValueSize(),
              i = this.getInterpolation() === K,
              r = t.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
              let r = !1;
              const o = t[a];
              if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                if (i) r = !0;
                else {
                  const t = a * n,
                    i = t - n,
                    s = t + n;
                  for (let a = 0; a !== n; ++a) {
                    const n = e[t + a];
                    if (n !== e[i + a] || n !== e[s + a]) {
                      r = !0;
                      break;
                    }
                  }
                }
              if (r) {
                if (a !== s) {
                  t[s] = t[a];
                  const i = a * n,
                    r = s * n;
                  for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
                }
                ++s;
              }
            }
            if (r > 0) {
              t[s] = t[r];
              for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
              ++s;
            }
            return (
              s !== t.length
                ? ((this.times = t.slice(0, s)), (this.values = e.slice(0, s * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = this.times.slice(),
              e = this.values.slice(),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (uo.prototype.TimeBufferType = Float32Array),
          (uo.prototype.ValueBufferType = Float32Array),
          (uo.prototype.DefaultInterpolation = Y);
        class po extends uo {}
        (po.prototype.ValueTypeName = "bool"),
          (po.prototype.ValueBufferType = Array),
          (po.prototype.DefaultInterpolation = q),
          (po.prototype.InterpolantFactoryMethodLinear = void 0),
          (po.prototype.InterpolantFactoryMethodSmooth = void 0);
        class fo extends uo {}
        fo.prototype.ValueTypeName = "color";
        class mo extends uo {}
        mo.prototype.ValueTypeName = "number";
        class go extends oo {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = (n - e) / (i - e);
            let l = t * a;
            for (let t = l + a; l !== t; l += 4) se.slerpFlat(r, 0, s, l - a, s, l, o);
            return r;
          }
        }
        class _o extends uo {
          InterpolantFactoryMethodLinear(t) {
            return new go(this.times, this.values, this.getValueSize(), t);
          }
        }
        (_o.prototype.ValueTypeName = "quaternion"),
          (_o.prototype.DefaultInterpolation = Y),
          (_o.prototype.InterpolantFactoryMethodSmooth = void 0);
        class vo extends uo {}
        (vo.prototype.ValueTypeName = "string"),
          (vo.prototype.ValueBufferType = Array),
          (vo.prototype.DefaultInterpolation = q),
          (vo.prototype.InterpolantFactoryMethodLinear = void 0),
          (vo.prototype.InterpolantFactoryMethodSmooth = void 0);
        class xo extends uo {}
        xo.prototype.ValueTypeName = "vector";
        class yo {
          constructor(t, e = -1, n, i = 2500) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = i),
              (this.uuid = bt()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t) e.push(Mo(n[t]).scale(i));
            const r = new this(t.name, t.duration, e, t.blendMode);
            return (r.uuid = t.uuid), r;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let t = 0, i = n.length; t !== i; ++t) e.push(uo.toJSON(n[t]));
            return i;
          }
          static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length,
              s = [];
            for (let t = 0; t < r; t++) {
              let a = [],
                o = [];
              a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
              const l = ro(a);
              (a = so(a, 1, l)),
                (o = so(o, 1, l)),
                i || 0 !== a[0] || (a.push(r), o.push(o[0])),
                s.push(new mo(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n));
            }
            return new this(t, -1, s);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                s = n.name.match(r);
              if (s && s.length > 1) {
                const t = s[1];
                let e = i[t];
                e || (i[t] = e = []), e.push(n);
              }
            }
            const s = [];
            for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
            return s;
          }
          static parseAnimation(t, e) {
            if (!t)
              return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  const s = [],
                    a = [];
                  ao(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a));
                }
              },
              i = [],
              r = t.name || "default",
              s = t.fps || 30,
              a = t.blendMode;
            let o = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
              const r = l[t].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const t = {};
                  let e;
                  for (e = 0; e < r.length; e++)
                    if (r[e].morphTargets)
                      for (let n = 0; n < r[e].morphTargets.length; n++)
                        t[r[e].morphTargets[n]] = -1;
                  for (const n in t) {
                    const t = [],
                      s = [];
                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                      const i = r[e];
                      t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                    }
                    i.push(new mo(".morphTargetInfluence[" + n + "]", t, s));
                  }
                  o = t.length * s;
                } else {
                  const s = ".bones[" + e[t].name + "]";
                  n(xo, s + ".position", r, "pos", i),
                    n(_o, s + ".quaternion", r, "rot", i),
                    n(xo, s + ".scale", r, "scl", i);
                }
            }
            return 0 === i.length ? null : new this(r, o, i, a);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
            return new this.constructor(this.name, this.duration, t, this.blendMode);
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function Mo(t) {
          if (void 0 === t.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return mo;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return xo;
              case "color":
                return fo;
              case "quaternion":
                return _o;
              case "bool":
              case "boolean":
                return po;
              case "string":
                return vo;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
          })(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            ao(t.keys, e, n, "value"), (t.times = e), (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        const So = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        class bo {
          constructor(t, e, n) {
            const i = this;
            let r,
              s = !1,
              a = 0,
              o = 0;
            const l = [];
            (this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = n),
              (this.itemStart = function (t) {
                o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), (s = !0);
              }),
              (this.itemEnd = function (t) {
                a++,
                  void 0 !== i.onProgress && i.onProgress(t, a, o),
                  a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
              }),
              (this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t);
              }),
              (this.resolveURL = function (t) {
                return r ? r(t) : t;
              }),
              (this.setURLModifier = function (t) {
                return (r = t), this;
              }),
              (this.addHandler = function (t, e) {
                return l.push(t, e), this;
              }),
              (this.removeHandler = function (t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this;
              }),
              (this.getHandler = function (t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                  const n = l[e],
                    i = l[e + 1];
                  if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
                }
                return null;
              });
          }
        }
        const Eo = new bo();
        class To {
          constructor(t) {
            (this.manager = void 0 !== t ? t : Eo),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.load(t, i, e, r);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        To.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Ao = {};
        class wo extends Error {
          constructor(t, e) {
            super(t), (this.response = e);
          }
        }
        class Ro extends To {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = So.get(t);
            if (void 0 !== r)
              return (
                this.manager.itemStart(t),
                setTimeout(() => {
                  e && e(r), this.manager.itemEnd(t);
                }, 0),
                r
              );
            if (void 0 !== Ao[t]) return void Ao[t].push({ onLoad: e, onProgress: n, onError: i });
            (Ao[t] = []), Ao[t].push({ onLoad: e, onProgress: n, onError: i });
            const s = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
              }),
              a = this.mimeType,
              o = this.responseType;
            fetch(s)
              .then((e) => {
                if (200 === e.status || 0 === e.status) {
                  if (
                    (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    "undefined" == typeof ReadableStream ||
                      void 0 === e.body ||
                      void 0 === e.body.getReader)
                  )
                    return e;
                  const n = Ao[t],
                    i = e.body.getReader(),
                    r = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
                    s = r ? parseInt(r) : 0,
                    a = 0 !== s;
                  let o = 0;
                  const l = new ReadableStream({
                    start(t) {
                      !(function e() {
                        i.read().then(({ done: i, value: r }) => {
                          if (i) t.close();
                          else {
                            o += r.byteLength;
                            const i = new ProgressEvent("progress", {
                              lengthComputable: a,
                              loaded: o,
                              total: s,
                            });
                            for (let t = 0, e = n.length; t < e; t++) {
                              const e = n[t];
                              e.onProgress && e.onProgress(i);
                            }
                            t.enqueue(r), e();
                          }
                        });
                      })();
                    },
                  });
                  return new Response(l);
                }
                throw new wo(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e);
              })
              .then((t) => {
                switch (o) {
                  case "arraybuffer":
                    return t.arrayBuffer();
                  case "blob":
                    return t.blob();
                  case "document":
                    return t.text().then((t) => new DOMParser().parseFromString(t, a));
                  case "json":
                    return t.json();
                  default:
                    if (void 0 === a) return t.text();
                    {
                      const e = /charset="?([^;"\s]*)"?/i.exec(a),
                        n = e && e[1] ? e[1].toLowerCase() : void 0,
                        i = new TextDecoder(n);
                      return t.arrayBuffer().then((t) => i.decode(t));
                    }
                }
              })
              .then((e) => {
                So.add(t, e);
                const n = Ao[t];
                delete Ao[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onLoad && i.onLoad(e);
                }
              })
              .catch((e) => {
                const n = Ao[t];
                if (void 0 === n) throw (this.manager.itemError(t), e);
                delete Ao[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onError && i.onError(e);
                }
                this.manager.itemError(t);
              })
              .finally(() => {
                this.manager.itemEnd(t);
              }),
              this.manager.itemStart(t);
          }
          setResponseType(t) {
            return (this.responseType = t), this;
          }
          setMimeType(t) {
            return (this.mimeType = t), this;
          }
        }
        class Co extends To {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
            const r = this,
              s = So.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            const a = Ot("img");
            function o() {
              c(), So.add(t, this), e && e(this), r.manager.itemEnd(t);
            }
            function l(e) {
              c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }
            function c() {
              a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1);
            }
            return (
              a.addEventListener("load", o, !1),
              a.addEventListener("error", l, !1),
              "data:" !== t.slice(0, 5) &&
                void 0 !== this.crossOrigin &&
                (a.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (a.src = t),
              a
            );
          }
        }
        class Lo extends To {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = new $t(),
              s = new Co(this.manager);
            return (
              s.setCrossOrigin(this.crossOrigin),
              s.setPath(this.path),
              s.load(
                t,
                function (t) {
                  (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
                },
                n,
                i
              ),
              r
            );
          }
        }
        class Po extends ln {
          constructor(t, e = 1) {
            super(),
              (this.isLight = !0),
              (this.type = "Light"),
              (this.color = new Tn(t)),
              (this.intensity = e);
          }
          dispose() {}
          copy(t, e) {
            return super.copy(t, e), this.color.copy(t.color), (this.intensity = t.intensity), this;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        const Io = new Oe(),
          Uo = new ae(),
          No = new ae();
        class Do {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new It(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new Oe()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new wi()),
              (this._frameExtents = new It(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new te(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            Uo.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(Uo),
              No.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(No),
              e.updateMatrixWorld(),
              Io.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Io),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(Io);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class Oo extends Do {
          constructor() {
            super(new gi(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * St * t.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far;
            (n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        class Bo extends Po {
          constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) {
            super(t, e),
              (this.isSpotLight = !0),
              (this.type = "SpotLight"),
              this.position.copy(ln.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new ln()),
              (this.distance = n),
              (this.angle = i),
              (this.penumbra = r),
              (this.decay = s),
              (this.map = null),
              (this.shadow = new Oo());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        const Fo = new Oe(),
          zo = new ae(),
          Ho = new ae();
        class Go extends Do {
          constructor() {
            super(new gi(90, 1, 0.5, 500)),
              (this.isPointLightShadow = !0),
              (this._frameExtents = new It(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new te(2, 1, 1, 1),
                new te(0, 1, 1, 1),
                new te(3, 1, 1, 1),
                new te(1, 1, 1, 1),
                new te(3, 0, 1, 1),
                new te(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new ae(1, 0, 0),
                new ae(-1, 0, 0),
                new ae(0, 0, 1),
                new ae(0, 0, -1),
                new ae(0, 1, 0),
                new ae(0, -1, 0),
              ]),
              (this._cubeUps = [
                new ae(0, 1, 0),
                new ae(0, 1, 0),
                new ae(0, 1, 0),
                new ae(0, 1, 0),
                new ae(0, 0, 1),
                new ae(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              i = this.matrix,
              r = t.distance || n.far;
            r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
              zo.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(zo),
              Ho.copy(n.position),
              Ho.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(Ho),
              n.updateMatrixWorld(),
              i.makeTranslation(-zo.x, -zo.y, -zo.z),
              Fo.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Fo);
          }
        }
        class ko extends Po {
          constructor(t, e, n = 0, i = 2) {
            super(t, e),
              (this.isPointLight = !0),
              (this.type = "PointLight"),
              (this.distance = n),
              (this.decay = i),
              (this.shadow = new Go());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        class Vo extends Do {
          constructor() {
            super(new Gi(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
          }
        }
        class Wo extends Po {
          constructor(t, e) {
            super(t, e),
              (this.isDirectionalLight = !0),
              (this.type = "DirectionalLight"),
              this.position.copy(ln.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new ln()),
              (this.shadow = new Vo());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        class Xo {
          static decodeText(t) {
            if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
            let e = "";
            for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
            try {
              return decodeURIComponent(escape(e));
            } catch (t) {
              return e;
            }
          }
          static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.slice(0, e + 1);
          }
          static resolveURL(t, e) {
            return "string" != typeof t || "" === t
              ? ""
              : (/^https?:\/\//i.test(e) &&
                  /^\//.test(t) &&
                  (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t)
                  ? t
                  : e + t);
          }
        }
        class jo extends To {
          constructor(t) {
            super(t),
              (this.isImageBitmapLoader = !0),
              "undefined" == typeof createImageBitmap &&
                console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
              "undefined" == typeof fetch &&
                console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              (this.options = { premultiplyAlpha: "none" });
          }
          setOptions(t) {
            return (this.options = t), this;
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              s = So.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                s.then
                  ? void s
                      .then((n) => {
                        e && e(n), r.manager.itemEnd(t);
                      })
                      .catch((t) => {
                        i && i(t);
                      })
                  : (setTimeout(function () {
                      e && e(s), r.manager.itemEnd(t);
                    }, 0),
                    s)
              );
            const a = {};
            (a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include"),
              (a.headers = this.requestHeader);
            const o = fetch(t, a)
              .then(function (t) {
                return t.blob();
              })
              .then(function (t) {
                return createImageBitmap(
                  t,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (n) {
                return So.add(t, n), e && e(n), r.manager.itemEnd(t), n;
              })
              .catch(function (e) {
                i && i(e), So.remove(t), r.manager.itemError(t), r.manager.itemEnd(t);
              });
            So.add(t, o), r.manager.itemStart(t);
          }
        }
        class qo {
          constructor(t, e, n) {
            let i, r, s;
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case "quaternion":
                (i = this._slerp),
                  (r = this._slerpAdditive),
                  (s = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (i = this._select),
                  (r = this._select),
                  (s = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (i = this._lerp),
                  (r = this._lerpAdditive),
                  (s = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = i),
              (this._mixBufferRegionAdditive = r),
              (this._setIdentity = s),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(t, e) {
            const n = this.buffer,
              i = this.valueSize,
              r = t * i + i;
            let s = this.cumulativeWeight;
            if (0 === s) {
              for (let t = 0; t !== i; ++t) n[r + t] = n[t];
              s = e;
            } else {
              s += e;
              const t = e / s;
              this._mixBufferRegion(n, r, 0, t, i);
            }
            this.cumulativeWeight = s;
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, i, 0, t, n),
              (this.cumulativeWeightAdditive += t);
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              i = t * e + e,
              r = this.cumulativeWeight,
              s = this.cumulativeWeightAdditive,
              a = this.binding;
            if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)) {
              const t = e * this._origIndex;
              this._mixBufferRegion(n, i, t, 1 - r, e);
            }
            s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
              if (n[t] !== n[t + e]) {
                a.setValue(n, i);
                break;
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
            this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n];
          }
          _select(t, e, n, i, r) {
            if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
          }
          _slerp(t, e, n, i) {
            se.slerpFlat(t, e, t, e, t, n, i);
          }
          _slerpAdditive(t, e, n, i, r) {
            const s = this._workIndex * r;
            se.multiplyQuaternionsFlat(t, s, t, e, t, n), se.slerpFlat(t, e, t, e, t, s, i);
          }
          _lerp(t, e, n, i, r) {
            const s = 1 - i;
            for (let a = 0; a !== r; ++a) {
              const r = e + a;
              t[r] = t[r] * s + t[n + a] * i;
            }
          }
          _lerpAdditive(t, e, n, i, r) {
            for (let s = 0; s !== r; ++s) {
              const r = e + s;
              t[r] = t[r] + t[n + s] * i;
            }
          }
        }
        const Yo = "\\[\\]\\.:\\/",
          Ko = new RegExp("[" + Yo + "]", "g"),
          Zo = "[^" + Yo + "]",
          Jo = "[^" + Yo.replace("\\.", "") + "]",
          Qo = new RegExp(
            "^" +
              /((?:WC+[\/:])*)/.source.replace("WC", Zo) +
              /(WCOD+)?/.source.replace("WCOD", Jo) +
              /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Zo) +
              /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Zo) +
              "$"
          ),
          $o = ["material", "materials", "bones", "map"];
        class tl {
          constructor(t, e, n) {
            (this.path = e),
              (this.parsedPath = n || tl.parseTrackName(e)),
              (this.node = tl.findNode(t, this.parsedPath.nodeName)),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, e, n) {
            return t && t.isAnimationObjectGroup ? new tl.Composite(t, e, n) : new tl(t, e, n);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(Ko, "");
          }
          static parseTrackName(t) {
            const e = Qo.exec(t);
            if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6],
              },
              i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
              const t = n.nodeName.substring(i + 1);
              -1 !== $o.indexOf(t) &&
                ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n;
          }
          static findNode(t, e) {
            if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
              return t;
            if (t.skeleton) {
              const n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              const n = function (t) {
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    if (r.name === e || r.uuid === e) return r;
                    const s = n(r.children);
                    if (s) return s;
                  }
                  return null;
                },
                i = n(t.children);
              if (i) return i;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName];
          }
          _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
          }
          _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
          }
          _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
          }
          _setValue_direct_setNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          }
          _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          }
          _setValue_arrayElement_setNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
          }
          _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
          }
          _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
          }
          bind() {
            let t = this.node;
            const e = this.parsedPath,
              n = e.objectName,
              i = e.propertyName;
            let r = e.propertyIndex;
            if (
              (t || ((t = tl.findNode(this.rootNode, e.nodeName)), (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.warn(
                "THREE.PropertyBinding: No target node found for track: " + this.path + "."
              );
            if (n) {
              let i = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let e = 0; e < t.length; e++)
                    if (t[e].name === i) {
                      i = e;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in t) {
                    t = t.map;
                    break;
                  }
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.map)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this
                    );
                  t = t.material.map;
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== i) {
                if (void 0 === t[i])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[i];
              }
            }
            const s = t[i];
            if (void 0 === s) {
              const n = e.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  n +
                  "." +
                  i +
                  " but it wasn't found.",
                t
              );
            }
            let a = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (a = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === i) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
              }
              (o = this.BindingType.ArrayElement),
                (this.resolvedProperty = s),
                (this.propertyIndex = r);
            } else
              void 0 !== s.fromArray && void 0 !== s.toArray
                ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                : Array.isArray(s)
                ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
                : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[o]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        (tl.Composite = class {
          constructor(t, e, n) {
            const i = n || tl.parseTrackName(e);
            (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
          }
          getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              i = this._bindings[n];
            void 0 !== i && i.getValue(t, e);
          }
          setValue(t, e) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
              n[i].setValue(t, e);
          }
          bind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
          }
          unbind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
              t[e].unbind();
          }
        }),
          (tl.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          }),
          (tl.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
          (tl.prototype.GetterByBindingType = [
            tl.prototype._getValue_direct,
            tl.prototype._getValue_array,
            tl.prototype._getValue_arrayElement,
            tl.prototype._getValue_toArray,
          ]),
          (tl.prototype.SetterByBindingTypeAndVersioning = [
            [
              tl.prototype._setValue_direct,
              tl.prototype._setValue_direct_setNeedsUpdate,
              tl.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
            ],
            [
              tl.prototype._setValue_array,
              tl.prototype._setValue_array_setNeedsUpdate,
              tl.prototype._setValue_array_setMatrixWorldNeedsUpdate,
            ],
            [
              tl.prototype._setValue_arrayElement,
              tl.prototype._setValue_arrayElement_setNeedsUpdate,
              tl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
            ],
            [
              tl.prototype._setValue_fromArray,
              tl.prototype._setValue_fromArray_setNeedsUpdate,
              tl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
            ],
          ]);
        class el {
          constructor(t, e, n = null, i = e.blendMode) {
            (this._mixer = t), (this._clip = e), (this._localRoot = n), (this.blendMode = i);
            const r = e.tracks,
              s = r.length,
              a = new Array(s),
              o = { endingStart: Z, endingEnd: Z };
            for (let t = 0; t !== s; ++t) {
              const e = r[t].createInterpolant(null);
              (a[t] = e), (e.settings = o);
            }
            (this._interpolantSettings = o),
              (this._interpolants = a),
              (this._propertyBindings = new Array(s)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = 2201),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(t) {
            return (this._startTime = t), this;
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          }
          setEffectiveWeight(t) {
            return (
              (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                i = t._clip.duration,
                r = i / n,
                s = n / i;
              t.warp(1, r, e), this.warp(s, 1, e);
            }
            return this;
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n);
          }
          stopFading() {
            const t = this._weightInterpolant;
            return (
              null !== t &&
                ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          setEffectiveTimeScale(t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(t) {
            return (this.timeScale = this._clip.duration / t), this.stopWarping();
          }
          syncWith(t) {
            return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping();
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          }
          warp(t, e, n) {
            const i = this._mixer,
              r = i.time,
              s = this.timeScale;
            let a = this._timeScaleInterpolant;
            null === a && ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
            const o = a.parameterPositions,
              l = a.sampleValues;
            return (o[0] = r), (o[1] = r + n), (l[0] = t / s), (l[1] = e / s), this;
          }
          stopWarping() {
            const t = this._timeScaleInterpolant;
            return (
              null !== t &&
                ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
              const i = (t - r) * n;
              i < 0 || 0 === n ? (e = 0) : ((this._startTime = null), (e = n * i));
            }
            e *= this._updateTimeScale(t);
            const s = this._updateTime(e),
              a = this._updateWeight(t);
            if (a > 0) {
              const t = this._interpolants,
                e = this._propertyBindings;
              if (2501 === this.blendMode)
                for (let n = 0, i = t.length; n !== i; ++n)
                  t[n].evaluate(s), e[n].accumulateAdditive(a);
              else
                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, a);
            }
          }
          _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
              e = this.weight;
              const n = this._weightInterpolant;
              if (null !== n) {
                const i = n.evaluate(t)[0];
                (e *= i),
                  t > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === i && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          }
          _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
              e = this.timeScale;
              const n = this._timeScaleInterpolant;
              null !== n &&
                ((e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)));
            }
            return (this._effectiveTimeScale = e), e;
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop;
            let i = this.time + t,
              r = this._loopCount;
            const s = 2202 === n;
            if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
            if (2200 === n) {
              -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (i >= e) i = e;
                else {
                  if (!(i < 0)) {
                    this.time = i;
                    break t;
                  }
                  i = 0;
                }
                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === r &&
                  (t >= 0
                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                    : this._setEndings(0 === this.repetitions, !0, s)),
                i >= e || i < 0)
              ) {
                const n = Math.floor(i / e);
                (i -= e * n), (r += Math.abs(n));
                const a = this.repetitions - r;
                if (a <= 0)
                  this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                    (i = t > 0 ? e : 0),
                    (this.time = i),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === a) {
                    const e = t < 0;
                    this._setEndings(e, !e, s);
                  } else this._setEndings(!1, !1, s);
                  (this._loopCount = r),
                    (this.time = i),
                    this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n });
                }
              } else this.time = i;
              if (s && 1 == (1 & r)) return e - i;
            }
            return i;
          }
          _setEndings(t, e, n) {
            const i = this._interpolantSettings;
            n
              ? ((i.endingStart = J), (i.endingEnd = J))
              : ((i.endingStart = t ? (this.zeroSlopeAtStart ? J : Z) : Q),
                (i.endingEnd = e ? (this.zeroSlopeAtEnd ? J : Z) : Q));
          }
          _scheduleFading(t, e, n) {
            const i = this._mixer,
              r = i.time;
            let s = this._weightInterpolant;
            null === s && ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
            const a = s.parameterPositions,
              o = s.sampleValues;
            return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = n), this;
          }
        }
        const nl = new Float32Array(1);
        class il extends vt {
          constructor(t) {
            super(),
              (this._root = t),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1);
          }
          _bindAction(t, e) {
            const n = t._localRoot || this._root,
              i = t._clip.tracks,
              r = i.length,
              s = t._propertyBindings,
              a = t._interpolants,
              o = n.uuid,
              l = this._bindingsByRootAndName;
            let c = l[o];
            void 0 === c && ((c = {}), (l[o] = c));
            for (let t = 0; t !== r; ++t) {
              const r = i[t],
                l = r.name;
              let h = c[l];
              if (void 0 !== h) ++h.referenceCount, (s[t] = h);
              else {
                if (((h = s[t]), void 0 !== h)) {
                  null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                  continue;
                }
                const i = e && e._propertyBindings[t].binding.parsedPath;
                (h = new qo(tl.create(n, l, i), r.ValueTypeName, r.getValueSize())),
                  ++h.referenceCount,
                  this._addInactiveBinding(h, o, l),
                  (s[t] = h);
              }
              a[t].resultBuffer = h.buffer;
            }
          }
          _activateAction(t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  i = this._actionsByClip[n];
                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e);
              }
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
              }
              this._lendAction(t);
            }
          }
          _deactivateAction(t) {
            if (this._isActiveAction(t)) {
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n));
              }
              this._takeBackAction(t);
            }
          }
          _initMemoryManager() {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            const t = this;
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length;
                },
                get inUse() {
                  return t._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return t._bindings.length;
                },
                get inUse() {
                  return t._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length;
                },
                get inUse() {
                  return t._nActiveControlInterpolants;
                },
              },
            };
          }
          _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions;
          }
          _addInactiveAction(t, e, n) {
            const i = this._actions,
              r = this._actionsByClip;
            let s = r[e];
            if (void 0 === s)
              (s = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (r[e] = s);
            else {
              const e = s.knownActions;
              (t._byClipCacheIndex = e.length), e.push(t);
            }
            (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
          }
          _removeInactiveAction(t) {
            const e = this._actions,
              n = e[e.length - 1],
              i = t._cacheIndex;
            (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
            const r = t._clip.uuid,
              s = this._actionsByClip,
              a = s[r],
              o = a.knownActions,
              l = o[o.length - 1],
              c = t._byClipCacheIndex;
            (l._byClipCacheIndex = c),
              (o[c] = l),
              o.pop(),
              (t._byClipCacheIndex = null),
              delete a.actionByRoot[(t._localRoot || this._root).uuid],
              0 === o.length && delete s[r],
              this._removeInactiveBindingsForAction(t);
          }
          _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == --n.referenceCount && this._removeInactiveBinding(n);
            }
          }
          _lendAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = this._nActiveActions++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _takeBackAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = --this._nActiveActions,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _addInactiveBinding(t, e, n) {
            const i = this._bindingsByRootAndName,
              r = this._bindings;
            let s = i[e];
            void 0 === s && ((s = {}), (i[e] = s)),
              (s[n] = t),
              (t._cacheIndex = r.length),
              r.push(t);
          }
          _removeInactiveBinding(t) {
            const e = this._bindings,
              n = t.binding,
              i = n.rootNode.uuid,
              r = n.path,
              s = this._bindingsByRootAndName,
              a = s[i],
              o = e[e.length - 1],
              l = t._cacheIndex;
            (o._cacheIndex = l),
              (e[l] = o),
              e.pop(),
              delete a[r],
              0 === Object.keys(a).length && delete s[i];
          }
          _lendBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = this._nActiveBindings++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _takeBackBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = --this._nActiveBindings,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _lendControlInterpolant() {
            const t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++;
            let n = t[e];
            return (
              void 0 === n &&
                ((n = new co(new Float32Array(2), new Float32Array(2), 1, nl)),
                (n.__cacheIndex = e),
                (t[e] = n)),
              n
            );
          }
          _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants,
              n = t.__cacheIndex,
              i = --this._nActiveControlInterpolants,
              r = e[i];
            (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
          }
          clipAction(t, e, n) {
            const i = e || this._root,
              r = i.uuid;
            let s = "string" == typeof t ? yo.findByName(i, t) : t;
            const a = null !== s ? s.uuid : t,
              o = this._actionsByClip[a];
            let l = null;
            if ((void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o)) {
              const t = o.actionByRoot[r];
              if (void 0 !== t && t.blendMode === n) return t;
              (l = o.knownActions[0]), null === s && (s = l._clip);
            }
            if (null === s) return null;
            const c = new el(this, s, e, n);
            return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
          }
          existingAction(t, e) {
            const n = e || this._root,
              i = n.uuid,
              r = "string" == typeof t ? yo.findByName(n, t) : t,
              s = r ? r.uuid : t,
              a = this._actionsByClip[s];
            return (void 0 !== a && a.actionByRoot[i]) || null;
          }
          stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
            return this;
          }
          update(t) {
            t *= this.timeScale;
            const e = this._actions,
              n = this._nActiveActions,
              i = (this.time += t),
              r = Math.sign(t),
              s = (this._accuIndex ^= 1);
            for (let a = 0; a !== n; ++a) e[a]._update(i, t, r, s);
            const a = this._bindings,
              o = this._nActiveBindings;
            for (let t = 0; t !== o; ++t) a[t].apply(s);
            return this;
          }
          setTime(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
            return this.update(t);
          }
          getRoot() {
            return this._root;
          }
          uncacheClip(t) {
            const e = this._actions,
              n = t.uuid,
              i = this._actionsByClip,
              r = i[n];
            if (void 0 !== r) {
              const t = r.knownActions;
              for (let n = 0, i = t.length; n !== i; ++n) {
                const i = t[n];
                this._deactivateAction(i);
                const r = i._cacheIndex,
                  s = e[e.length - 1];
                (i._cacheIndex = null),
                  (i._byClipCacheIndex = null),
                  (s._cacheIndex = r),
                  (e[r] = s),
                  e.pop(),
                  this._removeInactiveBindingsForAction(i);
              }
              delete i[n];
            }
          }
          uncacheRoot(t) {
            const e = t.uuid,
              n = this._actionsByClip;
            for (const t in n) {
              const i = n[t].actionByRoot[e];
              void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
            }
            const i = this._bindingsByRootAndName[e];
            if (void 0 !== i)
              for (const t in i) {
                const e = i[t];
                e.restoreOriginalState(), this._removeInactiveBinding(e);
              }
          }
          uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
          }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: i } })
          ),
          "undefined" != typeof window &&
            (window.__THREE__
              ? console.warn("WARNING: Multiple instances of Three.js being imported.")
              : (window.__THREE__ = i));
      },
      867: (t, e, n) => {
        n.r(e), n.d(e, { GLTFLoader: () => s });
        var i = n(477);
        function r(t, e) {
          if (e === i.TrianglesDrawMode)
            return (
              console.warn(
                "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
              ),
              t
            );
          if (e === i.TriangleFanDrawMode || e === i.TriangleStripDrawMode) {
            let n = t.getIndex();
            if (null === n) {
              const e = [],
                i = t.getAttribute("position");
              if (void 0 === i)
                return (
                  console.error(
                    "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                  ),
                  t
                );
              for (let t = 0; t < i.count; t++) e.push(t);
              t.setIndex(e), (n = t.getIndex());
            }
            const r = n.count - 2,
              s = [];
            if (e === i.TriangleFanDrawMode)
              for (let t = 1; t <= r; t++)
                s.push(n.getX(0)), s.push(n.getX(t)), s.push(n.getX(t + 1));
            else
              for (let t = 0; t < r; t++)
                t % 2 == 0
                  ? (s.push(n.getX(t)), s.push(n.getX(t + 1)), s.push(n.getX(t + 2)))
                  : (s.push(n.getX(t + 2)), s.push(n.getX(t + 1)), s.push(n.getX(t)));
            s.length / 3 !== r &&
              console.error(
                "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
              );
            const a = t.clone();
            return a.setIndex(s), a.clearGroups(), a;
          }
          return (
            console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
            t
          );
        }
        class s extends i.Loader {
          constructor(t) {
            super(t),
              (this.dracoLoader = null),
              (this.ktx2Loader = null),
              (this.meshoptDecoder = null),
              (this.pluginCallbacks = []),
              this.register(function (t) {
                return new u(t);
              }),
              this.register(function (t) {
                return new y(t);
              }),
              this.register(function (t) {
                return new M(t);
              }),
              this.register(function (t) {
                return new S(t);
              }),
              this.register(function (t) {
                return new p(t);
              }),
              this.register(function (t) {
                return new f(t);
              }),
              this.register(function (t) {
                return new m(t);
              }),
              this.register(function (t) {
                return new g(t);
              }),
              this.register(function (t) {
                return new h(t);
              }),
              this.register(function (t) {
                return new _(t);
              }),
              this.register(function (t) {
                return new d(t);
              }),
              this.register(function (t) {
                return new x(t);
              }),
              this.register(function (t) {
                return new v(t);
              }),
              this.register(function (t) {
                return new l(t);
              }),
              this.register(function (t) {
                return new b(t);
              }),
              this.register(function (t) {
                return new E(t);
              });
          }
          load(t, e, n, r) {
            const s = this;
            let a;
            if ("" !== this.resourcePath) a = this.resourcePath;
            else if ("" !== this.path) {
              const e = i.LoaderUtils.extractUrlBase(t);
              a = i.LoaderUtils.resolveURL(e, this.path);
            } else a = i.LoaderUtils.extractUrlBase(t);
            this.manager.itemStart(t);
            const o = function (e) {
                r ? r(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t);
              },
              l = new i.FileLoader(this.manager);
            l.setPath(this.path),
              l.setResponseType("arraybuffer"),
              l.setRequestHeader(this.requestHeader),
              l.setWithCredentials(this.withCredentials),
              l.load(
                t,
                function (n) {
                  try {
                    s.parse(
                      n,
                      a,
                      function (n) {
                        e(n), s.manager.itemEnd(t);
                      },
                      o
                    );
                  } catch (t) {
                    o(t);
                  }
                },
                n,
                o
              );
          }
          setDRACOLoader(t) {
            return (this.dracoLoader = t), this;
          }
          setDDSLoader() {
            throw new Error(
              'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
            );
          }
          setKTX2Loader(t) {
            return (this.ktx2Loader = t), this;
          }
          setMeshoptDecoder(t) {
            return (this.meshoptDecoder = t), this;
          }
          register(t) {
            return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
          }
          unregister(t) {
            return (
              -1 !== this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
              this
            );
          }
          parse(t, e, n, i) {
            let r;
            const s = {},
              a = {},
              l = new TextDecoder();
            if ("string" == typeof t) r = JSON.parse(t);
            else if (t instanceof ArrayBuffer)
              if (l.decode(new Uint8Array(t, 0, 4)) === T) {
                try {
                  s[o.KHR_BINARY_GLTF] = new A(t);
                } catch (t) {
                  return void (i && i(t));
                }
                r = JSON.parse(s[o.KHR_BINARY_GLTF].content);
              } else r = JSON.parse(l.decode(t));
            else r = t;
            if (void 0 === r.asset || r.asset.version[0] < 2)
              return void (
                i &&
                i(
                  new Error(
                    "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                  )
                )
              );
            const h = new Y(r, {
              path: e || this.resourcePath || "",
              crossOrigin: this.crossOrigin,
              requestHeader: this.requestHeader,
              manager: this.manager,
              ktx2Loader: this.ktx2Loader,
              meshoptDecoder: this.meshoptDecoder,
            });
            h.fileLoader.setRequestHeader(this.requestHeader);
            for (let t = 0; t < this.pluginCallbacks.length; t++) {
              const e = this.pluginCallbacks[t](h);
              e.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                (a[e.name] = e),
                (s[e.name] = !0);
            }
            if (r.extensionsUsed)
              for (let t = 0; t < r.extensionsUsed.length; ++t) {
                const e = r.extensionsUsed[t],
                  n = r.extensionsRequired || [];
                switch (e) {
                  case o.KHR_MATERIALS_UNLIT:
                    s[e] = new c();
                    break;
                  case o.KHR_DRACO_MESH_COMPRESSION:
                    s[e] = new w(r, this.dracoLoader);
                    break;
                  case o.KHR_TEXTURE_TRANSFORM:
                    s[e] = new R();
                    break;
                  case o.KHR_MESH_QUANTIZATION:
                    s[e] = new C();
                    break;
                  default:
                    n.indexOf(e) >= 0 &&
                      void 0 === a[e] &&
                      console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".');
                }
              }
            h.setExtensions(s), h.setPlugins(a), h.parse(n, i);
          }
          parseAsync(t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.parse(t, e, i, r);
            });
          }
        }
        function a() {
          let t = {};
          return {
            get: function (e) {
              return t[e];
            },
            add: function (e, n) {
              t[e] = n;
            },
            remove: function (e) {
              delete t[e];
            },
            removeAll: function () {
              t = {};
            },
          };
        }
        const o = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_IOR: "KHR_materials_ior",
          KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
          KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
          KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
          KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
          KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_MATERIALS_VOLUME: "KHR_materials_volume",
          KHR_TEXTURE_BASISU: "KHR_texture_basisu",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
          EXT_MATERIALS_BUMP: "EXT_materials_bump",
          EXT_TEXTURE_WEBP: "EXT_texture_webp",
          EXT_TEXTURE_AVIF: "EXT_texture_avif",
          EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
          EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
        };
        class l {
          constructor(t) {
            (this.parser = t),
              (this.name = o.KHR_LIGHTS_PUNCTUAL),
              (this.cache = { refs: {}, uses: {} });
          }
          _markDefs() {
            const t = this.parser,
              e = this.parser.json.nodes || [];
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              i.extensions &&
                i.extensions[this.name] &&
                void 0 !== i.extensions[this.name].light &&
                t._addNodeRef(this.cache, i.extensions[this.name].light);
            }
          }
          _loadLight(t) {
            const e = this.parser,
              n = "light:" + t;
            let r = e.cache.get(n);
            if (r) return r;
            const s = e.json,
              a = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[t];
            let o;
            const l = new i.Color(16777215);
            void 0 !== a.color &&
              l.setRGB(a.color[0], a.color[1], a.color[2], i.LinearSRGBColorSpace);
            const c = void 0 !== a.range ? a.range : 0;
            switch (a.type) {
              case "directional":
                (o = new i.DirectionalLight(l)), o.target.position.set(0, 0, -1), o.add(o.target);
                break;
              case "point":
                (o = new i.PointLight(l)), (o.distance = c);
                break;
              case "spot":
                (o = new i.SpotLight(l)),
                  (o.distance = c),
                  (a.spot = a.spot || {}),
                  (a.spot.innerConeAngle =
                    void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0),
                  (a.spot.outerConeAngle =
                    void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4),
                  (o.angle = a.spot.outerConeAngle),
                  (o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
                  o.target.position.set(0, 0, -1),
                  o.add(o.target);
                break;
              default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
            }
            return (
              o.position.set(0, 0, 0),
              (o.decay = 2),
              k(o, a),
              void 0 !== a.intensity && (o.intensity = a.intensity),
              (o.name = e.createUniqueName(a.name || "light_" + t)),
              (r = Promise.resolve(o)),
              e.cache.add(n, r),
              r
            );
          }
          getDependency(t, e) {
            if ("light" === t) return this._loadLight(e);
          }
          createNodeAttachment(t) {
            const e = this,
              n = this.parser,
              i = n.json.nodes[t],
              r = ((i.extensions && i.extensions[this.name]) || {}).light;
            return void 0 === r
              ? null
              : this._loadLight(r).then(function (t) {
                  return n._getNodeRef(e.cache, r, t);
                });
          }
        }
        class c {
          constructor() {
            this.name = o.KHR_MATERIALS_UNLIT;
          }
          getMaterialType() {
            return i.MeshBasicMaterial;
          }
          extendParams(t, e, n) {
            const r = [];
            (t.color = new i.Color(1, 1, 1)), (t.opacity = 1);
            const s = e.pbrMetallicRoughness;
            if (s) {
              if (Array.isArray(s.baseColorFactor)) {
                const e = s.baseColorFactor;
                t.color.setRGB(e[0], e[1], e[2], i.LinearSRGBColorSpace), (t.opacity = e[3]);
              }
              void 0 !== s.baseColorTexture &&
                r.push(n.assignTexture(t, "map", s.baseColorTexture, i.SRGBColorSpace));
            }
            return Promise.all(r);
          }
        }
        class h {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_EMISSIVE_STRENGTH);
          }
          extendMaterialParams(t, e) {
            const n = this.parser.json.materials[t];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name].emissiveStrength;
            return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve();
          }
        }
        class u {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_CLEARCOAT);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              r = n.json.materials[t];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [],
              a = r.extensions[this.name];
            if (
              (void 0 !== a.clearcoatFactor && (e.clearcoat = a.clearcoatFactor),
              void 0 !== a.clearcoatTexture &&
                s.push(n.assignTexture(e, "clearcoatMap", a.clearcoatTexture)),
              void 0 !== a.clearcoatRoughnessFactor &&
                (e.clearcoatRoughness = a.clearcoatRoughnessFactor),
              void 0 !== a.clearcoatRoughnessTexture &&
                s.push(n.assignTexture(e, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)),
              void 0 !== a.clearcoatNormalTexture &&
                (s.push(n.assignTexture(e, "clearcoatNormalMap", a.clearcoatNormalTexture)),
                void 0 !== a.clearcoatNormalTexture.scale))
            ) {
              const t = a.clearcoatNormalTexture.scale;
              e.clearcoatNormalScale = new i.Vector2(t, t);
            }
            return Promise.all(s);
          }
        }
        class d {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_IRIDESCENCE);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor),
              void 0 !== s.iridescenceTexture &&
                r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)),
              void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor),
              void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]),
              void 0 !== s.iridescenceThicknessMinimum &&
                (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
              void 0 !== s.iridescenceThicknessMaximum &&
                (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
              void 0 !== s.iridescenceThicknessTexture &&
                r.push(
                  n.assignTexture(e, "iridescenceThicknessMap", s.iridescenceThicknessTexture)
                ),
              Promise.all(r)
            );
          }
        }
        class p {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_SHEEN);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              r = n.json.materials[t];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [];
            (e.sheenColor = new i.Color(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1);
            const a = r.extensions[this.name];
            if (void 0 !== a.sheenColorFactor) {
              const t = a.sheenColorFactor;
              e.sheenColor.setRGB(t[0], t[1], t[2], i.LinearSRGBColorSpace);
            }
            return (
              void 0 !== a.sheenRoughnessFactor && (e.sheenRoughness = a.sheenRoughnessFactor),
              void 0 !== a.sheenColorTexture &&
                s.push(n.assignTexture(e, "sheenColorMap", a.sheenColorTexture, i.SRGBColorSpace)),
              void 0 !== a.sheenRoughnessTexture &&
                s.push(n.assignTexture(e, "sheenRoughnessMap", a.sheenRoughnessTexture)),
              Promise.all(s)
            );
          }
        }
        class f {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_TRANSMISSION);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
              void 0 !== s.transmissionTexture &&
                r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
              Promise.all(r)
            );
          }
        }
        class m {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_VOLUME);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              r = n.json.materials[t];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [],
              a = r.extensions[this.name];
            (e.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0),
              void 0 !== a.thicknessTexture &&
                s.push(n.assignTexture(e, "thicknessMap", a.thicknessTexture)),
              (e.attenuationDistance = a.attenuationDistance || 1 / 0);
            const o = a.attenuationColor || [1, 1, 1];
            return (
              (e.attenuationColor = new i.Color().setRGB(o[0], o[1], o[2], i.LinearSRGBColorSpace)),
              Promise.all(s)
            );
          }
        }
        class g {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_IOR);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser.json.materials[t];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name];
            return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
          }
        }
        class _ {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_SPECULAR);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              r = n.json.materials[t];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [],
              a = r.extensions[this.name];
            (e.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1),
              void 0 !== a.specularTexture &&
                s.push(n.assignTexture(e, "specularIntensityMap", a.specularTexture));
            const o = a.specularColorFactor || [1, 1, 1];
            return (
              (e.specularColor = new i.Color().setRGB(o[0], o[1], o[2], i.LinearSRGBColorSpace)),
              void 0 !== a.specularColorTexture &&
                s.push(
                  n.assignTexture(e, "specularColorMap", a.specularColorTexture, i.SRGBColorSpace)
                ),
              Promise.all(s)
            );
          }
        }
        class v {
          constructor(t) {
            (this.parser = t), (this.name = o.EXT_MATERIALS_BUMP);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              (e.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1),
              void 0 !== s.bumpTexture && r.push(n.assignTexture(e, "bumpMap", s.bumpTexture)),
              Promise.all(r)
            );
          }
        }
        class x {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_MATERIALS_ANISOTROPY);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              void 0 !== s.anisotropyStrength && (e.anisotropy = s.anisotropyStrength),
              void 0 !== s.anisotropyRotation && (e.anisotropyRotation = s.anisotropyRotation),
              void 0 !== s.anisotropyTexture &&
                r.push(n.assignTexture(e, "anisotropyMap", s.anisotropyTexture)),
              Promise.all(r)
            );
          }
        }
        class y {
          constructor(t) {
            (this.parser = t), (this.name = o.KHR_TEXTURE_BASISU);
          }
          loadTexture(t) {
            const e = this.parser,
              n = e.json,
              i = n.textures[t];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const r = i.extensions[this.name],
              s = e.options.ktx2Loader;
            if (!s) {
              if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error(
                  "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
                );
              return null;
            }
            return e.loadTextureImage(t, r.source, s);
          }
        }
        class M {
          constructor(t) {
            (this.parser = t), (this.name = o.EXT_TEXTURE_WEBP), (this.isSupported = null);
          }
          loadTexture(t) {
            const e = this.name,
              n = this.parser,
              i = n.json,
              r = i.textures[t];
            if (!r.extensions || !r.extensions[e]) return null;
            const s = r.extensions[e],
              a = i.images[s.source];
            let o = n.textureLoader;
            if (a.uri) {
              const t = n.options.manager.getHandler(a.uri);
              null !== t && (o = t);
            }
            return this.detectSupport().then(function (r) {
              if (r) return n.loadTextureImage(t, s.source, o);
              if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
              return n.loadTexture(t);
            });
          }
          detectSupport() {
            return (
              this.isSupported ||
                (this.isSupported = new Promise(function (t) {
                  const e = new Image();
                  (e.src =
                    "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                    (e.onload = e.onerror =
                      function () {
                        t(1 === e.height);
                      });
                })),
              this.isSupported
            );
          }
        }
        class S {
          constructor(t) {
            (this.parser = t), (this.name = o.EXT_TEXTURE_AVIF), (this.isSupported = null);
          }
          loadTexture(t) {
            const e = this.name,
              n = this.parser,
              i = n.json,
              r = i.textures[t];
            if (!r.extensions || !r.extensions[e]) return null;
            const s = r.extensions[e],
              a = i.images[s.source];
            let o = n.textureLoader;
            if (a.uri) {
              const t = n.options.manager.getHandler(a.uri);
              null !== t && (o = t);
            }
            return this.detectSupport().then(function (r) {
              if (r) return n.loadTextureImage(t, s.source, o);
              if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
              return n.loadTexture(t);
            });
          }
          detectSupport() {
            return (
              this.isSupported ||
                (this.isSupported = new Promise(function (t) {
                  const e = new Image();
                  (e.src =
                    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
                    (e.onload = e.onerror =
                      function () {
                        t(1 === e.height);
                      });
                })),
              this.isSupported
            );
          }
        }
        class b {
          constructor(t) {
            (this.name = o.EXT_MESHOPT_COMPRESSION), (this.parser = t);
          }
          loadBufferView(t) {
            const e = this.parser.json,
              n = e.bufferViews[t];
            if (n.extensions && n.extensions[this.name]) {
              const t = n.extensions[this.name],
                i = this.parser.getDependency("buffer", t.buffer),
                r = this.parser.options.meshoptDecoder;
              if (!r || !r.supported) {
                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                  throw new Error(
                    "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                  );
                return null;
              }
              return i.then(function (e) {
                const n = t.byteOffset || 0,
                  i = t.byteLength || 0,
                  s = t.count,
                  a = t.byteStride,
                  o = new Uint8Array(e, n, i);
                return r.decodeGltfBufferAsync
                  ? r.decodeGltfBufferAsync(s, a, o, t.mode, t.filter).then(function (t) {
                      return t.buffer;
                    })
                  : r.ready.then(function () {
                      const e = new ArrayBuffer(s * a);
                      return r.decodeGltfBuffer(new Uint8Array(e), s, a, o, t.mode, t.filter), e;
                    });
              });
            }
            return null;
          }
        }
        class E {
          constructor(t) {
            (this.name = o.EXT_MESH_GPU_INSTANCING), (this.parser = t);
          }
          createNodeMesh(t) {
            const e = this.parser.json,
              n = e.nodes[t];
            if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
            const r = e.meshes[n.mesh];
            for (const t of r.primitives)
              if (
                t.mode !== U.TRIANGLES &&
                t.mode !== U.TRIANGLE_STRIP &&
                t.mode !== U.TRIANGLE_FAN &&
                void 0 !== t.mode
              )
                return null;
            const s = n.extensions[this.name].attributes,
              a = [],
              o = {};
            for (const t in s)
              a.push(this.parser.getDependency("accessor", s[t]).then((e) => ((o[t] = e), o[t])));
            return a.length < 1
              ? null
              : (a.push(this.parser.createNodeMesh(t)),
                Promise.all(a).then((t) => {
                  const e = t.pop(),
                    n = e.isGroup ? e.children : [e],
                    r = t[0].count,
                    s = [];
                  for (const t of n) {
                    const e = new i.Matrix4(),
                      n = new i.Vector3(),
                      a = new i.Quaternion(),
                      l = new i.Vector3(1, 1, 1),
                      c = new i.InstancedMesh(t.geometry, t.material, r);
                    for (let t = 0; t < r; t++)
                      o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t),
                        o.ROTATION && a.fromBufferAttribute(o.ROTATION, t),
                        o.SCALE && l.fromBufferAttribute(o.SCALE, t),
                        c.setMatrixAt(t, e.compose(n, a, l));
                    for (const e in o)
                      if ("_COLOR_0" === e) {
                        const t = o[e];
                        c.instanceColor = new i.InstancedBufferAttribute(
                          t.array,
                          t.itemSize,
                          t.normalized
                        );
                      } else
                        "TRANSLATION" !== e &&
                          "ROTATION" !== e &&
                          "SCALE" !== e &&
                          t.geometry.setAttribute(e, o[e]);
                    i.Object3D.prototype.copy.call(c, t),
                      this.parser.assignFinalMaterial(c),
                      s.push(c);
                  }
                  return e.isGroup ? (e.clear(), e.add(...s), e) : s[0];
                }));
          }
        }
        const T = "glTF";
        class A {
          constructor(t) {
            (this.name = o.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
            const e = new DataView(t, 0, 12),
              n = new TextDecoder();
            if (
              ((this.header = {
                magic: n.decode(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0),
              }),
              this.header.magic !== T)
            )
              throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2)
              throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const i = this.header.length - 12,
              r = new DataView(t, 12);
            let s = 0;
            for (; s < i; ) {
              const e = r.getUint32(s, !0);
              s += 4;
              const i = r.getUint32(s, !0);
              if (((s += 4), 1313821514 === i)) {
                const i = new Uint8Array(t, 12 + s, e);
                this.content = n.decode(i);
              } else if (5130562 === i) {
                const n = 12 + s;
                this.body = t.slice(n, n + e);
              }
              s += e;
            }
            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
        class w {
          constructor(t, e) {
            if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            (this.name = o.KHR_DRACO_MESH_COMPRESSION),
              (this.json = t),
              (this.dracoLoader = e),
              this.dracoLoader.preload();
          }
          decodePrimitive(t, e) {
            const n = this.json,
              r = this.dracoLoader,
              s = t.extensions[this.name].bufferView,
              a = t.extensions[this.name].attributes,
              o = {},
              l = {},
              c = {};
            for (const t in a) {
              const e = F[t] || t.toLowerCase();
              o[e] = a[t];
            }
            for (const e in t.attributes) {
              const i = F[e] || e.toLowerCase();
              if (void 0 !== a[e]) {
                const r = n.accessors[t.attributes[e]],
                  s = N[r.componentType];
                (c[i] = s.name), (l[i] = !0 === r.normalized);
              }
            }
            return e.getDependency("bufferView", s).then(function (t) {
              return new Promise(function (e, n) {
                r.decodeDracoFile(
                  t,
                  function (t) {
                    for (const e in t.attributes) {
                      const n = t.attributes[e],
                        i = l[e];
                      void 0 !== i && (n.normalized = i);
                    }
                    e(t);
                  },
                  o,
                  c,
                  i.LinearSRGBColorSpace,
                  n
                );
              });
            });
          }
        }
        class R {
          constructor() {
            this.name = o.KHR_TEXTURE_TRANSFORM;
          }
          extendTexture(t, e) {
            return (void 0 !== e.texCoord && e.texCoord !== t.channel) ||
              void 0 !== e.offset ||
              void 0 !== e.rotation ||
              void 0 !== e.scale
              ? ((t = t.clone()),
                void 0 !== e.texCoord && (t.channel = e.texCoord),
                void 0 !== e.offset && t.offset.fromArray(e.offset),
                void 0 !== e.rotation && (t.rotation = e.rotation),
                void 0 !== e.scale && t.repeat.fromArray(e.scale),
                (t.needsUpdate = !0),
                t)
              : t;
          }
        }
        class C {
          constructor() {
            this.name = o.KHR_MESH_QUANTIZATION;
          }
        }
        class L extends i.Interpolant {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i * 3 + i;
            for (let t = 0; t !== i; t++) e[t] = n[r + t];
            return e;
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = 2 * a,
              l = 3 * a,
              c = i - e,
              h = (n - e) / c,
              u = h * h,
              d = u * h,
              p = t * l,
              f = p - l,
              m = -2 * d + 3 * u,
              g = d - u,
              _ = 1 - m,
              v = g - u + h;
            for (let t = 0; t !== a; t++) {
              const e = s[f + t + a],
                n = s[f + t + o] * c,
                i = s[p + t + a],
                l = s[p + t] * c;
              r[t] = _ * e + v * n + m * i + g * l;
            }
            return r;
          }
        }
        const P = new i.Quaternion();
        class I extends L {
          interpolate_(t, e, n, i) {
            const r = super.interpolate_(t, e, n, i);
            return P.fromArray(r).normalize().toArray(r), r;
          }
        }
        const U = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123,
          },
          N = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array,
          },
          D = {
            9728: i.NearestFilter,
            9729: i.LinearFilter,
            9984: i.NearestMipmapNearestFilter,
            9985: i.LinearMipmapNearestFilter,
            9986: i.NearestMipmapLinearFilter,
            9987: i.LinearMipmapLinearFilter,
          },
          O = {
            33071: i.ClampToEdgeWrapping,
            33648: i.MirroredRepeatWrapping,
            10497: i.RepeatWrapping,
          },
          B = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
          F = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex",
          },
          z = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences",
          },
          H = { CUBICSPLINE: void 0, LINEAR: i.InterpolateLinear, STEP: i.InterpolateDiscrete };
        function G(t, e, n) {
          for (const i in n.extensions)
            void 0 === t[i] &&
              ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
              (e.userData.gltfExtensions[i] = n.extensions[i]));
        }
        function k(t, e) {
          void 0 !== e.extras &&
            ("object" == typeof e.extras
              ? Object.assign(t.userData, e.extras)
              : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
        }
        function V(t, e) {
          if ((t.updateMorphTargets(), void 0 !== e.weights))
            for (let n = 0, i = e.weights.length; n < i; n++)
              t.morphTargetInfluences[n] = e.weights[n];
          if (e.extras && Array.isArray(e.extras.targetNames)) {
            const n = e.extras.targetNames;
            if (t.morphTargetInfluences.length === n.length) {
              t.morphTargetDictionary = {};
              for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e;
            } else
              console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
          }
        }
        function W(t) {
          let e;
          const n = t.extensions && t.extensions[o.KHR_DRACO_MESH_COMPRESSION];
          if (
            ((e = n
              ? "draco:" + n.bufferView + ":" + n.indices + ":" + X(n.attributes)
              : t.indices + ":" + X(t.attributes) + ":" + t.mode),
            void 0 !== t.targets)
          )
            for (let n = 0, i = t.targets.length; n < i; n++) e += ":" + X(t.targets[n]);
          return e;
        }
        function X(t) {
          let e = "";
          const n = Object.keys(t).sort();
          for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
          return e;
        }
        function j(t) {
          switch (t) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
          }
        }
        const q = new i.Matrix4();
        class Y {
          constructor(t = {}, e = {}) {
            (this.json = t),
              (this.extensions = {}),
              (this.plugins = {}),
              (this.options = e),
              (this.cache = new a()),
              (this.associations = new Map()),
              (this.primitiveCache = {}),
              (this.nodeCache = {}),
              (this.meshCache = { refs: {}, uses: {} }),
              (this.cameraCache = { refs: {}, uses: {} }),
              (this.lightCache = { refs: {}, uses: {} }),
              (this.sourceCache = {}),
              (this.textureCache = {}),
              (this.nodeNamesUsed = {});
            let n = !1,
              r = !1,
              s = -1;
            "undefined" != typeof navigator &&
              ((n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
              (r = navigator.userAgent.indexOf("Firefox") > -1),
              (s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
              "undefined" == typeof createImageBitmap || n || (r && s < 98)
                ? (this.textureLoader = new i.TextureLoader(this.options.manager))
                : (this.textureLoader = new i.ImageBitmapLoader(this.options.manager)),
              this.textureLoader.setCrossOrigin(this.options.crossOrigin),
              this.textureLoader.setRequestHeader(this.options.requestHeader),
              (this.fileLoader = new i.FileLoader(this.options.manager)),
              this.fileLoader.setResponseType("arraybuffer"),
              "use-credentials" === this.options.crossOrigin &&
                this.fileLoader.setWithCredentials(!0);
          }
          setExtensions(t) {
            this.extensions = t;
          }
          setPlugins(t) {
            this.plugins = t;
          }
          parse(t, e) {
            const n = this,
              i = this.json,
              r = this.extensions;
            this.cache.removeAll(),
              (this.nodeCache = {}),
              this._invokeAll(function (t) {
                return t._markDefs && t._markDefs();
              }),
              Promise.all(
                this._invokeAll(function (t) {
                  return t.beforeRoot && t.beforeRoot();
                })
              )
                .then(function () {
                  return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera"),
                  ]);
                })
                .then(function (e) {
                  const s = {
                    scene: e[0][i.scene || 0],
                    scenes: e[0],
                    animations: e[1],
                    cameras: e[2],
                    asset: i.asset,
                    parser: n,
                    userData: {},
                  };
                  return (
                    G(r, s, i),
                    k(s, i),
                    Promise.all(
                      n._invokeAll(function (t) {
                        return t.afterRoot && t.afterRoot(s);
                      })
                    ).then(function () {
                      t(s);
                    })
                  );
                })
                .catch(e);
          }
          _markDefs() {
            const t = this.json.nodes || [],
              e = this.json.skins || [],
              n = this.json.meshes || [];
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n].joints;
              for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0;
            }
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e];
              void 0 !== i.mesh &&
                (this._addNodeRef(this.meshCache, i.mesh),
                void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera);
            }
          }
          _addNodeRef(t, e) {
            void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
          }
          _getNodeRef(t, e, n) {
            if (t.refs[e] <= 1) return n;
            const i = n.clone(),
              r = (t, e) => {
                const n = this.associations.get(t);
                null != n && this.associations.set(e, n);
                for (const [n, i] of t.children.entries()) r(i, e.children[n]);
              };
            return r(n, i), (i.name += "_instance_" + t.uses[e]++), i;
          }
          _invokeOne(t) {
            const e = Object.values(this.plugins);
            e.push(this);
            for (let n = 0; n < e.length; n++) {
              const i = t(e[n]);
              if (i) return i;
            }
            return null;
          }
          _invokeAll(t) {
            const e = Object.values(this.plugins);
            e.unshift(this);
            const n = [];
            for (let i = 0; i < e.length; i++) {
              const r = t(e[i]);
              r && n.push(r);
            }
            return n;
          }
          getDependency(t, e) {
            const n = t + ":" + e;
            let i = this.cache.get(n);
            if (!i) {
              switch (t) {
                case "scene":
                  i = this.loadScene(e);
                  break;
                case "node":
                  i = this._invokeOne(function (t) {
                    return t.loadNode && t.loadNode(e);
                  });
                  break;
                case "mesh":
                  i = this._invokeOne(function (t) {
                    return t.loadMesh && t.loadMesh(e);
                  });
                  break;
                case "accessor":
                  i = this.loadAccessor(e);
                  break;
                case "bufferView":
                  i = this._invokeOne(function (t) {
                    return t.loadBufferView && t.loadBufferView(e);
                  });
                  break;
                case "buffer":
                  i = this.loadBuffer(e);
                  break;
                case "material":
                  i = this._invokeOne(function (t) {
                    return t.loadMaterial && t.loadMaterial(e);
                  });
                  break;
                case "texture":
                  i = this._invokeOne(function (t) {
                    return t.loadTexture && t.loadTexture(e);
                  });
                  break;
                case "skin":
                  i = this.loadSkin(e);
                  break;
                case "animation":
                  i = this._invokeOne(function (t) {
                    return t.loadAnimation && t.loadAnimation(e);
                  });
                  break;
                case "camera":
                  i = this.loadCamera(e);
                  break;
                default:
                  if (
                    ((i = this._invokeOne(function (n) {
                      return n != this && n.getDependency && n.getDependency(t, e);
                    })),
                    !i)
                  )
                    throw new Error("Unknown type: " + t);
              }
              this.cache.add(n, i);
            }
            return i;
          }
          getDependencies(t) {
            let e = this.cache.get(t);
            if (!e) {
              const n = this,
                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
              (e = Promise.all(
                i.map(function (e, i) {
                  return n.getDependency(t, i);
                })
              )),
                this.cache.add(t, e);
            }
            return e;
          }
          loadBuffer(t) {
            const e = this.json.buffers[t],
              n = this.fileLoader;
            if (e.type && "arraybuffer" !== e.type)
              throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
            if (void 0 === e.uri && 0 === t)
              return Promise.resolve(this.extensions[o.KHR_BINARY_GLTF].body);
            const r = this.options;
            return new Promise(function (t, s) {
              n.load(i.LoaderUtils.resolveURL(e.uri, r.path), t, void 0, function () {
                s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
              });
            });
          }
          loadBufferView(t) {
            const e = this.json.bufferViews[t];
            return this.getDependency("buffer", e.buffer).then(function (t) {
              const n = e.byteLength || 0,
                i = e.byteOffset || 0;
              return t.slice(i, i + n);
            });
          }
          loadAccessor(t) {
            const e = this,
              n = this.json,
              r = this.json.accessors[t];
            if (void 0 === r.bufferView && void 0 === r.sparse) {
              const t = B[r.type],
                e = N[r.componentType],
                n = !0 === r.normalized,
                s = new e(r.count * t);
              return Promise.resolve(new i.BufferAttribute(s, t, n));
            }
            const s = [];
            return (
              void 0 !== r.bufferView
                ? s.push(this.getDependency("bufferView", r.bufferView))
                : s.push(null),
              void 0 !== r.sparse &&
                (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
                s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
              Promise.all(s).then(function (t) {
                const s = t[0],
                  a = B[r.type],
                  o = N[r.componentType],
                  l = o.BYTES_PER_ELEMENT,
                  c = l * a,
                  h = r.byteOffset || 0,
                  u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                  d = !0 === r.normalized;
                let p, f;
                if (u && u !== c) {
                  const t = Math.floor(h / u),
                    n =
                      "InterleavedBuffer:" +
                      r.bufferView +
                      ":" +
                      r.componentType +
                      ":" +
                      t +
                      ":" +
                      r.count;
                  let c = e.cache.get(n);
                  c ||
                    ((p = new o(s, t * u, (r.count * u) / l)),
                    (c = new i.InterleavedBuffer(p, u / l)),
                    e.cache.add(n, c)),
                    (f = new i.InterleavedBufferAttribute(c, a, (h % u) / l, d));
                } else (p = null === s ? new o(r.count * a) : new o(s, h, r.count * a)), (f = new i.BufferAttribute(p, a, d));
                if (void 0 !== r.sparse) {
                  const e = B.SCALAR,
                    n = N[r.sparse.indices.componentType],
                    l = r.sparse.indices.byteOffset || 0,
                    c = r.sparse.values.byteOffset || 0,
                    h = new n(t[1], l, r.sparse.count * e),
                    u = new o(t[2], c, r.sparse.count * a);
                  null !== s &&
                    (f = new i.BufferAttribute(f.array.slice(), f.itemSize, f.normalized));
                  for (let t = 0, e = h.length; t < e; t++) {
                    const e = h[t];
                    if (
                      (f.setX(e, u[t * a]),
                      a >= 2 && f.setY(e, u[t * a + 1]),
                      a >= 3 && f.setZ(e, u[t * a + 2]),
                      a >= 4 && f.setW(e, u[t * a + 3]),
                      a >= 5)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                      );
                  }
                }
                return f;
              })
            );
          }
          loadTexture(t) {
            const e = this.json,
              n = this.options,
              i = e.textures[t].source,
              r = e.images[i];
            let s = this.textureLoader;
            if (r.uri) {
              const t = n.manager.getHandler(r.uri);
              null !== t && (s = t);
            }
            return this.loadTextureImage(t, i, s);
          }
          loadTextureImage(t, e, n) {
            const r = this,
              s = this.json,
              a = s.textures[t],
              o = s.images[e],
              l = (o.uri || o.bufferView) + ":" + a.sampler;
            if (this.textureCache[l]) return this.textureCache[l];
            const c = this.loadImageSource(e, n)
              .then(function (e) {
                (e.flipY = !1),
                  (e.name = a.name || o.name || ""),
                  "" === e.name &&
                    "string" == typeof o.uri &&
                    !1 === o.uri.startsWith("data:image/") &&
                    (e.name = o.uri);
                const n = (s.samplers || {})[a.sampler] || {};
                return (
                  (e.magFilter = D[n.magFilter] || i.LinearFilter),
                  (e.minFilter = D[n.minFilter] || i.LinearMipmapLinearFilter),
                  (e.wrapS = O[n.wrapS] || i.RepeatWrapping),
                  (e.wrapT = O[n.wrapT] || i.RepeatWrapping),
                  r.associations.set(e, { textures: t }),
                  e
                );
              })
              .catch(function () {
                return null;
              });
            return (this.textureCache[l] = c), c;
          }
          loadImageSource(t, e) {
            const n = this.json,
              r = this.options;
            if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t) => t.clone());
            const s = n.images[t],
              a = self.URL || self.webkitURL;
            let o = s.uri || "",
              l = !1;
            if (void 0 !== s.bufferView)
              o = this.getDependency("bufferView", s.bufferView).then(function (t) {
                l = !0;
                const e = new Blob([t], { type: s.mimeType });
                return (o = a.createObjectURL(e)), o;
              });
            else if (void 0 === s.uri)
              throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
            const c = Promise.resolve(o)
              .then(function (t) {
                return new Promise(function (n, s) {
                  let a = n;
                  !0 === e.isImageBitmapLoader &&
                    (a = function (t) {
                      const e = new i.Texture(t);
                      (e.needsUpdate = !0), n(e);
                    }),
                    e.load(i.LoaderUtils.resolveURL(t, r.path), a, void 0, s);
                });
              })
              .then(function (t) {
                var e;
                return (
                  !0 === l && a.revokeObjectURL(o),
                  (t.userData.mimeType =
                    s.mimeType ||
                    ((e = s.uri).search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === e.search(/^data\:image\/jpeg/)
                      ? "image/jpeg"
                      : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/)
                      ? "image/webp"
                      : "image/png")),
                  t
                );
              })
              .catch(function (t) {
                throw (console.error("THREE.GLTFLoader: Couldn't load texture", o), t);
              });
            return (this.sourceCache[t] = c), c;
          }
          assignTexture(t, e, n, i) {
            const r = this;
            return this.getDependency("texture", n.index).then(function (s) {
              if (!s) return null;
              if (
                (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord),
                r.extensions[o.KHR_TEXTURE_TRANSFORM])
              ) {
                const t = void 0 !== n.extensions ? n.extensions[o.KHR_TEXTURE_TRANSFORM] : void 0;
                if (t) {
                  const e = r.associations.get(s);
                  (s = r.extensions[o.KHR_TEXTURE_TRANSFORM].extendTexture(s, t)),
                    r.associations.set(s, e);
                }
              }
              return void 0 !== i && (s.colorSpace = i), (t[e] = s), s;
            });
          }
          assignFinalMaterial(t) {
            const e = t.geometry;
            let n = t.material;
            const r = void 0 === e.attributes.tangent,
              s = void 0 !== e.attributes.color,
              a = void 0 === e.attributes.normal;
            if (t.isPoints) {
              const t = "PointsMaterial:" + n.uuid;
              let e = this.cache.get(t);
              e ||
                ((e = new i.PointsMaterial()),
                i.Material.prototype.copy.call(e, n),
                e.color.copy(n.color),
                (e.map = n.map),
                (e.sizeAttenuation = !1),
                this.cache.add(t, e)),
                (n = e);
            } else if (t.isLine) {
              const t = "LineBasicMaterial:" + n.uuid;
              let e = this.cache.get(t);
              e ||
                ((e = new i.LineBasicMaterial()),
                i.Material.prototype.copy.call(e, n),
                e.color.copy(n.color),
                (e.map = n.map),
                this.cache.add(t, e)),
                (n = e);
            }
            if (r || s || a) {
              let t = "ClonedMaterial:" + n.uuid + ":";
              r && (t += "derivative-tangents:"),
                s && (t += "vertex-colors:"),
                a && (t += "flat-shading:");
              let e = this.cache.get(t);
              e ||
                ((e = n.clone()),
                s && (e.vertexColors = !0),
                a && (e.flatShading = !0),
                r &&
                  (e.normalScale && (e.normalScale.y *= -1),
                  e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                this.cache.add(t, e),
                this.associations.set(e, this.associations.get(n))),
                (n = e);
            }
            t.material = n;
          }
          getMaterialType() {
            return i.MeshStandardMaterial;
          }
          loadMaterial(t) {
            const e = this,
              n = this.json,
              r = this.extensions,
              s = n.materials[t];
            let a;
            const l = {},
              c = [];
            if ((s.extensions || {})[o.KHR_MATERIALS_UNLIT]) {
              const t = r[o.KHR_MATERIALS_UNLIT];
              (a = t.getMaterialType()), c.push(t.extendParams(l, s, e));
            } else {
              const n = s.pbrMetallicRoughness || {};
              if (
                ((l.color = new i.Color(1, 1, 1)),
                (l.opacity = 1),
                Array.isArray(n.baseColorFactor))
              ) {
                const t = n.baseColorFactor;
                l.color.setRGB(t[0], t[1], t[2], i.LinearSRGBColorSpace), (l.opacity = t[3]);
              }
              void 0 !== n.baseColorTexture &&
                c.push(e.assignTexture(l, "map", n.baseColorTexture, i.SRGBColorSpace)),
                (l.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
                (l.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
                void 0 !== n.metallicRoughnessTexture &&
                  (c.push(e.assignTexture(l, "metalnessMap", n.metallicRoughnessTexture)),
                  c.push(e.assignTexture(l, "roughnessMap", n.metallicRoughnessTexture))),
                (a = this._invokeOne(function (e) {
                  return e.getMaterialType && e.getMaterialType(t);
                })),
                c.push(
                  Promise.all(
                    this._invokeAll(function (e) {
                      return e.extendMaterialParams && e.extendMaterialParams(t, l);
                    })
                  )
                );
            }
            !0 === s.doubleSided && (l.side = i.DoubleSide);
            const h = s.alphaMode || "OPAQUE";
            if (
              ("BLEND" === h
                ? ((l.transparent = !0), (l.depthWrite = !1))
                : ((l.transparent = !1),
                  "MASK" === h && (l.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
              void 0 !== s.normalTexture &&
                a !== i.MeshBasicMaterial &&
                (c.push(e.assignTexture(l, "normalMap", s.normalTexture)),
                (l.normalScale = new i.Vector2(1, 1)),
                void 0 !== s.normalTexture.scale))
            ) {
              const t = s.normalTexture.scale;
              l.normalScale.set(t, t);
            }
            if (
              (void 0 !== s.occlusionTexture &&
                a !== i.MeshBasicMaterial &&
                (c.push(e.assignTexture(l, "aoMap", s.occlusionTexture)),
                void 0 !== s.occlusionTexture.strength &&
                  (l.aoMapIntensity = s.occlusionTexture.strength)),
              void 0 !== s.emissiveFactor && a !== i.MeshBasicMaterial)
            ) {
              const t = s.emissiveFactor;
              l.emissive = new i.Color().setRGB(t[0], t[1], t[2], i.LinearSRGBColorSpace);
            }
            return (
              void 0 !== s.emissiveTexture &&
                a !== i.MeshBasicMaterial &&
                c.push(e.assignTexture(l, "emissiveMap", s.emissiveTexture, i.SRGBColorSpace)),
              Promise.all(c).then(function () {
                const n = new a(l);
                return (
                  s.name && (n.name = s.name),
                  k(n, s),
                  e.associations.set(n, { materials: t }),
                  s.extensions && G(r, n, s),
                  n
                );
              })
            );
          }
          createUniqueName(t) {
            const e = i.PropertyBinding.sanitizeNodeName(t || "");
            return e in this.nodeNamesUsed
              ? e + "_" + ++this.nodeNamesUsed[e]
              : ((this.nodeNamesUsed[e] = 0), e);
          }
          loadGeometries(t) {
            const e = this,
              n = this.extensions,
              r = this.primitiveCache;
            function s(t) {
              return n[o.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (n) {
                return K(n, t, e);
              });
            }
            const a = [];
            for (let n = 0, l = t.length; n < l; n++) {
              const l = t[n],
                c = W(l),
                h = r[c];
              if (h) a.push(h.promise);
              else {
                let t;
                (t =
                  l.extensions && l.extensions[o.KHR_DRACO_MESH_COMPRESSION]
                    ? s(l)
                    : K(new i.BufferGeometry(), l, e)),
                  (r[c] = { primitive: l, promise: t }),
                  a.push(t);
              }
            }
            return Promise.all(a);
          }
          loadMesh(t) {
            const e = this,
              n = this.json,
              s = this.extensions,
              a = n.meshes[t],
              o = a.primitives,
              l = [];
            for (let t = 0, e = o.length; t < e; t++) {
              const e =
                void 0 === o[t].material
                  ? (void 0 === (c = this.cache).DefaultMaterial &&
                      (c.DefaultMaterial = new i.MeshStandardMaterial({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: i.FrontSide,
                      })),
                    c.DefaultMaterial)
                  : this.getDependency("material", o[t].material);
              l.push(e);
            }
            var c;
            return (
              l.push(e.loadGeometries(o)),
              Promise.all(l).then(function (n) {
                const l = n.slice(0, n.length - 1),
                  c = n[n.length - 1],
                  h = [];
                for (let n = 0, u = c.length; n < u; n++) {
                  const u = c[n],
                    d = o[n];
                  let p;
                  const f = l[n];
                  if (
                    d.mode === U.TRIANGLES ||
                    d.mode === U.TRIANGLE_STRIP ||
                    d.mode === U.TRIANGLE_FAN ||
                    void 0 === d.mode
                  )
                    (p = !0 === a.isSkinnedMesh ? new i.SkinnedMesh(u, f) : new i.Mesh(u, f)),
                      !0 === p.isSkinnedMesh && p.normalizeSkinWeights(),
                      d.mode === U.TRIANGLE_STRIP
                        ? (p.geometry = r(p.geometry, i.TriangleStripDrawMode))
                        : d.mode === U.TRIANGLE_FAN &&
                          (p.geometry = r(p.geometry, i.TriangleFanDrawMode));
                  else if (d.mode === U.LINES) p = new i.LineSegments(u, f);
                  else if (d.mode === U.LINE_STRIP) p = new i.Line(u, f);
                  else if (d.mode === U.LINE_LOOP) p = new i.LineLoop(u, f);
                  else {
                    if (d.mode !== U.POINTS)
                      throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode);
                    p = new i.Points(u, f);
                  }
                  Object.keys(p.geometry.morphAttributes).length > 0 && V(p, a),
                    (p.name = e.createUniqueName(a.name || "mesh_" + t)),
                    k(p, a),
                    d.extensions && G(s, p, d),
                    e.assignFinalMaterial(p),
                    h.push(p);
                }
                for (let n = 0, i = h.length; n < i; n++)
                  e.associations.set(h[n], { meshes: t, primitives: n });
                if (1 === h.length) return a.extensions && G(s, h[0], a), h[0];
                const u = new i.Group();
                a.extensions && G(s, u, a), e.associations.set(u, { meshes: t });
                for (let t = 0, e = h.length; t < e; t++) u.add(h[t]);
                return u;
              })
            );
          }
          loadCamera(t) {
            let e;
            const n = this.json.cameras[t],
              r = n[n.type];
            if (r)
              return (
                "perspective" === n.type
                  ? (e = new i.PerspectiveCamera(
                      i.MathUtils.radToDeg(r.yfov),
                      r.aspectRatio || 1,
                      r.znear || 1,
                      r.zfar || 2e6
                    ))
                  : "orthographic" === n.type &&
                    (e = new i.OrthographicCamera(
                      -r.xmag,
                      r.xmag,
                      r.ymag,
                      -r.ymag,
                      r.znear,
                      r.zfar
                    )),
                n.name && (e.name = this.createUniqueName(n.name)),
                k(e, n),
                Promise.resolve(e)
              );
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
          }
          loadSkin(t) {
            const e = this.json.skins[t],
              n = [];
            for (let t = 0, i = e.joints.length; t < i; t++)
              n.push(this._loadNodeShallow(e.joints[t]));
            return (
              void 0 !== e.inverseBindMatrices
                ? n.push(this.getDependency("accessor", e.inverseBindMatrices))
                : n.push(null),
              Promise.all(n).then(function (t) {
                const n = t.pop(),
                  r = t,
                  s = [],
                  a = [];
                for (let t = 0, o = r.length; t < o; t++) {
                  const o = r[t];
                  if (o) {
                    s.push(o);
                    const e = new i.Matrix4();
                    null !== n && e.fromArray(n.array, 16 * t), a.push(e);
                  } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t]);
                }
                return new i.Skeleton(s, a);
              })
            );
          }
          loadAnimation(t) {
            const e = this.json,
              n = this,
              r = e.animations[t],
              s = r.name ? r.name : "animation_" + t,
              a = [],
              o = [],
              l = [],
              c = [],
              h = [];
            for (let t = 0, e = r.channels.length; t < e; t++) {
              const e = r.channels[t],
                n = r.samplers[e.sampler],
                i = e.target,
                s = i.node,
                u = void 0 !== r.parameters ? r.parameters[n.input] : n.input,
                d = void 0 !== r.parameters ? r.parameters[n.output] : n.output;
              void 0 !== i.node &&
                (a.push(this.getDependency("node", s)),
                o.push(this.getDependency("accessor", u)),
                l.push(this.getDependency("accessor", d)),
                c.push(n),
                h.push(i));
            }
            return Promise.all([
              Promise.all(a),
              Promise.all(o),
              Promise.all(l),
              Promise.all(c),
              Promise.all(h),
            ]).then(function (t) {
              const e = t[0],
                r = t[1],
                a = t[2],
                o = t[3],
                l = t[4],
                c = [];
              for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t],
                  s = r[t],
                  h = a[t],
                  u = o[t],
                  d = l[t];
                if (void 0 === i) continue;
                i.updateMatrix && i.updateMatrix();
                const p = n._createAnimationTracks(i, s, h, u, d);
                if (p) for (let t = 0; t < p.length; t++) c.push(p[t]);
              }
              return new i.AnimationClip(s, void 0, c);
            });
          }
          createNodeMesh(t) {
            const e = this.json,
              n = this,
              i = e.nodes[t];
            return void 0 === i.mesh
              ? null
              : n.getDependency("mesh", i.mesh).then(function (t) {
                  const e = n._getNodeRef(n.meshCache, i.mesh, t);
                  return (
                    void 0 !== i.weights &&
                      e.traverse(function (t) {
                        if (t.isMesh)
                          for (let e = 0, n = i.weights.length; e < n; e++)
                            t.morphTargetInfluences[e] = i.weights[e];
                      }),
                    e
                  );
                });
          }
          loadNode(t) {
            const e = this,
              n = this.json.nodes[t],
              i = e._loadNodeShallow(t),
              r = [],
              s = n.children || [];
            for (let t = 0, n = s.length; t < n; t++) r.push(e.getDependency("node", s[t]));
            const a = void 0 === n.skin ? Promise.resolve(null) : e.getDependency("skin", n.skin);
            return Promise.all([i, Promise.all(r), a]).then(function (t) {
              const e = t[0],
                n = t[1],
                i = t[2];
              null !== i &&
                e.traverse(function (t) {
                  t.isSkinnedMesh && t.bind(i, q);
                });
              for (let t = 0, i = n.length; t < i; t++) e.add(n[t]);
              return e;
            });
          }
          _loadNodeShallow(t) {
            const e = this.json,
              n = this.extensions,
              r = this;
            if (void 0 !== this.nodeCache[t]) return this.nodeCache[t];
            const s = e.nodes[t],
              a = s.name ? r.createUniqueName(s.name) : "",
              o = [],
              l = r._invokeOne(function (e) {
                return e.createNodeMesh && e.createNodeMesh(t);
              });
            return (
              l && o.push(l),
              void 0 !== s.camera &&
                o.push(
                  r.getDependency("camera", s.camera).then(function (t) {
                    return r._getNodeRef(r.cameraCache, s.camera, t);
                  })
                ),
              r
                ._invokeAll(function (e) {
                  return e.createNodeAttachment && e.createNodeAttachment(t);
                })
                .forEach(function (t) {
                  o.push(t);
                }),
              (this.nodeCache[t] = Promise.all(o).then(function (e) {
                let o;
                if (
                  ((o =
                    !0 === s.isBone
                      ? new i.Bone()
                      : e.length > 1
                      ? new i.Group()
                      : 1 === e.length
                      ? e[0]
                      : new i.Object3D()),
                  o !== e[0])
                )
                  for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
                if (
                  (s.name && ((o.userData.name = s.name), (o.name = a)),
                  k(o, s),
                  s.extensions && G(n, o, s),
                  void 0 !== s.matrix)
                ) {
                  const t = new i.Matrix4();
                  t.fromArray(s.matrix), o.applyMatrix4(t);
                } else void 0 !== s.translation && o.position.fromArray(s.translation), void 0 !== s.rotation && o.quaternion.fromArray(s.rotation), void 0 !== s.scale && o.scale.fromArray(s.scale);
                return (
                  r.associations.has(o) || r.associations.set(o, {}),
                  (r.associations.get(o).nodes = t),
                  o
                );
              })),
              this.nodeCache[t]
            );
          }
          loadScene(t) {
            const e = this.extensions,
              n = this.json.scenes[t],
              r = this,
              s = new i.Group();
            n.name && (s.name = r.createUniqueName(n.name)), k(s, n), n.extensions && G(e, s, n);
            const a = n.nodes || [],
              o = [];
            for (let t = 0, e = a.length; t < e; t++) o.push(r.getDependency("node", a[t]));
            return Promise.all(o).then(function (t) {
              for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
              return (
                (r.associations = ((t) => {
                  const e = new Map();
                  for (const [t, n] of r.associations)
                    (t instanceof i.Material || t instanceof i.Texture) && e.set(t, n);
                  return (
                    t.traverse((t) => {
                      const n = r.associations.get(t);
                      null != n && e.set(t, n);
                    }),
                    e
                  );
                })(s)),
                s
              );
            });
          }
          _createAnimationTracks(t, e, n, r, s) {
            const a = [],
              o = t.name ? t.name : t.uuid,
              l = [];
            let c;
            switch (
              (z[s.path] === z.weights
                ? t.traverse(function (t) {
                    t.morphTargetInfluences && l.push(t.name ? t.name : t.uuid);
                  })
                : l.push(o),
              z[s.path])
            ) {
              case z.weights:
                c = i.NumberKeyframeTrack;
                break;
              case z.rotation:
                c = i.QuaternionKeyframeTrack;
                break;
              case z.position:
              case z.scale:
                c = i.VectorKeyframeTrack;
                break;
              default:
                c = 1 === n.itemSize ? i.NumberKeyframeTrack : i.VectorKeyframeTrack;
            }
            const h = void 0 !== r.interpolation ? H[r.interpolation] : i.InterpolateLinear,
              u = this._getArrayFromAccessor(n);
            for (let t = 0, n = l.length; t < n; t++) {
              const n = new c(l[t] + "." + z[s.path], e.array, u, h);
              "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(n),
                a.push(n);
            }
            return a;
          }
          _getArrayFromAccessor(t) {
            let e = t.array;
            if (t.normalized) {
              const t = j(e.constructor),
                n = new Float32Array(e.length);
              for (let i = 0, r = e.length; i < r; i++) n[i] = e[i] * t;
              e = n;
            }
            return e;
          }
          _createCubicSplineTrackInterpolant(t) {
            (t.createInterpolant = function (t) {
              return new (this instanceof i.QuaternionKeyframeTrack ? I : L)(
                this.times,
                this.values,
                this.getValueSize() / 3,
                t
              );
            }),
              (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
          }
        }
        function K(t, e, n) {
          const r = e.attributes,
            s = [];
          function a(e, i) {
            return n.getDependency("accessor", e).then(function (e) {
              t.setAttribute(i, e);
            });
          }
          for (const e in r) {
            const n = F[e] || e.toLowerCase();
            n in t.attributes || s.push(a(r[e], n));
          }
          if (void 0 !== e.indices && !t.index) {
            const i = n.getDependency("accessor", e.indices).then(function (e) {
              t.setIndex(e);
            });
            s.push(i);
          }
          return (
            i.ColorManagement.workingColorSpace !== i.LinearSRGBColorSpace &&
              "COLOR_0" in r &&
              console.warn(
                `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${i.ColorManagement.workingColorSpace}" not supported.`
              ),
            k(t, e),
            (function (t, e, n) {
              const r = e.attributes,
                s = new i.Box3();
              if (void 0 === r.POSITION) return;
              {
                const t = n.json.accessors[r.POSITION],
                  e = t.min,
                  a = t.max;
                if (void 0 === e || void 0 === a)
                  return void console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
                if (
                  (s.set(new i.Vector3(e[0], e[1], e[2]), new i.Vector3(a[0], a[1], a[2])),
                  t.normalized)
                ) {
                  const e = j(N[t.componentType]);
                  s.min.multiplyScalar(e), s.max.multiplyScalar(e);
                }
              }
              const a = e.targets;
              if (void 0 !== a) {
                const t = new i.Vector3(),
                  e = new i.Vector3();
                for (let i = 0, r = a.length; i < r; i++) {
                  const r = a[i];
                  if (void 0 !== r.POSITION) {
                    const i = n.json.accessors[r.POSITION],
                      s = i.min,
                      a = i.max;
                    if (void 0 !== s && void 0 !== a) {
                      if (
                        (e.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                        e.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                        e.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                        i.normalized)
                      ) {
                        const t = j(N[i.componentType]);
                        e.multiplyScalar(t);
                      }
                      t.max(e);
                    } else
                      console.warn(
                        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                      );
                  }
                }
                s.expandByVector(t);
              }
              t.boundingBox = s;
              const o = new i.Sphere();
              s.getCenter(o.center),
                (o.radius = s.min.distanceTo(s.max) / 2),
                (t.boundingSphere = o);
            })(t, e, n),
            Promise.all(s).then(function () {
              return void 0 !== e.targets
                ? (function (t, e, n) {
                    let i = !1,
                      r = !1,
                      s = !1;
                    for (let t = 0, n = e.length; t < n; t++) {
                      const n = e[t];
                      if (
                        (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        void 0 !== n.COLOR_0 && (s = !0),
                        i && r && s)
                      )
                        break;
                    }
                    if (!i && !r && !s) return Promise.resolve(t);
                    const a = [],
                      o = [],
                      l = [];
                    for (let c = 0, h = e.length; c < h; c++) {
                      const h = e[c];
                      if (i) {
                        const e =
                          void 0 !== h.POSITION
                            ? n.getDependency("accessor", h.POSITION)
                            : t.attributes.position;
                        a.push(e);
                      }
                      if (r) {
                        const e =
                          void 0 !== h.NORMAL
                            ? n.getDependency("accessor", h.NORMAL)
                            : t.attributes.normal;
                        o.push(e);
                      }
                      if (s) {
                        const e =
                          void 0 !== h.COLOR_0
                            ? n.getDependency("accessor", h.COLOR_0)
                            : t.attributes.color;
                        l.push(e);
                      }
                    }
                    return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(
                      function (e) {
                        const n = e[0],
                          a = e[1],
                          o = e[2];
                        return (
                          i && (t.morphAttributes.position = n),
                          r && (t.morphAttributes.normal = a),
                          s && (t.morphAttributes.color = o),
                          (t.morphTargetsRelative = !0),
                          t
                        );
                      }
                    );
                  })(t, e.targets, n)
                : t;
            })
          );
        }
      },
      542: (t, e, n) => {
        n.r(e),
          n.d(e, {
            DEG2RAD: () => s,
            MathUtils: () => C,
            RAD2DEG: () => a,
            ceilPowerOfTwo: () => E,
            clamp: () => l,
            damp: () => p,
            degToRad: () => M,
            denormalize: () => w,
            euclideanModulo: () => c,
            floorPowerOfTwo: () => T,
            generateUUID: () => o,
            inverseLerp: () => u,
            isPowerOfTwo: () => b,
            lerp: () => d,
            mapLinear: () => h,
            normalize: () => R,
            pingpong: () => f,
            radToDeg: () => S,
            randFloat: () => v,
            randFloatSpread: () => x,
            randInt: () => _,
            seededRandom: () => y,
            setQuaternionFromProperEuler: () => A,
            smootherstep: () => g,
            smoothstep: () => m,
          });
        const i = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ];
        let r = 1234567;
        const s = Math.PI / 180,
          a = 180 / Math.PI;
        function o() {
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            r = (4294967295 * Math.random()) | 0;
          return (
            i[255 & t] +
            i[(t >> 8) & 255] +
            i[(t >> 16) & 255] +
            i[(t >> 24) & 255] +
            "-" +
            i[255 & e] +
            i[(e >> 8) & 255] +
            "-" +
            i[((e >> 16) & 15) | 64] +
            i[(e >> 24) & 255] +
            "-" +
            i[(63 & n) | 128] +
            i[(n >> 8) & 255] +
            "-" +
            i[(n >> 16) & 255] +
            i[(n >> 24) & 255] +
            i[255 & r] +
            i[(r >> 8) & 255] +
            i[(r >> 16) & 255] +
            i[(r >> 24) & 255]
          ).toLowerCase();
        }
        function l(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function c(t, e) {
          return ((t % e) + e) % e;
        }
        function h(t, e, n, i, r) {
          return i + ((t - e) * (r - i)) / (n - e);
        }
        function u(t, e, n) {
          return t !== e ? (n - t) / (e - t) : 0;
        }
        function d(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function p(t, e, n, i) {
          return d(t, e, 1 - Math.exp(-n * i));
        }
        function f(t, e = 1) {
          return e - Math.abs(c(t, 2 * e) - e);
        }
        function m(t, e, n) {
          return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
        }
        function g(t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
        }
        function _(t, e) {
          return t + Math.floor(Math.random() * (e - t + 1));
        }
        function v(t, e) {
          return t + Math.random() * (e - t);
        }
        function x(t) {
          return t * (0.5 - Math.random());
        }
        function y(t) {
          void 0 !== t && (r = t);
          let e = (r += 1831565813);
          return (
            (e = Math.imul(e ^ (e >>> 15), 1 | e)),
            (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
            ((e ^ (e >>> 14)) >>> 0) / 4294967296
          );
        }
        function M(t) {
          return t * s;
        }
        function S(t) {
          return t * a;
        }
        function b(t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        }
        function E(t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }
        function T(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        function A(t, e, n, i, r) {
          const s = Math.cos,
            a = Math.sin,
            o = s(n / 2),
            l = a(n / 2),
            c = s((e + i) / 2),
            h = a((e + i) / 2),
            u = s((e - i) / 2),
            d = a((e - i) / 2),
            p = s((i - e) / 2),
            f = a((i - e) / 2);
          switch (r) {
            case "XYX":
              t.set(o * h, l * u, l * d, o * c);
              break;
            case "YZY":
              t.set(l * d, o * h, l * u, o * c);
              break;
            case "ZXZ":
              t.set(l * u, l * d, o * h, o * c);
              break;
            case "XZX":
              t.set(o * h, l * f, l * p, o * c);
              break;
            case "YXY":
              t.set(l * p, o * h, l * f, o * c);
              break;
            case "ZYZ":
              t.set(l * f, l * p, o * h, o * c);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        }
        function w(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return t / 4294967295;
            case Uint16Array:
              return t / 65535;
            case Uint8Array:
              return t / 255;
            case Int32Array:
              return Math.max(t / 2147483647, -1);
            case Int16Array:
              return Math.max(t / 32767, -1);
            case Int8Array:
              return Math.max(t / 127, -1);
            default:
              throw new Error("Invalid component type.");
          }
        }
        function R(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return Math.round(4294967295 * t);
            case Uint16Array:
              return Math.round(65535 * t);
            case Uint8Array:
              return Math.round(255 * t);
            case Int32Array:
              return Math.round(2147483647 * t);
            case Int16Array:
              return Math.round(32767 * t);
            case Int8Array:
              return Math.round(127 * t);
            default:
              throw new Error("Invalid component type.");
          }
        }
        const C = {
          DEG2RAD: s,
          RAD2DEG: a,
          generateUUID: o,
          clamp: l,
          euclideanModulo: c,
          mapLinear: h,
          inverseLerp: u,
          lerp: d,
          damp: p,
          pingpong: f,
          smoothstep: m,
          smootherstep: g,
          randInt: _,
          randFloat: v,
          randFloatSpread: x,
          seededRandom: y,
          degToRad: M,
          radToDeg: S,
          isPowerOfTwo: b,
          ceilPowerOfTwo: E,
          floorPowerOfTwo: T,
          setQuaternionFromProperEuler: A,
          normalize: R,
          denormalize: w,
        };
      },
    },
    e = {};
  function n(i) {
    var r = e[i];
    if (void 0 !== r) return r.exports;
    var s = (e[i] = { id: i, exports: {} });
    return t[i].call(s.exports, s, s.exports, n), s.exports;
  }
  (n.m = t),
    (n.n = (t) => {
      var e = t && t.__esModule ? () => t.default : () => t;
      return n.d(e, { a: e }), e;
    }),
    (n.d = (t, e) => {
      for (var i in e)
        n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
    }),
    (n.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t) {
        if ("object" == typeof window) return window;
      }
    })()),
    (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
    (n.r = (t) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (() => {
      var t;
      n.g.importScripts && (t = n.g.location + "");
      var e = n.g.document;
      if (!t && e && (e.currentScript && (t = e.currentScript.src), !t)) {
        var i = e.getElementsByTagName("script");
        if (i.length) for (var r = i.length - 1; r > -1 && !t; ) t = i[r--].src;
      }
      if (!t) throw new Error("Automatic publicPath is not supported in this browser");
      (t = t
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/")),
        (n.p = t + "./");
    })(),
    (n.b = document.baseURI || self.location.href),
    (n.nc = void 0),
    (() => {
      var t = n(477),
        e = n(979),
        i = n(150),
        r = n(958),
        s = n(854),
        a = n(485),
        o = n(35),
        l = n(878);
      n.p;
      var c = n(379),
        h = n.n(c),
        u = n(795),
        d = n.n(u),
        p = n(569),
        f = n.n(p),
        m = n(565),
        g = n.n(m),
        _ = n(216),
        v = n.n(_),
        x = n(589),
        y = n.n(x),
        M = n(922),
        S = {};
      (S.styleTagTransform = y()),
        (S.setAttributes = g()),
        (S.insert = f().bind(null, "head")),
        (S.domAPI = d()),
        (S.insertStyleElement = v()),
        h()(M.Z, S),
        M.Z && M.Z.locals && M.Z.locals;
      var b = n(287),
        E = {};
      (E.styleTagTransform = y()),
        (E.setAttributes = g()),
        (E.insert = f().bind(null, "head")),
        (E.domAPI = d()),
        (E.insertStyleElement = v()),
        h()(b.Z, E),
        b.Z && b.Z.locals && b.Z.locals,
        n.p,
        n.p,
        n.p,
        n.p;
      const T = n.p + "right-click.png";
      async function A(t) {
        return new Promise((e) => {
          setTimeout(() => e(), t);
        });
      }
      function w(t, e, n, i) {
        t &&
          (t.animate([{ opacity: n || 1 }, { opacity: 0 }], { duration: e }),
          setTimeout(() => {
            (t.style.display = "none"), i && i();
          }, e - 100));
      }
      function R(t, e, n, i, r) {
        t &&
          ((t.style.display = i || "flex"),
          t.animate([{ opacity: 0 }, { opacity: n || 1 }], { duration: e }),
          setTimeout(() => {
            (t.style.opacity = n ? n.toString() : "1"), r && r();
          }, e - 100));
      }
      function C() {
        let t = document.querySelector("#right-mouse");
        t && (t.src = T),
          (async function () {
            let t = document.querySelector("#first"),
              e = document.querySelector("#second"),
              n = document.querySelector("#third"),
              i = document.querySelector("#fourth");
            R(t, 3e3, 1, "flex"),
              await A(3100),
              w(t, 3e3, 1, "none"),
              await A(3100),
              R(e, 3e3, 1, "flex"),
              await A(3100),
              w(e, 3e3, 1, "none"),
              await A(3100),
              R(n, 3e3, 1, "flex"),
              R(i, 3e3, 1, "flex"),
              await A(3100),
              w(n, 3e3, 1, "none"),
              w(i, 3e3, 1, "none");
          })();
      }
      function L() {
        let t = o.InputManager.GetActiveKeys(),
          e = document.querySelector("#w"),
          n = document.querySelector("#a"),
          i = document.querySelector("#s"),
          r = document.querySelector("#d"),
          s = "0px 4px 0px 3px rgb(177, 176, 176)",
          a = "0px 4px 0px 4px rgb(156, 154, 154)";
        e && (t.has("KeyW") ? (e.style.boxShadow = a) : (e.style.boxShadow = s)),
          n && (t.has("KeyA") ? (n.style.boxShadow = a) : (n.style.boxShadow = s)),
          i && (t.has("KeyS") ? (i.style.boxShadow = a) : (i.style.boxShadow = s)),
          r && (t.has("KeyD") ? (r.style.boxShadow = a) : (r.style.boxShadow = s));
      }
      !(async function () {
        let n = new e.SceneManager(),
          o = document.querySelector("#three-root");
        n.CreateScene(o, "demo-scene", !1, !1, !0);
        let c = n.activeScene;
        if (c instanceof i.Scene && c.cameraManager instanceof r.CameraManager) {
          let e = new a.Screen("sample-ui", "screenOne.html", C, L);
          n.UIManager.RegisterScreens([e]),
            c.cameraManager.CreateFirstPersonCamera(
              "player",
              75,
              0.1,
              1e3,
              { x: 0, y: 8, z: 10 },
              { x: 0, y: 0, z: 0 },
              5
            );
          var h = 0,
            u = ["#f900ff", "#ffffff", "#1aeb00", "#ea6d00", "#380cd0"],
            d = u[h],
            p = performance.now(),
            f = [];
          let r = null,
            o = null;
          c.Start(() => {
            if (c instanceof i.Scene) {
              if (
                (null == r && (r = c.objects.find((t) => "cube" == t.name)),
                null == o && (o = c.objects.find((t) => "cube-light" == t.name)),
                r && r._object && o && o._object)
              ) {
                (r._object.position.y += 0.0125 * Math.sin(0.0125 * c.frame)),
                  (o._object.intensity += 3 * Math.sin(0.0125 * c.frame)),
                  (r._object.rotation.x += 0.005),
                  (r._object.rotation.y += 0.005),
                  (r._object.rotation.z += 0.005);
                let e = performance.now();
                e - p >= 1e3 &&
                  (h + 1 <= u.length ? h++ : (h = 0),
                  (d = u[h]),
                  (r._object.material.color = new t.Color(d)),
                  (o._object.color = new t.Color(d)),
                  (p = e));
              }
              f.forEach((t) => {
                t.update(c.deltaTime);
              });
            }
          }).then(() => {
            if (c instanceof i.Scene) {
              c.primitiveObjects.CreateAmbientLight({
                name: "scene-light",
                color: "#ffffff",
                intensity: 2,
              });
              let e = { x: 10, y: 10 };
              c.primitiveObjects.CreateSkyBox({
                name: "skybox",
                scale: { x: 50, y: 50, z: 50 },
                color: "#303030",
                texturePath: "./grid.png",
                textureRepeat: e,
              }),
                c.primitiveObjects.CreatePlane({
                  name: "ground",
                  scale: { x: 50, y: 1, z: 50 },
                  position: { x: 0, y: 0, z: 0 },
                  rotation: { x: s.MathHelpers.DegreesToRadians(270), y: 0, z: 0 },
                  color: "#303030",
                  texturePath: "./grid.png",
                  textureRepeat: e,
                });
              let n = c.primitiveObjects.CreateCube(
                  {
                    name: "cube",
                    scale: { x: 1, y: 1, z: 1 },
                    position: { x: 0, y: 11, z: 5 },
                    rotation: { x: 0, y: 0, z: 0 },
                    color: d,
                    texturePath: "./grid.png",
                  },
                  !1
                ),
                r = c.primitiveObjects.CreatePointLight({
                  name: "cube-light",
                  color: d,
                  intensity: 20,
                  distance: 50,
                  decay: 1,
                  position: { x: 0, y: 0, z: 0 },
                  rotation: { x: 0, y: 0, z: 0 },
                });
              n._object.add(r._object),
                n.Instantiate(),
                new l.ObjectLoader(c).LoadGLTFModel({
                  name: "dance_crowd",
                  modelPath: "./scene.gltf",
                  scale: { x: 5, y: 5, z: 5 },
                  position: { x: 0, y: 0.1, z: -5 },
                  rotation: { x: 0, y: 0, z: 0 },
                  onLoad: (e) => {
                    (e._object.animations = e.animations),
                      e._object.animations.forEach((n) => {
                        let i = new t.AnimationMixer(e._object);
                        const r = i.clipAction(n);
                        f.push(i), r.play();
                      });
                  },
                }),
                c.audioManager.CreateAudioGroup("music"),
                c.audioManager.CreateAudioClip("music", "club_music", "./club.mp3", () => {
                  if (c instanceof i.Scene) {
                    let t = c.audioManager.audioGroups
                      .find((t) => "music" === t.groupName)
                      .audioClips.find((t) => "club_music" == t.name);
                    t && t.SetVolume(0.8),
                      setTimeout(() => {
                        c.audioManager.PlayNextInGroup("music", !0);
                      }, 1e3);
                  }
                });
            }
          });
        }
      })();
    })();
})();
//# sourceMappingURL=demo.js.map
